
;;;;;
;;@type cmd
;;@@parse-relative #f


;;;;;
;;@type Method
;;@name apply-method
;;@param gf 
;;@param method 
;;@param build-next 
;;@param args 

;;;;;
;;@type Method
;;@name apply-methods
;;@param gf 
;;@param methods 
;;@param args 

;;;;;
;;@type Method
;;@name method-more-specific?
;;@param method1 
;;@param method2 
;;@param classes 

;;;;;
;;@type Method
;;@name sort-applicable-methods
;;@param gf 
;;@param methods 
;;@param args 

;;;;;
;;@type Method
;;@name apply-generic
;;@param gf 
;;@param args 

;;;;;
;;@type Method
;;@name make
;;@param (class <method>) :rest initargs 

;;;;;
;;@type Function
;;@name slot-initialize-using-accessor!
;;@description The low-level slot accessing mechanism.  Every function or
;;method that needs to read or write to a slot eventually comes
;;down to one of these functions.
;;
;;Ordinary programs need not call these functions directly.  
;;If you ever need to call them, you have to be careful not 
;;to grab the reference to slot-accessor too long; if
;;obj's class is changed or redefined, slot-accessor
;;can no longer be used.
;;
;;@param obj 
;;@param slot-accessor 
;;@param initargs 

;;;;;
;;@type Function
;;@name slot-bound-using-accessor?
;;@description The low-level slot accessing mechanism.  Every function or
;;method that needs to read or write to a slot eventually comes
;;down to one of these functions.
;;
;;Ordinary programs need not call these functions directly.  
;;If you ever need to call them, you have to be careful not 
;;to grab the reference to slot-accessor too long; if
;;obj's class is changed or redefined, slot-accessor
;;can no longer be used.
;;
;;@param obj 
;;@param slot-accessor 

;;;;;
;;@type Function
;;@name slot-set-using-accessor!
;;@description The low-level slot accessing mechanism.  Every function or
;;method that needs to read or write to a slot eventually comes
;;down to one of these functions.
;;
;;Ordinary programs need not call these functions directly.  
;;If you ever need to call them, you have to be careful not 
;;to grab the reference to slot-accessor too long; if
;;obj's class is changed or redefined, slot-accessor
;;can no longer be used.
;;
;;@param obj 
;;@param slot-accessor 
;;@param value 

;;;;;
;;@type Function
;;@name slot-ref-using-accessor
;;@description The low-level slot accessing mechanism.  Every function or
;;method that needs to read or write to a slot eventually comes
;;down to one of these functions.
;;
;;Ordinary programs need not call these functions directly.  
;;If you ever need to call them, you have to be careful not 
;;to grab the reference to slot-accessor too long; if
;;obj's class is changed or redefined, slot-accessor
;;can no longer be used.
;;
;;@param obj 
;;@param slot-accessor 

;;;;;
;;@type Method
;;@name compute-get-n-set
;;@description The standard processes the slot definition with the following
;;slot allocations: :instance, :class,
;;each-subclass and :virtual.
;;
;;@param (class <class>) slot 

;;;;;
;;@type Method
;;@name compute-slots
;;@description The standard method walks CPL of class and gathers
;;all direct slots.  If slots with the same name are found,
;;the one of a class closer to class in CPL takes precedence.
;;
;;@param (class <class>) 

;;;;;
;;@type Method
;;@name compute-slot-accessor
;;@description Access-specifier is a value returned from
;;compute-get-n-set.  The base method creates an instance
;;of <slot-accessor> that encapsulates how to 
;;access the given slot.
;;
;;Created slot accessor objects are stored (as an assoc list using
;;slot names as keys) in the class's accessors slot.
;;Standard slot accessors and mutators, such as slot-ref,
;;slot-set!, slot-bound?, and the slot accessor
;;methods specified in :getter, :setter and :accessor
;;slot options, all go through slot accessor object eventually.
;;Specifically, those functions and methods first looks up
;;the slot accessor object of the desired slot, then calls
;;slot-ref-using-accessor etc.
;;
;;@param (class <class>) slot access-specifier 

;;;;;
;;@type Method
;;@name compute-slot-accessor
;;@description Access-specifier is a value returned from
;;compute-get-n-set.  The base method creates an instance
;;of <slot-accessor> that encapsulates how to 
;;access the given slot.
;;
;;Created slot accessor objects are stored (as an assoc list using
;;slot names as keys) in the class's accessors slot.
;;Standard slot accessors and mutators, such as slot-ref,
;;slot-set!, slot-bound?, and the slot accessor
;;methods specified in :getter, :setter and :accessor
;;slot options, all go through slot accessor object eventually.
;;Specifically, those functions and methods first looks up
;;the slot accessor object of the desired slot, then calls
;;slot-ref-using-accessor etc.
;;

;;;;;
;;@type Method
;;@name compute-get-n-set
;;@description These two generic functions are responsible to determine
;;what slots a class has, and how each slot is accessed.
;;
;;In the initialize method of a class,
;;compute-slots is called after the class's
;;direct-supers, cpl and direct-slots are set.
;;It must decide what slots the class should have, and what
;;slot options each slot should have, based on those three piece
;;of information.  The returned value should have the following
;;form, and it is used as the value of the slots slot of the class.
;;
;;example:
;;  <slots> : (<slot-definition> ...)
;;  <slot-definition> : (<slot-name> . <slot-options>)
;;  <slot-name> : symbol
;;  <slot-options> : keyword-value alternating list.
;;
;;After the slots slot of the class is set by the returned
;;value from compute-slots,
;;compute-get-n-set is called for each slot
;;to calculate how to access and modify the slot.
;;The class and the slot definition are the arguments.
;;It must return either one of the followings:
;;
;;an integer n ------
;;  This slot becomes n-th instance slot.  This is the only way to
;;  allocate a slot per instance.
;;  
;;  The base method of compute-get-n-set keeps track of the current
;;  number of allocated instance slots in the class's num-instance-slots
;;  slot.  It is not recommended for other specialized methods to use or
;;  change the value of this slot, unless you know a very good reason to
;;  override the object system behavior in deep down.  Usually it is suffice
;;  to call next-method to let the base method reserve an instnace
;;  slot for you.
;;  
;;  See the examples below for modifying instance slot access behaviors.
;;  
;;a list (get-proc set-proc bound?-proc initializable) ------
;;  The get-proc, set-proc and bound?-proc elements are procedures
;;  invoked when this slot of an instance is accessed (either via 
;;  slot-ref/slot-set!/slot-bound?, 
;;  or an accessor method specified by :getter/:setter slot options).
;;  The value other than get-proc may be #f, and can be omitted
;;  if all the values after it is also #f.  That is, the simplest
;;  form of this type of return value is a list of one element,
;;  get-proc.
;;  
;;    When this slot is about to be read, get-proc is called with
;;    an argument, the instance.  The returned value of get-proc is
;;    the value of the slot.
;;    
;;    The procedure may return #<undef> to indicate the slot is 
;;    unbound.  It triggers the slot-unbound generic function.
;;    (That is, this type of slot cannot have #<undef> as its value.)   
;;    
;;    When this slot is about to be written, set-proc is called
;;    with two arguments, the instance and the new value.  It is called
;;    purely for the side effect; the procedure may change the value
;;    of other slot of the instance, for example.
;;    
;;    If this element is #f or omitted, the slot becomes read-only; 
;;    any attempt to write to the slot will raise an error.
;;    
;;    When slot-bound? is called to check whether the slot of
;;    an instance is bound, bound?-proc is called with
;;    an argument, the instance.  It should return a boolean value
;;    which will be the result of slot-bound?.
;;    
;;    If this element is #f or omitted, slot-bound? will
;;    call get-proc and returns true if it returns
;;    #<undef>.
;;    
;;    The last element, initializable, is a flag that indicates
;;    whether this slot should be initialized when :init-value
;;    or :init-form.  
;;  
;;A <slot-accessor> object ------
;;  Access to this slot is redirected through the returned
;;  slot-accessor object.   See below for more on <slot-accessor>.
;;
;;The value returned by compute-get-n-set is immediately passed
;;to compute-slot-accessor to create a slot accessor object,
;;which encapsulates how to access and modify the slot.
;;
;;After all slot definitions are processed by compute-get-n-set
;;and compute-slot-accessor, an assoc list of 
;;slot names and <slot-accessor> objects are stored in the
;;class's accessors slot.
;;

;;;;;
;;@type Method
;;@name compute-slots
;;@description These two generic functions are responsible to determine
;;what slots a class has, and how each slot is accessed.
;;
;;In the initialize method of a class,
;;compute-slots is called after the class's
;;direct-supers, cpl and direct-slots are set.
;;It must decide what slots the class should have, and what
;;slot options each slot should have, based on those three piece
;;of information.  The returned value should have the following
;;form, and it is used as the value of the slots slot of the class.
;;
;;example:
;;  <slots> : (<slot-definition> ...)
;;  <slot-definition> : (<slot-name> . <slot-options>)
;;  <slot-name> : symbol
;;  <slot-options> : keyword-value alternating list.
;;
;;After the slots slot of the class is set by the returned
;;value from compute-slots,
;;compute-get-n-set is called for each slot
;;to calculate how to access and modify the slot.
;;The class and the slot definition are the arguments.
;;It must return either one of the followings:
;;
;;an integer n ------
;;  This slot becomes n-th instance slot.  This is the only way to
;;  allocate a slot per instance.
;;  
;;  The base method of compute-get-n-set keeps track of the current
;;  number of allocated instance slots in the class's num-instance-slots
;;  slot.  It is not recommended for other specialized methods to use or
;;  change the value of this slot, unless you know a very good reason to
;;  override the object system behavior in deep down.  Usually it is suffice
;;  to call next-method to let the base method reserve an instnace
;;  slot for you.
;;  
;;  See the examples below for modifying instance slot access behaviors.
;;  
;;a list (get-proc set-proc bound?-proc initializable) ------
;;  The get-proc, set-proc and bound?-proc elements are procedures
;;  invoked when this slot of an instance is accessed (either via 
;;  slot-ref/slot-set!/slot-bound?, 
;;  or an accessor method specified by :getter/:setter slot options).
;;  The value other than get-proc may be #f, and can be omitted
;;  if all the values after it is also #f.  That is, the simplest
;;  form of this type of return value is a list of one element,
;;  get-proc.
;;  
;;    When this slot is about to be read, get-proc is called with
;;    an argument, the instance.  The returned value of get-proc is
;;    the value of the slot.
;;    
;;    The procedure may return #<undef> to indicate the slot is 
;;    unbound.  It triggers the slot-unbound generic function.
;;    (That is, this type of slot cannot have #<undef> as its value.)   
;;    
;;    When this slot is about to be written, set-proc is called
;;    with two arguments, the instance and the new value.  It is called
;;    purely for the side effect; the procedure may change the value
;;    of other slot of the instance, for example.
;;    
;;    If this element is #f or omitted, the slot becomes read-only; 
;;    any attempt to write to the slot will raise an error.
;;    
;;    When slot-bound? is called to check whether the slot of
;;    an instance is bound, bound?-proc is called with
;;    an argument, the instance.  It should return a boolean value
;;    which will be the result of slot-bound?.
;;    
;;    If this element is #f or omitted, slot-bound? will
;;    call get-proc and returns true if it returns
;;    #<undef>.
;;    
;;    The last element, initializable, is a flag that indicates
;;    whether this slot should be initialized when :init-value
;;    or :init-form.  
;;  
;;A <slot-accessor> object ------
;;  Access to this slot is redirected through the returned
;;  slot-accessor object.   See below for more on <slot-accessor>.
;;
;;The value returned by compute-get-n-set is immediately passed
;;to compute-slot-accessor to create a slot accessor object,
;;which encapsulates how to access and modify the slot.
;;
;;After all slot definitions are processed by compute-get-n-set
;;and compute-slot-accessor, an assoc list of 
;;slot names and <slot-accessor> objects are stored in the
;;class's accessors slot.
;;

;;;;;
;;@type Method
;;@name make
;;@param (class <class>) :rest initargs 

;;;;;
;;@type Class
;;@name <class>
;;@description すべてのメタクラスのベースクラスである <class> は以下のような
;;スロットを持っています。これらのスロットは内部的な管理のためにあるので
;;クラスが初期化された後に、これらの値を変更すべきではないということに
;;注意してください。クラスの情報を得るには、これらのスロットに直接
;;アクセスするのではなく、Class object にある手続きを使うことをおすすめ
;;します。
;;
;;クラスの名前、define-class マクロに与えられたシンボルです。
;;class-name はこの値を返します。
;;
;;クラス順位リストです。class-precedence-list はこの値を返します。
;;
;;直接スーパークラスのリストです。
;;class-direct-supers はこの値を返します。
;;
;;スロットアクセサの連想リストです。これは各スロットがどのようにアクセスされる
;;べきかをカプセル化しています。
;;
;;スロット定義のリストです。class-slots はこの値を返します。
;;スロット定義についての詳細は、Slot definition object を参照してください。
;;
;;このクラスの定義で直接指定された(つまり継承したものではない)スロット定義の
;;リストです。class-direct-slots はこの値を返します。
;;
;;インスタンスにアロケートされるスロットの数です。
;;
;;このクラスを直接継承しているクラスのリストです。
;;class-direct-subclasses はこの値を返します。
;;
;;このクラスを特定化子リスト中にもつメソッドのリストです。
;;class-direct-methods はこの値を返します。
;;
;;このクラスが生成されるときの初期化引数リストです。この情報は
;;再定義されたクラスを初期化するのに使います(Class redefinition 参照)。
;;
;;このクラスがグローバル束縛をもつモジュールのリストです。
;;
;;このクラスが再定義された場合、このスロットは新しいクラスへの参照を含みます。
;;そうでない場合にはこのスロットは #f をもっています。
;;
;;このスロットの値は、このクラスがどのように生成されたかを示しています。
;;Scheme 定義のクラスは、scheme というシンボルを持っています。それ以外の
;;値は内部的に使用するだけです。
;;

;;;;;
;;@type Macro
;;@name define-method
;;@description name という名前のメソッドを定義します。すでにグローバルに name
;;に束縛されているジェネリック関数オブジェクトが存在していれば、生成された
;;メソッドはそのジェネリック関数に追加されます。name が未束縛であるか
;;またはジェネリック関数以外に束縛されているなら、新しいジェネリック関数が
;;生成され、name に束縛されて、新しいメソッドがそれに追加されます。
;;
;;specs はこのメソッドに対応する引数とその型を指定します。これは
;;lambda 形式の引数リストに似ていますが、それぞれの引数の型を指定できる
;;ところが違います。
;;
;;example:
;;  @i{specs} : ( @i{arg} ... )
;;        | ( @i{arg} ... . @i{symbol} )
;;        | ( @i{arg} ... @i{extended-spec} ...)
;;        | @i{symbol}
;;  
;;  @i{arg}   : ( @i{symbol} @i{class} )
;;        | @i{symbol}
;;
;;シンボルであれば、(@i{arg <top>)} と同じです。rest 引数の
;;型を指定することはできません。それは常にリストに束縛されるからです。
;;
;;:optional、:key、:rest等の拡張引数指定を使うことも
;;できます。(拡張引数指定についてはMaking Proceduresを参照してください)。
;;拡張引数指定は、メソッドディスパッチに関しては rest引数と同様に扱われます。
;;すなわち、省略可能引数やキーワード引数にクラスを指定することはできません。
;;
;;引数リストのクラスのリストはメソッド特定化子リストといい、
;;これを基に、ジェネリック関数は適切なメソッドを選択します。specs と
;;それに対応する特定化子リストの例をあげておきます。
;;
;;example:
;;  specs:        ((self <myclass>) (index <integer>) value)
;;  specializers: (<myclas> <integer> <top>)
;;  
;;  specs:        ((self <myclass>) obj . options)
;;  specializers: (<myclas> <top> . <top>)
;;  
;;  specs:        (obj (attr <string>))
;;  specializers: (<top> <string>)
;;  
;;  specs:        args
;;  specializers: <top>
;;  
;;  specs:        ((self <myclass>) obj :optional (a 0) (b 1) :key (c 2))
;;  specializers: (<myclas> <top> . <top>)
;;
;;その特定化子リストがジェネリック関数の中のメソッドの一つに一致するような
;;name 上のメソッドを定義すると、既存のメソッドは新しく定義された
;;メソッドに置き換えられます。
;;
;;@param name 
;;@param specs 
;;@param body 

;;;;;
;;@type Macro
;;@name define-generic
;;@description ジェネリック関数を生成し、name に束縛します。
;;
;;通常は、これを使う必要はありません。もし、まだ存在していなければ、
;;define-method マクロが暗黙裏にジェネリック関数を生成してくれるからです。
;;
;;キーワード引数classに、<generic>のサブクラスを渡すことで、
;;作られるジェネリック関数をデフォルトの<generic>クラスのインスタンスでは
;;なく指定のクラスのインスタンスにすることができます。<generic>の
;;サブクラスを定義してメソッド適用をカスタマイズする場合に便利です。
;;
;;@param name 
;;@param :key 
;;@param class 

;;;;;
;;@type Function
;;@name change-object-class
;;@description オブジェクト obj のクラスを orig-class から new-class
;;に変更します。これはジェネリック関数ではありません。
;;オブジェクトのクラスを変更するにはちょっとした秘密の内部的操作が必要で、
;;この手続きはそれを隠蔽しています。
;;
;;クラスを変更する正確なステップは以下のようになっています。
;;
;;new-class の新しいインスタンスが allocate-instance によって
;;アロケートされる。
;;
;;new-classの各スロットに対して、
;;もし、そのスロットが old-class に存在し、obj で束縛されていれば、
;;その値は obj から取り出され、新しいインスタンスにセットされる。
;;(そのスロットは持ち越されます。)
;;そうでなければ、新しいインスタンスのスロットは、Creating instance で
;;説明された手順で、標準のスロット初期化プロトコルによって初期化されます。
;;
;;最後に、新しいインスタンスの内容が obj に移植されます。すなわち、
;;obj がアイデンティティを変えることなく new-class のインスタンス
;;となります。
;;
;;objに対してnew-classのinitilize メソッドは呼ばれないことに
;;注意してください。必要なら、独自の change-class メソッドを
;;定義してintializeを呼ぶようにすることができます。
;;
;;change-object-class は obj を返します。
;;
;;@param obj 
;;@param orig-class 
;;@param new-class 

;;;;;
;;@type Method
;;@name change-class
;;@description オブジェクト obj のクラスを new-class に変更します。
;;デフォルトのメソッドは単に change-object-class 手続きを呼ぶだけです。
;;
;;@param (obj <object>) (new-class <class>) 

;;;;;
;;@type Method
;;@name change-class
;;@description オブジェクト obj のクラスを new-class に変更します。
;;デフォルトのメソッドは単に change-object-class 手続きを呼ぶだけです。
;;

;;;;;
;;@type Method
;;@name slot-bound-using-class?
;;@description slot-ref、slot-set!、slot-bound? のジェネリック
;;関数版です。class は object のクラスでなければなりません。
;;
;;これらの関数は、ジェネリックであることに加えて、
;;obj のクラスが再定義されてもクラスの再定義を起動しない
;;(そのような場合、classは obj の元々のクラスで
;;なければならない)という点で手続き版とは違います。
;;
;;覚書: CLOS とはちがい、slot-ref などは、その中でジェネリック
;;関数版を呼ぶことはありません。それゆえ、slot-ref-using-class を
;;特定化することによって、slot-ref をカスタマイズすることはできません。
;;つまり、これらのジェネリック関数の主たる目的は change-class 
;;メソッドの内部で使われることです。とくに、slot-ref などは
;;クラス再定義を再度起動する(詳細については Changing classes を
;;参照)ので、obj の再定義中には使えません。
;;
;;@param (class <class>) (obj <object>) slot-name 

;;;;;
;;@type Method
;;@name slot-set-using-class!
;;@description slot-ref、slot-set!、slot-bound? のジェネリック
;;関数版です。class は object のクラスでなければなりません。
;;
;;これらの関数は、ジェネリックであることに加えて、
;;obj のクラスが再定義されてもクラスの再定義を起動しない
;;(そのような場合、classは obj の元々のクラスで
;;なければならない)という点で手続き版とは違います。
;;
;;覚書: CLOS とはちがい、slot-ref などは、その中でジェネリック
;;関数版を呼ぶことはありません。それゆえ、slot-ref-using-class を
;;特定化することによって、slot-ref をカスタマイズすることはできません。
;;つまり、これらのジェネリック関数の主たる目的は change-class 
;;メソッドの内部で使われることです。とくに、slot-ref などは
;;クラス再定義を再度起動する(詳細については Changing classes を
;;参照)ので、obj の再定義中には使えません。
;;
;;@param (class <class>) (obj <object>) slot-name value 

;;;;;
;;@type Method
;;@name slot-ref-using-class
;;@description slot-ref、slot-set!、slot-bound? のジェネリック
;;関数版です。class は object のクラスでなければなりません。
;;
;;これらの関数は、ジェネリックであることに加えて、
;;obj のクラスが再定義されてもクラスの再定義を起動しない
;;(そのような場合、classは obj の元々のクラスで
;;なければならない)という点で手続き版とは違います。
;;
;;覚書: CLOS とはちがい、slot-ref などは、その中でジェネリック
;;関数版を呼ぶことはありません。それゆえ、slot-ref-using-class を
;;特定化することによって、slot-ref をカスタマイズすることはできません。
;;つまり、これらのジェネリック関数の主たる目的は change-class 
;;メソッドの内部で使われることです。とくに、slot-ref などは
;;クラス再定義を再度起動する(詳細については Changing classes を
;;参照)ので、obj の再定義中には使えません。
;;
;;@param (class <class>) (obj <object>) slot-name 

;;;;;
;;@type Function
;;@name class-slot-bound?
;;@description スロットの:allocationオプションが:classもしくは
;;:each-subclassである場合、これらの手続きを使って、
;;インスタンス無しでそれらのスロットの値を取得/設定できます。
;;
;;@param class 
;;@param slot-name 
;;@param obj 

;;;;;
;;@type Function
;;@name class-slot-set!
;;@description スロットの:allocationオプションが:classもしくは
;;:each-subclassである場合、これらの手続きを使って、
;;インスタンス無しでそれらのスロットの値を取得/設定できます。
;;
;;@param class 
;;@param slot-name 
;;@param obj 

;;;;;
;;@type Function
;;@name class-slot-ref
;;@description スロットの:allocationオプションが:classもしくは
;;:each-subclassである場合、これらの手続きを使って、
;;インスタンス無しでそれらのスロットの値を取得/設定できます。
;;
;;@param class 
;;@param slot-name 

;;;;;
;;@type Method
;;@name slot-missing
;;@description このジェネリック関数は存在しないスロットの値を取り出そうとしたとき、あるいは
;;設定しようとしたときに呼びだされます。このジェネリック関数の返り値は、
;;値を得ようとした呼出しもとに返されます。
;;
;;デフォルトのメソッドは単にエラーのシグナルをあげるだけです。
;;
;;@param (class <class>) obj slot :optional value 

;;;;;
;;@type Method
;;@name slot-missing
;;@description このジェネリック関数は存在しないスロットの値を取り出そうとしたとき、あるいは
;;設定しようとしたときに呼びだされます。このジェネリック関数の返り値は、
;;値を得ようとした呼出しもとに返されます。
;;
;;デフォルトのメソッドは単にエラーのシグナルをあげるだけです。
;;

;;;;;
;;@type Method
;;@name slot-unbound
;;@description このジェネリック関数は束縛されていないスロットの値を取り出そうとしたときに
;;呼び出されます。このジェネリック関数の返り値は値を得ようとした呼出しもとに
;;返されます。
;;
;;デフォルトのメソッドは単にエラーのシグナルをあげるだけです。
;;
;;@param (class <class>) obj slot 

;;;;;
;;@type Method
;;@name slot-unbound
;;@description このジェネリック関数は束縛されていないスロットの値を取り出そうとしたときに
;;呼び出されます。このジェネリック関数の返り値は値を得ようとした呼出しもとに
;;返されます。
;;
;;デフォルトのメソッドは単にエラーのシグナルをあげるだけです。
;;

;;;;;
;;@type Method
;;@name ref
;;@description これらのメソッドはそれぞれ、単に slot-ref および slot-set!
;;を呼ぶだけです。直接 slot-ref や slot-set! を呼ぶよりも
;;効率はすこし悪いですが、プログラムコードはコンパクトになります。
;;
;;@param (obj <object>) (slot <symbol>) 

;;;;;
;;@type Function
;;@name slot-pop!
;;@description slot-push!と逆の操作です。objのslotの値が
;;ペアの場合、そのcarをslotの値から取り除き、取り除かれた値を返します。
;;
;;slotの値がペアでない、あるいはslotが未束縛の場合、
;;fallbackが与えられていればそれが返され、そうでなければエラーが報告されます。
;;
;;@param obj 
;;@param slot 
;;@param :optional 
;;@param fallback 

;;;;;
;;@type Function
;;@name slot-push!
;;@description この関数は、一般的なイディオムの実装です。
;;これは以下のようなコードで定義できます(が、将来のバージョンでは
;;最適化されるでしょう)。
;;example:
;;  (define (slot-push! obj slot value)
;;    (slot-set! obj slot (cons value (slot-ref obj slot))))
;;
;;@param obj 
;;@param slot 
;;@param value 

;;;;;
;;@type Function
;;@name slot-exists?
;;@description objがslotを持っていれば真を返します。
;;
;;@param obj 
;;@param slot 

;;;;;
;;@type Function
;;@name slot-bound?
;;@description オブジェクトobjのスロットslotが束縛されていれば真を、
;;そうでなければ偽を返します。
;;
;;オブジェクトが指定したスロットを持っていない場合は、ジェネリック関数
;;slot-missingが3つの引数、objのクラス、obj、
;;slotを伴って呼び出されます。
;;
;;@param obj 
;;@param slot 

;;;;;
;;@type Function
;;@name slot-set!
;;@description オブジェクトobjのスロットslotの値を、valueに
;;セットします。
;;
;;オブジェクトが指定したスロットを持っていない場合は、ジェネリック関数
;;slot-missingが4つの引数、objのクラス、obj、
;;slot、valueを伴って呼び出されます。
;;
;;@param obj 
;;@param slot 
;;@param value 

;;;;;
;;@type Function
;;@name slot-ref
;;@description オブジェクトobjのスロットslotの値を返します。
;;
;;指定したスロットが値に束縛されていない場合、ジェネリック関数
;;slot-unboundが3つの引数、objのクラス、obj、slot
;;を伴って呼び出されます。slot-unboundのデフォルトの振る舞いは、
;;エラーの通知です。
;;
;;オブジェクトが指定されたスロットを持っていない場合は、ジェネリック関数
;;slot-missingが3つの引数、objのクラス、obj、slotを
;;伴って呼び出されます。slot-missingのデフォルトの振る舞いは、
;;エラーの通知です。
;;
;;@param obj 
;;@param slot 

;;;;;
;;@type Method
;;@name initialize
;;@description <object> に対するデフォルトの初期化メソッドは以下のように働きます。
;;
;;  そのクラスの初期化可能なスロットのそれぞれに対して、
;;    もし (そのスロットが :init-keyword スロットオプションを持ち、「かつ」
;;    そのキーワードが initargs 中にある)
;;    そのときは、対応する値がそのスロットを初期化するのに使われます。
;;    そうではないとき、もし、そのスロットが、:init-value スロットオプションを
;;    持てば、そのオプションに与えられた値がそのスロットを初期化するのに使われます。
;;    そうでもないとき、もし、そのスロットが、:init-thunk スロットオプションを
;;    持てば、その thunk が呼ばれその返り値が、そのスロットを初期化するのに
;;    使われます。
;;    さらにどれでもなければ、そのスロットは未束縛のままです。
;;
;;デフォルトのスロットアロケーションクラスのなかで、インスタンスアロケート
;;スロットだけが初期化可能で、上の流れで処理されます。クラスアロケート
;;スロット(すなわち、スロットアロケーションが :class あるいは
;;:each-subclass のどちらかの場合)は、:init-value あるいは
;;:init-form スロットオプションが与えられていれば、クラスオブジェクト
;;生成時に初期化されます。仮想スロットが、初期化されることはありません。
;;
;;ユーザ定義アロケーションクラスは、初期化可能にも不可能にも設定することが
;;できます。詳しくは Metaobject protocol を参照してください。
;;
;;initialize メソッドを特定化する場合には next-method が
;;確実に呼ばれるようにして、新しく生成されたインスタンスのすべての
;;スロットにアクセスする前にデフォルトの流れで、そのスロットが正しく
;;初期化されるようにしてください。
;;
;;@param (obj <object>) initargs 

;;;;;
;;@type Method
;;@name initialize
;;@description <object> に対するデフォルトの初期化メソッドは以下のように働きます。
;;
;;  そのクラスの初期化可能なスロットのそれぞれに対して、
;;    もし (そのスロットが :init-keyword スロットオプションを持ち、「かつ」
;;    そのキーワードが initargs 中にある)
;;    そのときは、対応する値がそのスロットを初期化するのに使われます。
;;    そうではないとき、もし、そのスロットが、:init-value スロットオプションを
;;    持てば、そのオプションに与えられた値がそのスロットを初期化するのに使われます。
;;    そうでもないとき、もし、そのスロットが、:init-thunk スロットオプションを
;;    持てば、その thunk が呼ばれその返り値が、そのスロットを初期化するのに
;;    使われます。
;;    さらにどれでもなければ、そのスロットは未束縛のままです。
;;
;;デフォルトのスロットアロケーションクラスのなかで、インスタンスアロケート
;;スロットだけが初期化可能で、上の流れで処理されます。クラスアロケート
;;スロット(すなわち、スロットアロケーションが :class あるいは
;;:each-subclass のどちらかの場合)は、:init-value あるいは
;;:init-form スロットオプションが与えられていれば、クラスオブジェクト
;;生成時に初期化されます。仮想スロットが、初期化されることはありません。
;;
;;ユーザ定義アロケーションクラスは、初期化可能にも不可能にも設定することが
;;できます。詳しくは Metaobject protocol を参照してください。
;;
;;initialize メソッドを特定化する場合には next-method が
;;確実に呼ばれるようにして、新しく生成されたインスタンスのすべての
;;スロットにアクセスする前にデフォルトの流れで、そのスロットが正しく
;;初期化されるようにしてください。
;;

;;;;;
;;@type Method
;;@name allocate-instance
;;@description classの新規にアロケートされた、初期化されていないインスタンスを返します。
;;
;;@param (class <class>) initargs 

;;;;;
;;@type Method
;;@name allocate-instance
;;@description classの新規にアロケートされた、初期化されていないインスタンスを返します。
;;

;;;;;
;;@type Method
;;@name make
;;@description class のインスタンスを生成し、それを返します。arg ... は
;;典型的な場合には、そのインスタンスを初期化するためのキーワード値のリストです。
;;
;;@param (class <class>) arg ... 

;;;;;
;;@type Method
;;@name make
;;@description class のインスタンスを生成し、それを返します。arg ... は
;;典型的な場合には、そのインスタンスを初期化するためのキーワード値のリストです。
;;

;;;;;
;;@type Function
;;@name slot-definition-option
;;@description slot-def のスロットオプション option の値を返します。
;;そのようなオプションがない場合には、default が与えられていれば
;;それを返し、さもなければ、エラーシグナルがあがります。
;;
;;@param slot-def 
;;@param option 
;;@param :optional 
;;@param default 

;;;;;
;;@type Function
;;@name slot-definition-accessor
;;@description それぞれ、slot-def の :getter、:setter および
;;:accessor スロットオプションの値を返します。
;;
;;@param slot-def 

;;;;;
;;@type Function
;;@name slot-definition-setter
;;@description それぞれ、slot-def の :getter、:setter および
;;:accessor スロットオプションの値を返します。
;;
;;@param slot-def 

;;;;;
;;@type Function
;;@name slot-definition-getter
;;@description それぞれ、slot-def の :getter、:setter および
;;:accessor スロットオプションの値を返します。
;;
;;@param slot-def 

;;;;;
;;@type Function
;;@name slot-definition-allocation
;;@description slot-def の :allocation オプションの値を返します。
;;
;;@param slot-def 

;;;;;
;;@type Function
;;@name slot-definition-options
;;@description slot-def のスロットオプションのキーワード値リストを返します。
;;
;;@param slot-def 

;;;;;
;;@type Function
;;@name slot-definition-name
;;@description スロット定義オブジェクト slot-def で与えられたスロットの名前を
;;返します。
;;
;;@param slot-def 

;;;;;
;;@type Function
;;@name class-slot-accessor
;;@description class で slot-name で指定したスロットの
;;スロットアクセサオブジェクトを返します。
;;スロットアクセサオブジェクトは内部オブジェクトで与えられたスロットへの
;;アクセス方法、変更方法、初期化の方法という情報をカプセル化しています。
;;
;;メタオブジェクトプロトコルを使って特別なスロットを定義するのでなければ、
;;通常スロットアクセサオブジェクトを扱う必要はありません。
;;
;;@param class 
;;@param slot-name 

;;;;;
;;@type Function
;;@name class-direct-methods
;;@description classを特定化子中にもつメソッドのリストを返します。
;;
;;@param class 

;;;;;
;;@type Function
;;@name class-direct-slots
;;@description 当該クラスで直接定義されている(つまりスーパークラスから継承された
;;ものではない)スロット定義のリストを返します。この情報は、クラスの
;;初期化の際にスロットの継承を処理するために利用されます。
;;
;;@param class 

;;;;;
;;@type Function
;;@name class-slot-definition
;;@description クラス class 中の slot-name で指定されたスロットの
;;スロット定義を返します。class が指定した名前のスロットを
;;持たなければ #f が返ります。
;;
;;@param class 
;;@param slot-name 

;;;;;
;;@type Function
;;@name class-slots
;;@description class の スロット定義 のリストを返します。スロット定義は
;;リストで、その car 部はスロット名、cdr 部はスロットオプションを指定する
;;キーワード値のリストです。スロット定義内部を覗いてスロットのもつ性格を
;;知ることができます。詳しくは Slot definition object を
;;参照してください。
;;
;;与えられたクラスのスロット名のリストを得るための標準的な方法は、
;;(map slot-definition-name (class-slots class)) です。
;;
;;@param class 

;;;;;
;;@type Function
;;@name class-direct-subclasses
;;@description class の直接サブクラスのリストを返します。
;;直接サブクラスは class を直接継承しているクラスです。
;;<T> が <S> の直接サブクラスであれば、
;;<S> は <T> の直接スーパークラスです。
;;
;;@param class 

;;;;;
;;@type Function
;;@name class-direct-supers
;;@description class の直接スーパークラスのリストを返します。
;;直接スーパークラスは class が直接継承しているクラスです。
;;
;;example:
;;  (class-direct-supers <string>)
;;    ==> (#<class <sequence>>)
;;
;;@param class 

;;;;;
;;@type Function
;;@name class-precedence-list
;;@description class のクラス順位リストを返します。
;;
;;example:
;;  (class-precedence-list <string>)
;;    ==> (#<class <string>>
;;        #<class <sequence>>
;;        #<class <collection>>
;;        #<class <top>>)
;;
;;@param class 

;;;;;
;;@type Function
;;@name class-name
;;@description class の名前を返します。
;;
;;example:
;;  (class-name <string>) ==> <string>
;;
;;@param class 

;;;;;
;;@type Macro
;;@name define-class
;;@description 引数によって指定されたクラスオブジェクトを作成し、それを name に
;;グローバルに束縛します。このマクロはトップレベルでのみ使うことができます。
;;
;;Supers はそのクラスが継承する直接のスーパークラスのリストです。
;;多重継承も使えます。継承の詳細についてはInheritance を参照して下さい。
;;
;;Slot-spec は「スロット」の仕様で、他の言語ではよく
;;「フィールド」や「インスタンス変数」と呼ばれるものです 
;;(slot-spec を使って「クラス変数」を指定することもできます)。
;;slot-spec の最も単純なフォームはシンボルそのもので、その名前が
;;スロットであるものです。あるいは、最初の要素がシンボルで残りの要素が
;;キーワードと値が交互に来るリストを渡すこともできます。
;;
;;このリストフォームは、スロットの名前を定義するだけでなく、そのスロットの
;;振る舞いも定義します。スロットの定義については以下で説明します。
;;
;;最後に、option ... は、クラスオブジェクトがどのように
;;作られるかを指定する、キーワードと値が交互に来るリストです。
;;
;;このマクロでは1つのキーワード引数、:metaclass により、
;;メタクラス(他のクラスをインスタンス化するクラス)を指定できます。
;;他のオプションはクラスオブジェクトを作成するために、make
;;メソッドに渡されます。メタクラスの使用方法については、
;;Class instantiationを参照。
;;
;;@param name 
;;@param supers 
;;@param (slot-spec ...) option ... 

;;;;;
;;@type Function
;;@name current-class-of
;;@description obj のクラスメタオブジェクトを返します。obj のクラスが
;;再定義されてしまった場合でも、obj がその変更に合せて更新されて
;;いない場合には、この手続きは obj の元のクラスを返します。
;;この手続きは、obj を更新しません。
;;
;;この手続きはめったに必要にはなりません。必要になるのは change-class
;;メソッド内で、obj の更新のトリガーを引きたくないような場合
;;(無限ループを起す可能性がある場合)です。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name is-a?
;;@description objがclassのインスタンスであるか、classのサブクラスの
;;インスタンスである場合に、真を返します。
;;
;;example:
;;  (is-a? 3 <integer>)   ==> #t
;;  (is-a? 3 <real>)      ==> #t
;;  (is-a? 5+3i <real>)   ==> #f
;;  (is-a? :foo <symbol>) ==> #f
;;
;;@param obj 
;;@param class 

;;;;;
;;@type Function
;;@name class-of
;;@description objのクラスを返します。
;;
;;example:
;;  (class-of 3)         ==> #<class <integer>>
;;  (class-of "foo")     ==> #<class <string>>
;;  (class-of <integer>) ==> #<class <class>>
;;
;;@param obj 

;;;;;
;;@type Macro
;;@name require-extension
;;@description clauseで指定した拡張を以降のプログラムで利用可能にします。
;;
;;clauseは以下の形式になります。
;;example:
;;  (extension-id extension-arg ...)
;;
;;現時点では、srfiのみextension-idとして使えます。その引数
;;はSRFIの番号です。
;;
;;たとえば、以下の
;;example:
;;  (require-extension (srfi 1 13 14))
;;
;;は以下の Gauche の use 形式にほぼ対応します。
;;example:
;;  (use srfi-1)
;;  (use srfi-13)
;;  (use srfi-14)
;;
;;@param clause 
;;@param ... 

;;;;;
;;@type Function
;;@name every
;;@description [SRFI-1]
;;clist の各要素に pred を順に適用し、predが
;;偽を返した場合、直ちに偽を返します。全てのpredの適用が
;;偽でない値を返した場合は、最後に返された値が返されます。
;;
;;@param pred 
;;@param clist1 
;;@param clist2 
;;@param ... 

;;;;;
;;@type Function
;;@name any
;;@description [SRFI-1]
;;clist の各要素に pred を適用し、predが偽でない
;;値を返したら直ちにその値を返します。
;;predが偽でない値を返す前にリストの要素を使いきってしまったら
;;#fが返ります。
;;
;;@param pred 
;;@param clist1 
;;@param clist2 
;;@param ... 

;;;;;
;;@type Function
;;@name find
;;@description [SRFI-1] clist の各要素に対して左から右に pred を適用し、
;;pred が真を返す最初の要素を返します。predを満たす要素が
;;無い場合は#fを返します。
;;
;;@param pred 
;;@param clist 

;;;;;
;;@type Function
;;@name fold
;;@description [SRFI-1] 基本リスト反復演算子です。単一のリスト
;;clist1 = (e1 e2 ... en) 
;;を与えられたときには、以下を返します。
;;example:
;;  (kons en ... (kons e2 (kons e1 knil)) ... ) 
;;
;;n 本のリストが与えられた場合には、kons 関数は n+1 個の引数
;;をとる関数でなければなりません。それぞれのリストから要素をひとつずつと、
;;初期値 knil である「種」あるいは畳み込み状態とよばれるものです。
;;この畳み込み演算は、もっとも短いリストの要素がなくなったところで終了します。
;;与えられるリストの少くともひとつは有限でなければなりません。
;;
;;例:
;;example:
;;  (fold + 0 '(3 1 4 1 5 9)) ==> 23 ;@r{sum up the elements}
;;  (fold cons '() '(a b c d e)) ==> (e d c b a) ;reverse
;;  (fold cons* '() '(a b c) '(1 2 3 4 5))
;;      ==> (c 3 b 2 a 1) ;@r{n-ary case}
;;
;;@param kons 
;;@param knil 
;;@param clist1 
;;@param clist2 
;;@param ... 

;;;;;
;;@type Function
;;@name split-at
;;@description [SRFI-1] split-at はリスト x をインデックス i の
;;位置で分割し、最初の i 個の要素からなるリストと、残りの末尾とを
;;返します。
;;example:
;;  (split-at '(a b c d e) 2) ==> (a b) (c d e)
;;split-at! はその場で更新されるバージョンです。
;;これは x を破壊的に更新するかもしれません。
;;
;;@param x 
;;@param i 

;;;;;
;;@type Function
;;@name null-list?
;;@description [SRFI-1] list が空リスト () なら #t を返します。
;;それ以外のときは #f を返します。
;;
;;@param list 

;;;;;
;;@type Function
;;@name dotted-list?
;;@description [SRFI-1] x が有限の大きさで、空リストで終端していないリストなら
;;#t を返します。これには、ペアではなく、空リストもない値(たとえば
;;シンボルや数値)のような長さ0のドットリストと考えられるものを含みます。
;;
;;@param x 

;;;;;
;;@type Function
;;@name circular-list?
;;@description [SRFI-1] x が循環リストであれば #t を返します。
;;
;;@param x 

;;;;;
;;@type Function
;;@name proper-list?
;;@description [SRFI-1] x が真性リストであれば #t を返します。
;;
;;@param x 

;;;;;
;;@type Macro
;;@name cond-expand
;;@description [SRFI-0]
;;Gauche が feature-requirement をサポートしていれば、このマクロは
;;command-or-definition ... を展開します。
;;異るScheme の実装による機能の差異を吸収するのに使えると言えるでしょう。
;;
;;feature-requiremnt は以下のような構文でなければなりません。
;;example:
;;  feature-requirement
;;    : feature-identifier
;;    | (and feature-requirement ...)
;;    | (or  feature-requirement ...)
;;    | (not feature-requirement)
;;
;;feature-identifier は機能を示すシンボルです。ある機能が Gauche で
;;サポートされているなら、それは、feature-requirement を満たします。
;;より複雑な条件を構成するために、feature-requirement のブール代数による
;;組み合わせを用いることが出来ます。
;;
;;このマクロは feature-requirement を順にテストし、そのひとつが
;;満たされたら、対応する command-or-definition ... に展開されます。
;;
;;最後の節は、feature-requirement ではなく、else で始めることも
;;できます。これ以前に満たされた条件がない場合には、このマクロは else 節の
;;command-or-definition に展開されます。もし、else 節がなく、
;;満たされる条件節がひとつもなければ、エラーが発生します。
;;
;;現時点の Gauche では、サポートされている SRFI の機能は、srfi 名
;;(たとえば、srfi-1)で識別されます(サポートされている SRFI に
;;ついては Standard conformance を参照してください)。
;;また、シンボル gauche も feature-identifier として認識されます。
;;
;;srfi-13 (文字列ライブラリ)を必要とするプログラムを書いているとしましょう。
;;Gauche では、標準的には、以下のようにします。
;;
;;example:
;;  (use srfi-13)
;;  
;;  ;; ... あなたのプログラム ...
;;
;;しかし、この 'use' マクロは Gauche 専用で、他の Scheme の実装では
;;動作しません。代りに以下のように書くことができます。
;;
;;example:
;;  (cond-expand
;;    (srfi-13
;;      ;; ... あなたのプログラム ...
;;    ))
;;
;;その実装が srfi-13 をサポートしていれば、この形式は「あなたの
;;プログラム」に展開されます。Gauche では、この場合に
;;内部で(use srfi-13)を呼び出します。
;;
;;上記のフォームは実装がsrfi-13をサポートしていなければエラーとなります。
;;そのような実装の上でもプログラムを走らせたい時は、
;;代替となるライブラリ定義を提供すると良いでしょう。
;;
;;example:
;;  (cond-expand
;;   (srfi-13
;;     ;; ... あなたのプログラム ...
;;   )
;;   (else
;;     (load "my-srfi-13-implementation")
;;     ;; ... あなたのプログラム ...
;;   ))
;;
;;@param (feature-requirement command-or-definition 
;;@param ...) ... 

;;;;;
;;@type Macro
;;@name time
;;@description 式expr expr2 ... を順に評価し、最後の式の結果を返します。
;;結果が返される前に、全ての式の評価にかかった実(経過)時間および
;;ユーザースペース、カーネルスペースで費されたCPU時間がカレントエラーポートに
;;報告されます。
;;
;;現在の実装は、経過時間に対してはsys-gettimeofday
;;(Time参照)を、CPU時間に対してはsys-times
;;(System inquiry参照)を用いています。従って、
;;それぞれの数値の分解能はこれらの手続きが用いているシステムコールに依存します。
;;CPU時間は10ms単位で、経過時間はそれより細かいことが多いです。
;;但しgettimeofday(2)コールをサポートしていないOSでは経過時間が最悪の場合
;;秒単位になります。
;;
;;example:
;;  gosh> (time (length (sort (call-with-input-file "/usr/share/dict/words"
;;                                                  port->string-list))))
;;  ;(time (length (sort (call-with-input-file "/usr/share/dict/words" port- ...
;;  ; real   0.357
;;  ; user   0.350
;;  ; sys    0.000
;;  45427
;;
;;@param expr 
;;@param expr2 
;;@param ... 

;;;;;
;;@type Class
;;@name <uncaught-exception>
;;@description 待機していたスレッドが捕捉されない例外により終了された場合に
;;thread-join!により投げられる例外。
;;<thread-exception>を継承し、スロットを1つ持ちます。
;;
;;そのスレッドの終了の原因となった例外。
;;

;;;;;
;;@type Class
;;@name <terminated-thread-exception>
;;@description 待機していたスレッドが(thread-terminate!により)異常終了した
;;場合に(thread-join!により)投げられる例外。
;;<thread-exception>を継承し、スロットを1つ持ちます。
;;
;;この例外の原因となったスレッドを終了したスレッド。
;;

;;;;;
;;@type Class
;;@name <abandoned-mutex-exception>
;;@description ロックされるmutexが、unlocked/abandoned(ロックされておらず、放棄された状態)
;;であるときにmutex-lock!により投げられる例外。
;;<thread-exception>を継承しています。スロットを1つ持ちます。
;;
;;この例外の原因となったmutex。
;;

;;;;;
;;@type Class
;;@name <join-timeout-exception>
;;@description 待機していたスレッドが戻る前にタイムアウトに達した時にthread-join!によって
;;投げられる例外。<thread-exception>を継承しています。
;;

;;;;;
;;@type Class
;;@name <thread-exception>
;;@description スレッド関連の例外の基底クラスです。<exception>クラスを継承しています。
;;スロットを1つ持っています。
;;
;;この例外を投げたスレッド。
;;

;;;;;
;;@type Function
;;@name current-thread
;;@description [SRFI-18]、[SRFI-21]
;;現在のスレッドを返します。
;;

;;;;;
;;@type Class
;;@name <thread>
;;@description スレッドを表すクラスです。それぞれのスレッドは、POSIXスレッドにより
;;評価される関連付けられた手続きを持ちます。手続きが正常に戻ると、
;;その結果は内部的な``結果''スロットに格納され、thread-join!により
;;取得することができます。例外が投げられるか
;;thread-terminate!により終了されるかで、手続きが異常終了すると、
;;例外条件が内部的な``結果としての例外''スロットに格納され、
;;その例外条件は終了したスレッドに対してthread-join!を
;;呼ぶスレッドへと渡されます。
;;
;;それぞれのスレッドは独自の動的環境と動的なハンドラスタックを持っています。
;;あるスレッドが生成されると、その動的な環境は生成者の動的な環境によって
;;初期化されます。そのスレッドの動的なハンドラスタックは初期においては空です。
;;
;;スレッドは以下の4つの状態のうちのひとつを取ります。thread-state手続きで
;;スレッドの状態を調べることができます。
;;
;;new ------
;;  まだ作られたばかりで起動されてない状態です。make-threadが返すスレッドは
;;  この状態です。スレッドがひとたび起動されると、そのスレッドがこの状態に戻ることは
;;  決してありません。
;;  この時点ではPOSIXスレッドはまだ作られません。thread-start!によって
;;  POSIXスレッドが作られ、Gaucheのスレッドを実行します。
;;runnable ------
;;  thread-start!によって起動されたスレッドはこの状態になります。
;;  スレッドがシステムコールによるブロックされている時もその状態はrunnable
;;  であることに注意してください。
;;stopped ------
;;  スレッドがthread-stop!によって止められるとこの状態になります。
;;  この状態のスレッドはthread-cont!によって再びrunnableになり、
;;  止められた時点から実行を再開することができます。
;;terminated ------
;;  割り当てられたコードの実行が終了したり、thread-terminate!によって
;;  強制的に終了させられた時に、スレッドはこの状態になります。
;;  一度この状態になると他の状態に遷移することはありません。
;;
;;複数のスレッドで共有されるリソースへのアクセスは、同期化プリミティブにより
;;明示的に保護されなければなりません。Synchronization primitives参照。
;;
;;ポートへのアクセスはGaucheによりシリアライズされます。
;;複数のスレッドが1つのポートへの書き込みを試みた場合、それらの出力は
;;混じることもありますが、失われる出力はなく、そのポートのステータスは
;;一貫性が保たれます。複数のスレッドが1つのポートからの読み込みを試みた
;;場合、1つの読み込みプリミティブ(例えば、readやread-char、
;;read-lineなど)がアトミックに実行されます。
;;
;;シグナルハンドラは全てのスレッドで共有されますが、それぞれのスレッドは
;;独自のシグナルマスクを持ちます。詳細は、Signals and threadsを参照。
;;
;;スレッドオブジェクトは以下の外部スロットを持ちます。
;;
;;スレッドに関連付けられる名前。
;;これは単にアプリケーションにとっての便宜を図るためのものです。
;;原始となるスレッドは``root''という名前を持ちます。
;;
;;アプリケーションが使うスレッドローカルなスロット。
;;

;;;;;
;;@type Method
;;@name fold-right
;;@description リストに対するfold-rightの総称関数版です。
;;foldと同じように、このメソッドは種となる値 (初期値はknil)
;;を受渡しながら、高階関数konsを与えられたシーケンスの各要素に
;;適用してゆきます。foldとfold-rightの違いは
;;要素間の結合の順序にあります。
;;
;;ひとつだけのシーケンス[E0, E1, ..., En]に適用する場合、
;;foldとfold-rightはそれぞれ以下のように動作します。
;;
;;example:
;;  fold:
;;    (kons En (kons En-1 (kons ... (kons E1 (kons E1 knil)) ...)))
;;  
;;  fold-right
;;    (kons E0 (kons E1 (kons ... (kons En-1 (kons En knil)) ...)))
;;
;;このメソッドは<collection>に対しては提供されていません。
;;コレクションは要素の順序を規定しないからです。
;;
;;@param kons 
;;@param knil 
;;@param (seq <sequence>) ... 

;;;;;
;;@type Method
;;@name ref
;;@description シーケンスseqのindex番目の要素を返します。
;;このメソッドによって、全てのシーケンスが統一的にアクセスできます。
;;
;;indexが負値だったりシーケンスのサイズ以上だった場合は、
;;fallbackが与えられていればそれが返され、
;;そうでなければエラーとなります。
;;
;;example:
;;  (ref '(a b c) 1)  ==> b
;;  (ref '#(a b c) 1) ==> b
;;  (ref "abc" 1)     ==> #\b
;;
;;@param (seq <sequence>) index :optional fallback 

;;;;;
;;@type Method
;;@name for-each$
;;@description fold、map、for-eachの部分評価版です。
;;
;;@param proc 

;;;;;
;;@type Method
;;@name map$
;;@description fold、map、for-eachの部分評価版です。
;;
;;@param proc 

;;;;;
;;@type Method
;;@name fold$
;;@description fold、map、for-eachの部分評価版です。
;;
;;@param proc 
;;@param knil 

;;;;;
;;@type Method
;;@name fold$
;;@description fold、map、for-eachの部分評価版です。
;;
;;@param proc 

;;;;;
;;@type Function
;;@name unwrap-syntax
;;@description formの内部的な構文情報を取り除きます。
;;健全なマクロの実装のために、マクロ拡張ルーチンはマクロ内のシンボルを
;;識別子(identifier)に置き換えます。識別子はそれが現れる構文的環境を
;;捕捉します。それはコンパイラに取っては必要な情報ですが、
;;エラーメッセージに現れるとユーザーを混乱させるもとにもなります。
;;そこで、この手続きではform中の識別子をもとのシンボルに
;;置換しなおします。
;;
;;@param form 

;;;;;
;;@type Macro
;;@name syntax-errorf
;;@description これらはerrorとerrorf (Signalling exceptions参照) と
;;ほぼ同じですが、実行時ではなくマクロ展開時(すなわち、コンパイル時)に
;;エラーを通知するところが異なります。
;;
;;これらの手続きは、マクロの誤った使い方を、
;;マクロ展開ルーチンの出す複雑なエラーではなく、
;;分かりやすい方法でユーザーに通知するのに使えます。
;;そのため、arg ...はまず下に述べるunwrap-syntaxに渡されて
;;内部の構文的束縛情報を取り除いた後でこれらの手続きに渡されます。
;;
;;example:
;;  (define-syntax my-macro
;;    (syntax-rules ()
;;      ((_ a b)   (foo2 a b))
;;      ((_ a b c) (foo3 a b c))
;;      ((_ . ?)
;;       (syntax-error "malformed my-macro" (my-macro . ?)))))
;;  
;;  (my-macro 1 2 3 4)
;;    ==> @r{error: "malformed my-macro: (mymacro 1 2 3 4)"}
;;
;;
;;@param fmt 
;;@param arg 
;;@param ... 

;;;;;
;;@type Macro
;;@name syntax-error
;;@description これらはerrorとerrorf (Signalling exceptions参照) と
;;ほぼ同じですが、実行時ではなくマクロ展開時(すなわち、コンパイル時)に
;;エラーを通知するところが異なります。
;;
;;これらの手続きは、マクロの誤った使い方を、
;;マクロ展開ルーチンの出す複雑なエラーではなく、
;;分かりやすい方法でユーザーに通知するのに使えます。
;;そのため、arg ...はまず下に述べるunwrap-syntaxに渡されて
;;内部の構文的束縛情報を取り除いた後でこれらの手続きに渡されます。
;;
;;example:
;;  (define-syntax my-macro
;;    (syntax-rules ()
;;      ((_ a b)   (foo2 a b))
;;      ((_ a b c) (foo3 a b c))
;;      ((_ . ?)
;;       (syntax-error "malformed my-macro" (my-macro . ?)))))
;;  
;;  (my-macro 1 2 3 4)
;;    ==> @r{error: "malformed my-macro: (mymacro 1 2 3 4)"}
;;
;;
;;@param msg 
;;@param arg 
;;@param ... 

;;;;;
;;@type Function
;;@name macroexpand-1
;;@description form がリストで、その最初の要素が大域的にマクロに束縛された
;;変数であるならば、macroexpand-1はそのマクロ変換子を実行し、
;;展開されたフォームを返します。そうでなければ、form をそのまま
;;返します。
;;
;;macroexpand は、form が展開できなくなるまで
;;macroexpand-1 を繰り返します。
;;
;;これらの手続きは、大域的に定義されたマクロを展開するために使うことが
;;できます。
;;
;;@param form 

;;;;;
;;@type Function
;;@name macroexpand
;;@description form がリストで、その最初の要素が大域的にマクロに束縛された
;;変数であるならば、macroexpand-1はそのマクロ変換子を実行し、
;;展開されたフォームを返します。そうでなければ、form をそのまま
;;返します。
;;
;;macroexpand は、form が展開できなくなるまで
;;macroexpand-1 を繰り返します。
;;
;;これらの手続きは、大域的に定義されたマクロを展開するために使うことが
;;できます。
;;
;;@param form 

;;;;;
;;@type Function
;;@name define-macro
;;@description 変換子が procedure である大域マクロ name を定義します。
;;2番目のフォームは、以下のフォームの簡易記法です。
;;example:
;;  (define-macro name (lambda formals body ...))
;;
;;コンパイラが (name arg ...) というフォームを見つけると、
;;arg ... を引数として procedure を呼び出します。
;;procedure が戻ると、コンパイラは元のフォームの場所に返されたフォームを
;;挿入し、再度それをコンパイルします。
;;
;;@param (name . 
;;@param formals) body ... 

;;;;;
;;@type Function
;;@name define-macro
;;@description 変換子が procedure である大域マクロ name を定義します。
;;2番目のフォームは、以下のフォームの簡易記法です。
;;example:
;;  (define-macro name (lambda formals body ...))
;;
;;コンパイラが (name arg ...) というフォームを見つけると、
;;arg ... を引数として procedure を呼び出します。
;;procedure が戻ると、コンパイラは元のフォームの場所に返されたフォームを
;;挿入し、再度それをコンパイルします。
;;
;;@param name 
;;@param procedure 

;;;;;
;;@type Function
;;@name path->module-name
;;@description module-name->pathの逆関数です。
;;
;;@param string 

;;;;;
;;@type Function
;;@name module-name->path
;;@description モジュール名symbolを、パス名の一部(requireやprovideが
;;使うような)へと変換します。
;;
;;@param symbol 

;;;;;
;;@type Function
;;@name global-variable-ref
;;@description モジュールmoduleから可視の、シンボルsymbolのグローバルな
;;束縛値を返します。moduleはモジュールオブジェクトか
;;既存のモジュール名を示すシンボルでなければなりません。
;;symbolに対する可視のグローバル束縛が無い場合は、
;;default引数があたえられていればその値を返し、
;;無ければエラーを通知します。
;;
;;@param module 
;;@param symbol 
;;@param :optional 
;;@param default 

;;;;;
;;@type Function
;;@name global-variable-bound?
;;@description symbolのグローバルなバインディングがmoduleから
;;可視であれば、真を返します。moduleはモジュールオブジェクトか
;;既存のモジュール名を示すシンボルでなければなりません。
;;
;;註: 以前、この手続きの機能はsymbol-bound?という手続きで
;;実現されていました。symbol-bound?は非推奨となり、新しいコードは
;;global-variable-bound?を使わねばなりません。
;;この変更の理由は、symbol-bound?がカレントモジュールをデフォルトと
;;しており、またその名前からも、グローバルな束縛値があたかも
;;(CommonLispのように)シンボルそのものの属性であるかのような誤解を招いて
;;いたからです。そのせいで、特にコンパイル時と実行時でカレントモジュールが
;;異なるような場合に多くの混乱が生じていました。
;;新しい名前とAPIは、グローバルな束縛値についてモジュールに問い合わせている
;;ということを明確にしています。
;;
;;@param module 
;;@param symbol 

;;;;;
;;@type Function
;;@name module-precedence-list
;;@description モジュールの継承に関する情報を返します。
;;module-parentsはmoduleが直接継承しているモジュールのリストを
;;返します。module-precedence-listはmoduleのmodule precedence
;;list (Module inheritance参照) を返します。
;;
;;@param module 

;;;;;
;;@type Function
;;@name module-parents
;;@description モジュールの継承に関する情報を返します。
;;module-parentsはmoduleが直接継承しているモジュールのリストを
;;返します。module-precedence-listはmoduleのmodule precedence
;;list (Module inheritance参照) を返します。
;;
;;@param module 

;;;;;
;;@type Function
;;@name module-table
;;@description モジュールオブジェクトのアクセスメソッドです。
;;moduleの名前(シンボル)、moduleがインポートしているモジュールのリスト、
;;エクスポートしているシンボルのリスト、そして
;;シンボルから束縛へのマップを行うハッシュテーブルを返します。
;;
;;もしmoduleが全てのシンボルをエクスポートしている場合は、module-exports
;;は#tを返します。
;;
;;モジュールオブジェクト以外が渡された場合はエラーになります。
;;
;;@param module 

;;;;;
;;@type Function
;;@name module-exports
;;@description モジュールオブジェクトのアクセスメソッドです。
;;moduleの名前(シンボル)、moduleがインポートしているモジュールのリスト、
;;エクスポートしているシンボルのリスト、そして
;;シンボルから束縛へのマップを行うハッシュテーブルを返します。
;;
;;もしmoduleが全てのシンボルをエクスポートしている場合は、module-exports
;;は#tを返します。
;;
;;モジュールオブジェクト以外が渡された場合はエラーになります。
;;
;;@param module 

;;;;;
;;@type Function
;;@name module-imports
;;@description モジュールオブジェクトのアクセスメソッドです。
;;moduleの名前(シンボル)、moduleがインポートしているモジュールのリスト、
;;エクスポートしているシンボルのリスト、そして
;;シンボルから束縛へのマップを行うハッシュテーブルを返します。
;;
;;もしmoduleが全てのシンボルをエクスポートしている場合は、module-exports
;;は#tを返します。
;;
;;モジュールオブジェクト以外が渡された場合はエラーになります。
;;
;;@param module 

;;;;;
;;@type Function
;;@name module-name
;;@description モジュールオブジェクトのアクセスメソッドです。
;;moduleの名前(シンボル)、moduleがインポートしているモジュールのリスト、
;;エクスポートしているシンボルのリスト、そして
;;シンボルから束縛へのマップを行うハッシュテーブルを返します。
;;
;;もしmoduleが全てのシンボルをエクスポートしている場合は、module-exports
;;は#tを返します。
;;
;;モジュールオブジェクト以外が渡された場合はエラーになります。
;;
;;@param module 

;;;;;
;;@type Function
;;@name all-modules
;;@description 現在存在する全ての名前付きモジュールのリストを返します。
;;無名のモジュールは含まれません。
;;

;;;;;
;;@type Function
;;@name make-module
;;@description シンボルの名前nameを持つモジュールを作成して返します。
;;その名前を持つモジュールが既に存在していた場合、その動作は
;;if-existsキーワード引数で指定されます。
;;if-exists引数が:errorである場合（デフォルト）、
;;エラーが報告されます。それが#fである場合は単に#fが返されます。
;;
;;モジュールを実行時に動的に生成することは、通常のスクリプトでは
;;あまり必要とはされません。既に書かれたプログラムの解釈においては、
;;モジュールは名前で指定されている必要があるからです。
;;構文define-module、import、extend、with-module
;;等はモジュールそのものではなくモジュール名を取ります。
;;これは、モジュールが本質的にコンパイル時の構造であるためです。
;;しかし、動的に作られるモジュールが有用な場合もあります---プログラムそのものが、
;;動的に作られる場合です。evalにモジュールを渡して、
;;そのような動的に作られたプログラムがそのモジュールの中で
;;コンパイルされ評価されるようにできます。
;;
;;また、nameに#fを渡すことで無名のモジュールを作ることもできます。
;;無名のモジュールはfind-moduleで探すことはできませんし、
;;他のモジュールからimportすることもextendされることも
;;できません（importやextendはモジュール名を必要とするからです）。
;;無名のモジュールは、一時的に隔離された名前空間を動的に作りたい時に
;;便利です。例えばネットワークで接続されたプログラムから送られた式を
;;その中で評価して、コネクションが終了したら名前空間ごと捨ててしまうという
;;ような場合です。無名のモジュールはシステムの内部辞書に登録されないので、
;;モジュールへの参照が無くなればガベージコレクトされます。
;;
;;@param name 
;;@param :key 
;;@param if-exists 

;;;;;
;;@type Function
;;@name find-module
;;@description 名前がシンボルnameであるようなモジュールを返します。
;;その名前をもつモジュールが存在しなければ、#fを返します。
;;
;;@param name 

;;;;;
;;@type Function
;;@name module?
;;@description objがモジュールなら真の値を返します。
;;
;;@param obj 

;;;;;
;;@type Class
;;@name <module>
;;@description モジュールクラスです。
;;

;;;;;
;;@type Macro
;;@name extend
;;@description カレントモジュールが、module-name ...に挙げられたモジュールを
;;継承するようにします。それまでの継承の情報は捨てられ、module-name ...
;;から計算される継承情報が有効になります。
;;
;;新たに作られるモジュールはデフォルトでgaucheモジュールを継承しています。
;;例えばそのモジュールに(extend scheme)というフォームを入れた場合、
;;その時点でそのモジュールはschemeモジュール(R5RSで定義された束縛
;;のみを含む)を直接継承するようになります。したがって、そのフォームの後で
;;'import' やその他gauche特有の束縛はそのモジュール内では
;;使えなくなります。
;;
;;module-nameに挙げられたモジュールがまだ存在しなかった場合、
;;extendはuseと同じメカニズムを使ってファイルをロードすることを
;;試みます。
;;
;;モジュールは複数のモジュールを継承することができます。
;;丁度、クラスが複数のクラスを継承できるのと同じようにです。
;;多重継承の場合、次のようにしてモジュール間の優先順位が決められます。
;;
;;各モジュールはmodule precedence listというモジュールのリストを
;;持っています。そこにリストされた順に束縛が探されます。
;;モジュールが複数のモジュールを多重継承した場合、継承される各モジュールの
;;module precedence listを、次に挙げる制約を満たすようにマージ
;;したものが新たなmodule precedence listとなります：
;;(1) あるmodule precedence listでモジュールAがモジュールBより前に現れていたら、
;;結果のmodule precedence listでもAはBより前に現れる：
;;(2) モジュールAがモジュールBよりextendフォームで前に現れていたら、
;;結果のmodule precedence listでもAはBより前に現れる。
;;この条件を満たすようなmodule precedence listが構成できない場合はエラーとなります。
;;
;;@param module-name 
;;@param ... 

;;;;;
;;@type Macro
;;@name use
;;@description モジュールのインポートと必要に応じてファイルのロードを合わせて行う、
;;便利なマクロです。基本的に、(use foo) は以下のふたつのフォームと
;;等価です。
;;example:
;;  (require "foo")
;;  (import foo)
;;すなわち、まず名前``foo''を持つライブラリファイルが(まだロードされて
;;いなければ)ロードされ、その中で定義されているモジュールfooをカレントモジュールに
;;インポートします。
;;
;;キーワード引数only, except, prefixは
;;importにインポートオプションとして渡されます。
;;
;;example:
;;  (use srfi-1 :only (iota) :prefix srfi-1:)
;;  
;;  (srfi-1:iota 3) ==> (0 1 2)
;;
;;
;;ファイルのロードとモジュールとは直交する概念ですが、
;;実用的にはモジュール毎にファイルを分割するのが便利です。
;;必ずしもそうする必要は無く、require と import を別々に
;;使っても構いません。が、Gaucheに附属してくるライブラリはすべて、
;;use マクロで使えるように書かれています。
;;
;;もしモジュールが一つのファイルに収めるには大きすぎる場合、一つのメインファイルと
;;いくつかのサブファイルに分けることも出来ます。メインファイルの中でモジュールを
;;定義し、サブファイルをまとめてロードするか、オートロードを設定します。
;;
;;実際は、与えられたモジュール名からファイルのパス名を得るのに
;;手続きmodule-name->pathが使われます。デフォルトの変換規則は、
;;モジュール名name中のピリオド`.'を`/'に置換
;;するというものです。例えば(use foo.bar.baz)は
;;example:
;;  (require "foo/bar/baz")
;;  (import foo.bar.baz)
;;となります。これはあまりScheme風ではありませんが、便利ではあります。
;;将来、このマッピングルールをカスタマイズする機構が導入されるかもしれません。
;;
;;@param name 
;;@param :key 
;;@param only 
;;@param except 
;;@param rename 
;;@param prefix 

;;;;;
;;@type Function
;;@name import
;;@description import-specで指定されるモジュールがexportしている
;;束縛のすべてもしくはいくつかを、カレントモジュール中で使えるようにします。
;;import-specは以下の形式です。
;;
;;example:
;;  <import-spec> : <module-name>
;;                | (<module-name> <import-option> ...)
;;  
;;  <import-option> : :only (<symbol> ...)
;;                  | :except (<symbol> ...)
;;                  | :rename ((<symbol> <symbol>) ...)
;;                  | :prefix <symbol>
;;  
;;  <module-name> : <symbol>
;;
;;module-nameで指定される名前のモジュールは
;;このフォームがコンパイルされる時点までに存在していなければなりません。
;;
;;モジュールのimportは遷移的ではありません。
;;つまりmodule-nameで指定されたモジュールがその内部でimport
;;しているモジュールは自動的にカレントモジュールにはimportされてません。
;;モジュールの独立性を保つための設計です。この性質により、
;;ライブラリモジュールの作者はいくら他のモジュールを
;;importしようとも利用者の名前空間を不意に汚染してしまう心配はありません。
;;(利用者からはそのモジュールでexportしている名前しか見えないからです。)
;;
;;import-optionは束縛がどのようにインポートされるかを制御します。
;;:onlyがある場合、<symbol> ...に挙げられた名前を
;;持つ束縛のみがインポートされます。:exceptがある場合は逆に、
;;エクスポートされている束縛のうち挙げられた名前を持つもの以外が
;;インポートされます。:renameは各2要素のリストの最初の名前
;;を持つ束縛が2番目の名前へとリネームされます。
;;:prefixがあると、元の名前の前に
;;指定されるシンボルが付加された名前で束縛が見えるようになります。
;;import-optionが指定されなければ、module-nameのすべての
;;エクスポートされた束縛がプレフィクス無しでインポートされます。
;;
;;example:
;;  (define-module M (export x y)
;;    (define x 1)
;;    (define y 2)
;;    (define z 3))
;;  
;;  (import M)
;;  
;;  x ==> 1
;;  z ==> @r{エラー。 zはMからエクスポートされなていない}
;;  
;;  (import (M :only (y)))
;;  
;;  x ==> エラー。xは:onlyリストに含まれない。
;;  
;;  (import (M :except (y)))
;;  
;;  y ==> エラー。yは:exceptにより除外されている。
;;  
;;  (import (M :prefix M:))
;;  
;;  x ==> error
;;  M:x ==> 1
;;  M:y ==> 2
;;
;;一つ以上のインポートオプションが与えられた場合、
;;それは出現順に処理されます。すなわち、:prefixが
;;最初に現れた場合、その後に来る:onlyや:except
;;はプレフィックスつきの名前を使って指定しなければなりません。
;;
;;@param import-spec 
;;@param ... 

;;;;;
;;@type Function
;;@name export-all
;;@description カレントモジュール中の全ての束縛をexportします。
;;

;;;;;
;;@type Function
;;@name export
;;@description カレントモジュールの中で、シンボルsymbolに対応する束縛をexportします。
;;exportされた束縛は、カレントモジュールをimportしたモジュール中で見えるようになります。
;;
;;@param symbol 
;;@param ... 

;;;;;
;;@type Function
;;@name current-module
;;@description コンパイル時点でのカレントモジュールに評価されます。
;;これは手続きではなく特殊形式です。
;;Gaucheではモジュールはコンパイル時に静的に決定されます。
;;
;;example:
;;  (define-module foo
;;    (export get-current-module)
;;    (define (get-current-module) (module-name (current-module))))
;;  
;;  (define-module bar
;;    (import foo)
;;    (get-current-module)) ==> foo @r{; not bar}
;;

;;;;;
;;@type Function
;;@name with-module
;;@description 名前nameを持つモジュールをカレントモジュールとした状態でbody ...
;;を順に評価し、最後の結果を返します。該当するモジュールが存在しなければエラーとなります。
;;
;;@param name 
;;@param body 
;;@param ... 

;;;;;
;;@type Function
;;@name select-module
;;@description 名前nameを持つモジュールをカレントモジュールとします。
;;その名前を持つモジュールが無ければエラーとなります。
;;
;;select-moduleがSchemeファイルの中で用いられた場合、
;;その効果はそのファイルの終了までに限られます。select-moduleを中で呼んでいる
;;ファイルをloadやrequireしても、呼んだ側のカレントモジュールは影響を受けません。
;;
;;@param name 

;;;;;
;;@type Function
;;@name define-module
;;@description nameはシンボルでなければなりません。
;;名前nameを持つモジュールが存在しなければまず作成します。
;;それから、body ... をモジュールname中で評価します。
;;
;;@param name 
;;@param body 
;;@param ... 

;;;;;
;;@type Function
;;@name define-in-module
;;@description この形式はvariableのグローバルな束縛をmodule中に作成します。
;;moduleはモジュール名を表すシンボルか、モジュールオブジェクトで
;;なければなりません。moduleがシンボルの場合、その名前を持つ
;;モジュールが既に存在している必要があります。
;;
;;expressionは現在のモジュール中で評価されます。
;;
;;2番目の形式は次の形式の構文的修飾です。
;;example:
;;  (define-in-module module variable (lambda formals body ...))
;;
;;@param module 
;;@param (variable . 
;;@param formals) body ... 

;;;;;
;;@type Function
;;@name define-in-module
;;@description この形式はvariableのグローバルな束縛をmodule中に作成します。
;;moduleはモジュール名を表すシンボルか、モジュールオブジェクトで
;;なければなりません。moduleがシンボルの場合、その名前を持つ
;;モジュールが既に存在している必要があります。
;;
;;expressionは現在のモジュール中で評価されます。
;;
;;2番目の形式は次の形式の構文的修飾です。
;;example:
;;  (define-in-module module variable (lambda formals body ...))
;;
;;@param module 
;;@param variable 
;;@param expression 

;;;;;
;;@type Function
;;@name define-constant
;;@description defineと同じように動作しますが、
;;コンパイラはvariableの値が今後変更されないものとして
;;最適化されたコードを生成します。
;;
;;variableの値をset!で変更しようとするとエラーとなります。
;;variableを再定義することは許されますが、警告が表示されます。
;;
;;@param (variable . 
;;@param formals) body ... 

;;;;;
;;@type Function
;;@name define-constant
;;@description defineと同じように動作しますが、
;;コンパイラはvariableの値が今後変更されないものとして
;;最適化されたコードを生成します。
;;
;;variableの値をset!で変更しようとするとエラーとなります。
;;variableを再定義することは許されますが、警告が表示されます。
;;
;;@param variable 
;;@param expression 

;;;;;
;;@type Macro
;;@name define-values
;;@description まずexprが評価されます。それは与えられたvarと同数の値を
;;返さなければなりません。続いて各値がvarに順に束縛されます。
;;Let-valuesも参照してください。
;;example:
;;  (define-values (lo hi) (min&max 3 -1 15 2))
;;  
;;  lo ==> -1
;;  hi ==> 15
;;
;;@param (var ...) expr 

;;;;;
;;@type Macro
;;@name until
;;@description while の条件を逆にしたものです。 つまり、
;;最初の形式ではexprが真値を返すまで body ... を
;;繰り返します。2番目の形式ではexprの結果がguard に渡され
;;それが真値を返すまで繰り返します。 Varはexpr返り値に
;;束縛されます。
;;
;;(guard を省いた2番目の形式ではvarは常に#fへ
;;束縛されるため、あまり意味がありません。)
;;
;;until自体の返り値は不定です。
;;
;;example:
;;  (let ((a '(0 1 2 3 4)))
;;    (until (null? a)
;;      (write (pop! a)))) ==> @r{prints "01234"}
;;  
;;  (until (read-char) eof-object? => ch
;;    (write-char ch))
;;   ==> @r{reads from stdin and writes char until EOF is read}
;;
;;@param expr 
;;@param guard 
;;@param => 
;;@param var 
;;@param body 
;;@param ... 

;;;;;
;;@type Macro
;;@name until
;;@description while の条件を逆にしたものです。 つまり、
;;最初の形式ではexprが真値を返すまで body ... を
;;繰り返します。2番目の形式ではexprの結果がguard に渡され
;;それが真値を返すまで繰り返します。 Varはexpr返り値に
;;束縛されます。
;;
;;(guard を省いた2番目の形式ではvarは常に#fへ
;;束縛されるため、あまり意味がありません。)
;;
;;until自体の返り値は不定です。
;;
;;example:
;;  (let ((a '(0 1 2 3 4)))
;;    (until (null? a)
;;      (write (pop! a)))) ==> @r{prints "01234"}
;;  
;;  (until (read-char) eof-object? => ch
;;    (write-char ch))
;;   ==> @r{reads from stdin and writes char until EOF is read}
;;
;;@param expr 
;;@param body 
;;@param ... 

;;;;;
;;@type Macro
;;@name while
;;@description Var は識別子でguardは一つの引数をとる手続きです。
;;
;;最初の形式ではまずexprが評価され、もしそれが真値を返したら
;;body ... が評価されます。そしてexprが真値を返す
;;限り繰り返されます。
;;
;;2番目の形式では、body ... で有効な変数varを
;;作成し、exprの結果に束縛します。
;;
;;最後の形式では、expr の返り値が guard に渡されこの
;;結果が真値である限り body ... が繰り返されます。
;;変数 var は expr の結果に束縛されます。
;;
;;while 自体の返り値は不定です。
;;
;;example:
;;  (let ((a '(0 1 2 3 4)))
;;    (while (pair? a)
;;      (write (pop! a)))) ==> @r{prints "01234"}
;;  
;;  (let ((a '(0 1 2 3 #f 5 6)))
;;    (while (pop! a) integer? => var
;;      (write var))) ==> @r{prints "0123"}
;;
;;@param expr 
;;@param guard 
;;@param => 
;;@param var 
;;@param body 
;;@param ... 

;;;;;
;;@type Macro
;;@name while
;;@description Var は識別子でguardは一つの引数をとる手続きです。
;;
;;最初の形式ではまずexprが評価され、もしそれが真値を返したら
;;body ... が評価されます。そしてexprが真値を返す
;;限り繰り返されます。
;;
;;2番目の形式では、body ... で有効な変数varを
;;作成し、exprの結果に束縛します。
;;
;;最後の形式では、expr の返り値が guard に渡されこの
;;結果が真値である限り body ... が繰り返されます。
;;変数 var は expr の結果に束縛されます。
;;
;;while 自体の返り値は不定です。
;;
;;example:
;;  (let ((a '(0 1 2 3 4)))
;;    (while (pair? a)
;;      (write (pop! a)))) ==> @r{prints "01234"}
;;  
;;  (let ((a '(0 1 2 3 #f 5 6)))
;;    (while (pop! a) integer? => var
;;      (write var))) ==> @r{prints "0123"}
;;
;;@param expr 
;;@param => 
;;@param var 
;;@param body 
;;@param ... 

;;;;;
;;@type Macro
;;@name while
;;@description Var は識別子でguardは一つの引数をとる手続きです。
;;
;;最初の形式ではまずexprが評価され、もしそれが真値を返したら
;;body ... が評価されます。そしてexprが真値を返す
;;限り繰り返されます。
;;
;;2番目の形式では、body ... で有効な変数varを
;;作成し、exprの結果に束縛します。
;;
;;最後の形式では、expr の返り値が guard に渡されこの
;;結果が真値である限り body ... が繰り返されます。
;;変数 var は expr の結果に束縛されます。
;;
;;while 自体の返り値は不定です。
;;
;;example:
;;  (let ((a '(0 1 2 3 4)))
;;    (while (pair? a)
;;      (write (pop! a)))) ==> @r{prints "01234"}
;;  
;;  (let ((a '(0 1 2 3 #f 5 6)))
;;    (while (pop! a) integer? => var
;;      (write var))) ==> @r{prints "0123"}
;;
;;@param expr 
;;@param body 
;;@param ... 

;;;;;
;;@type Macro
;;@name dolist
;;@description Common Lispからの輸入です。それぞれ以下のように展開されます。
;;example:
;;  (dotimes (variable limit result) body ...)
;;  ==>
;;  (do ((tlimit limit)
;;       (variable 0 (+ variable 1)))
;;      ((>= variable tlimit) result)
;;    body ...)
;;  
;;  (dolist (variable lexpr result) body ...)
;;  ==>
;;  (begin
;;    (for-each (lambda (variable) body ...) lexpr)
;;    (let ((variable '())) result))
;;
;;@param (variable lexpr 
;;@param [result]) body ... 

;;;;;
;;@type Macro
;;@name dotimes
;;@description Common Lispからの輸入です。それぞれ以下のように展開されます。
;;example:
;;  (dotimes (variable limit result) body ...)
;;  ==>
;;  (do ((tlimit limit)
;;       (variable 0 (+ variable 1)))
;;      ((>= variable tlimit) result)
;;    body ...)
;;  
;;  (dolist (variable lexpr result) body ...)
;;  ==>
;;  (begin
;;    (for-each (lambda (variable) body ...) lexpr)
;;    (let ((variable '())) result))
;;
;;@param (variable limit 
;;@param [result]) body ... 

;;;;;
;;@type Macro
;;@name begin0
;;@description exp0, exp1, ... を評価し、exp0の結果を返します。
;;この名前はMzSchemeから取られました。これはCommonLispで
;;prog1と呼ばれているものです。
;;
;;beginと違って、これは「ブロック」を構成します。
;;begin0フォームは次のように展開されるからです。
;;
;;example:
;;  (receive tmp exp0
;;    exp1 ...
;;    (apply values tmp))
;;
;;@param exp0 
;;@param exp1 
;;@param ... 

;;;;;
;;@type Macro
;;@name rec
;;@description [SRFI-31]
;;再帰的な参照のある式の評価を行うマクロです。
;;
;;最初の形式は、varがexprの結果に束縛される状態でexprを
;;評価します。
;;2番目の形式は以下の形式と等価です。
;;example:
;;  (rec name (lambda vars expr ...))
;;
;;例：
;;
;;example:
;;  ;; constant infinite stream
;;  (rec s (cons 1 (delay s)))
;;  
;;  ;; factorial function
;;  (rec (f n) 
;;    (if (zero? n)
;;        1 
;;        (* n (f (- n 1)))))
;;
;;@param (name . 
;;@param vars) expr ... 

;;;;;
;;@type Macro
;;@name rec
;;@description [SRFI-31]
;;再帰的な参照のある式の評価を行うマクロです。
;;
;;最初の形式は、varがexprの結果に束縛される状態でexprを
;;評価します。
;;2番目の形式は以下の形式と等価です。
;;example:
;;  (rec name (lambda vars expr ...))
;;
;;例：
;;
;;example:
;;  ;; constant infinite stream
;;  (rec s (cons 1 (delay s)))
;;  
;;  ;; factorial function
;;  (rec (f n) 
;;    (if (zero? n)
;;        1 
;;        (* n (f (- n 1)))))
;;
;;@param var 
;;@param expr 

;;;;;
;;@type Function
;;@name receive
;;@description [SRFI-8]
;;この構文により、多値を受け取ることができます。
;;formalsはシンボルのリストです。不完全なリストであっても構いません。
;;expressionが評価され、返された値がlambda形式の引数の束縛と
;;同じようにしてformals内の変数と束縛され、その環境下でbody ...が
;;評価されます。
;;
;;example:
;;  (define (divrem n m)
;;    (values (quotient n m) (remainder n m)))
;;  
;;  (receive (q r) (divrem 13 4) (list q r))
;;    ==> (3 1)
;;  
;;  (receive all (divrem 13 4) all)
;;    ==> (3 1)
;;  
;;  (receive (q . rest) (divrem 13 4) (list q rest))
;;    ==> (3 (1))
;;
;;なお、Multiple valuesのcall-with-valuesは
;;receiveと等価な手続き的インタフェースです。
;;多値を複数のトップレベル変数に束縛するには、define-values
;;(Definitions参照) が使えます。
;;また、SRFI-11 (Let-values) のlet-valuesと
;;let*-valuesはletのような形式で多値を扱うことができます。
;;
;;@param formals 
;;@param expression 
;;@param body 
;;@param ... 

;;;;;
;;@type Macro
;;@name fluid-let
;;@description 動的スコープの変数をエミュレートするマクロです。
;;varはfluid-letフォームを含むスコープで定義されている
;;変数でなければなりません。valは式です。
;;fluid-letはまずvalを評価し、
;;valをvarに動的スコープで束縛してbody ... を評価します。
;;
;;マルチスレッド環境下では、varの値の変化は全てのスレッドから見えます。
;;このフォームは主として他の処理系のコードを移植する際の利便性のために
;;追加されました。スレッドローカルな動的状態を実現するには、
;;パラメータオブジェクト(Parameters参照)を
;;使って下さい。
;;example:
;;  (define x 0)
;;  
;;  (define (print-x) (print x))
;;  
;;  (fluid-let ((x 1))
;;    (print-x))  ==> ;; prints 1
;;
;;@param ((var val) 
;;@param ...) body ... 

;;;;;
;;@type Macro
;;@name and-let*
;;@description [SRFI-2]
;;簡単に言うと、このフォームはlet*のように動作しますが、
;;bindings中の式が#fに評価されたらそこで評価を打ち切り
;;#fを返します。
;;
;;各bindingは以下のいずれかの形式でなければなりません。
;;(variable expression) ------
;;  expressionが評価されます。それが真の値を返したら、その値がvariable
;;  に束縛され、次のbindingへと進みます。もうbindingが無ければ
;;  body ...が評価されます。もしexpressionが#fを返したら、
;;  評価を打ち切り、and-let*から#fを返します。
;;(expression) ------
;;  この形式ではvariableが省略されています。Expressionが評価され、
;;  その結果は評価を続行するか打ち切るかを判断するためにのみ使われます。
;;bound-variable ------
;;  この形式ではbound-variableは束縛変数を示す識別子でなければなりません。
;;  その変数の値が偽でなければ評価を続行します。
;;
;;いくつか例を挙げます。次のコードは連想リストalistからkeyを
;;探し、見つかったらその値を返します。
;;example:
;;  (and-let* ((entry (assoc key alist))) (cdr entry))
;;
;;もしargが正確な整数の文字列表現だった場合はnumを返し、そうでなければ
;;0を返します：
;;example:
;;  (or (and-let* ((num (string->number arg))
;;                 ( (exact? num) )
;;                 ( (integer? num) ))
;;        num)
;;      0)
;;
;;以下のコードはとあるサーバーのポート番号をいくつかの可能性
;;(環境変数、設定ファイル…)の中から探す仮想的なコードです。
;;example:
;;  (or (and-let* ((val (sys-getenv "SERVER_PORT")))
;;        (string->number val))
;;      (and-let* ((portfile (expand-path "~/.server_port"))
;;                 ( (file-exists? portfile) )
;;                 (val (call-with-input-string portfile port->string)))
;;        (string->number val))
;;      8080) ; default
;;
;;
;;@param (binding ...) body ... 

;;;;;
;;@type Macro
;;@name rlet1
;;@description このマクロは次のようなイディオムを簡素化します。
;;example:
;;  (let1 var expr
;;    body ...
;;    var)
;;
;;@param var 
;;@param expr 
;;@param body 
;;@param ... 

;;;;;
;;@type Macro
;;@name if-let1
;;@description このマクロは次のようなイディオムを簡素化します。
;;example:
;;  (let1 var expr
;;    (if var then else))
;;
;;@param var 
;;@param expr 
;;@param then 
;;@param else 

;;;;;
;;@type Macro
;;@name if-let1
;;@description このマクロは次のようなイディオムを簡素化します。
;;example:
;;  (let1 var expr
;;    (if var then else))
;;
;;@param var 
;;@param expr 
;;@param then 

;;;;;
;;@type Macro
;;@name let1
;;@description 変数が一つしか無い場合の便利なマクロです。次のように展開されます。
;;
;;example:
;;  (let ((var expr)) body ...)
;;
;;@param var 
;;@param expr 
;;@param body 
;;@param ... 

;;;;;
;;@type Function
;;@name unless
;;@description まずtestが評価されます。それが真の値(unlessの場合は偽の値)を返した場合、
;;引続きbodyが順に評価され、最後のbodyの評価値が返されます。
;;そうでなければ、未定義の値が返されます。
;;
;;@param test 
;;@param body 
;;@param ... 

;;;;;
;;@type Function
;;@name when
;;@description まずtestが評価されます。それが真の値(unlessの場合は偽の値)を返した場合、
;;引続きbodyが順に評価され、最後のbodyの評価値が返されます。
;;そうでなければ、未定義の値が返されます。
;;
;;@param test 
;;@param body 
;;@param ... 

;;;;;
;;@type Macro
;;@name ecase
;;@description このフォームはほぼcaseと同等ですが、else節が与えられず、
;;keyの値がclause中のどのdatumとも一致しなかった場合の
;;動作だけが異なります。caseではそのような場合は未定義値が返されますが、
;;ecaseはエラーを報告します。
;;
;;このマクロはCommon Lispから採られました。想定外の値が渡されることを
;;念のために検出したい、という場合に便利です。
;;
;;example:
;;  (ecase 5 ((1) 'a) ((2 3) 'b) ((4) 'c))
;;   ==> ERROR: ecase test fell through: got 5, expecting one of (1 2 3 4)
;;
;;@param key 
;;@param clause1 
;;@param clause2 
;;@param ... 

;;;;;
;;@type Macro
;;@name update!
;;@description push!等のマクロの一般化された形式です。
;;procは一つの引数を取り、一つの値を返す手続きでなければなりません。
;;placeの値がprocに渡され、procの結果がplaceに格納されます。
;;example:
;;  (define a (cons 2 3))
;;  (update! (car a) (lambda (v) (* v 3))) ==> undefined
;;  a ==> (6 . 3)
;;  
;;  (update! (cdr a) (cut - <> 3))
;;  a ==> (6 . 0)
;;
;;@param place 
;;@param proc 

;;;;;
;;@type Macro
;;@name dec!
;;@description placeの値を評価します。それは数値にならなければなりません。
;;その値にdeltaが加算(inc!)もしくは減算(dec!)され、
;;結果がplaceに格納されます。deltaの既定値は1です。
;;
;;Common Lispのincfとdecfに似ていますが、
;;戻り値を使うことは出来ません。
;;
;;@param place 
;;@param :optional 
;;@param delta 

;;;;;
;;@type Macro
;;@name inc!
;;@description placeの値を評価します。それは数値にならなければなりません。
;;その値にdeltaが加算(inc!)もしくは減算(dec!)され、
;;結果がplaceに格納されます。deltaの既定値は1です。
;;
;;Common Lispのincfとdecfに似ていますが、
;;戻り値を使うことは出来ません。
;;
;;@param place 
;;@param :optional 
;;@param delta 

;;;;;
;;@type Macro
;;@name pop!
;;@description placeの値を取り出し、そのcdrをplaceにセットします。
;;元の値のcarを返します。
;;
;;example:
;;  (define x (list 1 2 3))
;;  (pop! x) ==> 1
;;  x ==> (2 3)
;;  
;;  (define x (vector (list 1 2 3)))
;;  x ==> #((1 2 3))
;;  (pop! (vector-ref x 0)) ==> 1
;;  x ==> #((2 3))
;;
;;註：この動作はCommon Lispのpopと同じです。
;;Perlのpopはシーケンスの末尾から値を取ります。
;;Perlならshiftがpop!の動作に近いです。
;;
;;@param place 

;;;;;
;;@type Macro
;;@name push!
;;@description itemとplaceの値をコンスし、その結果を再びplaceにセットします。
;;placeはset!と同様に、
;;変数か@var{(proc arg ...)}という形式でなければなりません。このマクロの戻り値は
;;未定義です。
;;
;;example:
;;  (define x (list 2))
;;  (push! x 3) ==> undefined
;;  x ==> (3 2)
;;  
;;  (push! (cdr x) 4) ==> undefined
;;  x ==> (3 4 2)
;;
;;placeがリストの場合、だいたいこんなふうに展開されます。
;;
;;example:
;;  (push! (foo x y) item)
;;   ≡ 
;;   (let ((tfoo foo)
;;         (tx x)
;;         (ty y))
;;     ((setter tfoo) tx ty (cons item (tfoo tx ty))))
;;
;;註：Common Lispのpushマクロは引数を逆の順番で取ります。
;;push!は他の副作用を持つ形式との互換性を考えてこの順番としました。
;;Perlのpush関数はpush!マクロと同じ引数順ですが、
;;itemはシーケンスの末尾に追加されます (Perlのunshiftの方が
;;push!の動作に近いです)。
;;Perlのpushオペレータの動作が必要ならQueueが使えます (Queue参照)。
;;
;;@param place 
;;@param item 

;;;;;
;;@type Function
;;@name getter-with-setter
;;@description [SRFI-17]
;;2つの手続き、getとsetを取り、新しい手続きを返します。
;;新しい手続きはgetと同じ動作をし、そのsetter手続きはsetにロックされて
;;います。
;;
;;この手続きは、SRFI-17によれば、setter手続きのインライン展開を可能にするための
;;ものですが、Gaucheではまだそのような最適化は実装されていません。
;;
;;@param get 
;;@param set 

;;;;;
;;@type Function
;;@name has-setter?
;;@description procがsetter手続きを持っている場合は#tを返します。
;;
;;@param proc 

;;;;;
;;@type Function
;;@name setter
;;@description [SRFI-17]
;;手続きprocのsetter手続きを返します。
;;procがsetter手続きを持たない場合の動作は未定義です。
;;
;;ある関数fのsetter手続きgとは、もし(g a b ... v)のように
;;呼ばれた場合、次の(f a b ...)がvを返すようになる手続きのことです。
;;
;;ある手続きにsetter手続きを関連付けるには、setter自身のsetter手続きを使うことが
;;できます。
;;example:
;;  (set! (setter f) g)
;;
;;特定の手続きにsetter手続きを「ロック」することができます。システム既定のsetter手続き、
;;例えばcarに対するset-car!等はロックされていて、上記のような方法で
;;変更することは出来ません。ユーザ定義手続きにsetter手続きをロックするには下記の
;;getter-with-setterを使います。
;;
;;procが手続きでない場合は、object-applyジェネリックファンクションの
;;setterが返されます。これにより、適用可能オブジェクトが一般化されたset!
;;でもうまく動作します。詳しくはApplicable objectsを参照して下さい。
;;
;;@param proc 

;;;;;
;;@type Macro
;;@name set!-values
;;@description 複数の変数を同時に更新します。Exprは与えられた変数と同じ
;;数だけの値を生成しなけばなりません。各値が対応するvarに
;;セットされます。
;;example:
;;  (define a 0)
;;  (define b 1)
;;  (set!-values (a b) (values 3 4)) ==> undefined
;;  a ==> 3
;;  b ==> 4
;;  (set!-values (a b) (values b a)) ==> undefined
;;  a ==> 4
;;  b ==> 3
;;
;;@param (var ...) expr 

;;;;;
;;@type Macro
;;@name case-lambda
;;@description [SRFI-16]
;;それぞれの clause は (formals expr ...) という形式
;;でなければなりません。ここで、formals は lambda の仮引数
;;リストです。
;;
;;この式は、評価されると可変数の引数をとり、lambda 式から結果として
;;できる手続き同じレキシカルスコープをもつ手続きになります。この手続きが
;;いくつかの引数とともに呼ばれると、formals と一致する引数に対応する
;;最初の clause が選択されます。この引数の一致というのは、
;;lambda 式の formals に対応するものとして指定されるものです。
;;formals の変数は実引数に束縛され、 expr ... がその
;;環境内で評価されます。
;;
;;実際の引数がどの clause の formals にも一致しなければエラーです。
;;
;;@param clause 
;;@param ... 

;;;;;
;;@type Macro
;;@name cute
;;@description [SRFI-26]
;;手続きを簡潔に書ける便利なマクロです。
;;いわゆる部分適用を実現するために使えます。
;;
;;各expr-or-slotは式またはシンボル<>でなければなりません。
;;最後のexpr-or-slotはシンボル<...>であっても構いません。
;;cutは、そのフォーム中にある<>と同じ数の引数を取る
;;lambdaフォームに展開されます。そのフォームのボディには次の式が置かれます。
;;example:
;;    (expr-or-slot expr-or-slot2 ...)
;;但し、各<>は対応する仮引数に置き換えられます。
;;もしシンボル<...>が与えられていた場合、展開されたlambdaフォームは
;;可変長引数を取る手続きとなり、作成される手続きに与えられたすべての引数が
;;expr-or-slotを呼び出すのに使われます(下の4番目の例を参照のこと)。
;;
;;example:
;;  (cut cons (+ a 1) <>)  ≡  (lambda (x2) (cons (+ a 1) x2))
;;  (cut list 1 <> 3 <> 5) ≡  (lambda (x2 x4) (list 1 x2 3 x4 5))
;;  (cut list)             ≡  (lambda () (list))
;;  (cut list 1 <> 3 <...>)
;;     ≡  (lambda (x2 . xs) (apply list 1 x2 3 xs))
;;  (cut <> a b)           ≡  (lambda (f) (f a b))
;;  
;;  ;; Usage
;;  (map (cut * 2 <>) '(1 2 3 4))
;;  (for-each (cut write <> port) exprs)
;;
;;cuteはcutとほぼ同じですが、expr-or-slotに与えられた
;;フォームが手続きを作る前に評価される点が異なります。
;;
;;example:
;;  (cute cons (+ a 1) <>)
;;     ≡  (let ((xa (+ a 1))) (lambda (x2) (cons xa x2)))
;;
;;Gaucheはまた、部分適用を行うpa$という組み込み手続きを持っています
;;(@xref{Combinators}参照)。
;;
;;@param expr-or-slot 
;;@param expr-or-slot2 
;;@param ... 

;;;;;
;;@type Macro
;;@name cut
;;@description [SRFI-26]
;;手続きを簡潔に書ける便利なマクロです。
;;いわゆる部分適用を実現するために使えます。
;;
;;各expr-or-slotは式またはシンボル<>でなければなりません。
;;最後のexpr-or-slotはシンボル<...>であっても構いません。
;;cutは、そのフォーム中にある<>と同じ数の引数を取る
;;lambdaフォームに展開されます。そのフォームのボディには次の式が置かれます。
;;example:
;;    (expr-or-slot expr-or-slot2 ...)
;;但し、各<>は対応する仮引数に置き換えられます。
;;もしシンボル<...>が与えられていた場合、展開されたlambdaフォームは
;;可変長引数を取る手続きとなり、作成される手続きに与えられたすべての引数が
;;expr-or-slotを呼び出すのに使われます(下の4番目の例を参照のこと)。
;;
;;example:
;;  (cut cons (+ a 1) <>)  ≡  (lambda (x2) (cons (+ a 1) x2))
;;  (cut list 1 <> 3 <> 5) ≡  (lambda (x2 x4) (list 1 x2 3 x4 5))
;;  (cut list)             ≡  (lambda () (list))
;;  (cut list 1 <> 3 <...>)
;;     ≡  (lambda (x2 . xs) (apply list 1 x2 3 xs))
;;  (cut <> a b)           ≡  (lambda (f) (f a b))
;;  
;;  ;; Usage
;;  (map (cut * 2 <>) '(1 2 3 4))
;;  (for-each (cut write <> port) exprs)
;;
;;cuteはcutとほぼ同じですが、expr-or-slotに与えられた
;;フォームが手続きを作る前に評価される点が異なります。
;;
;;example:
;;  (cute cons (+ a 1) <>)
;;     ≡  (let ((xa (+ a 1))) (lambda (x2) (cons xa x2)))
;;
;;Gaucheはまた、部分適用を行うpa$という組み込み手続きを持っています
;;(@xref{Combinators}参照)。
;;
;;@param expr-or-slot 
;;@param expr-or-slot2 
;;@param ... 

;;;;;
;;@type Macro
;;@name ^c
;;@description (lambda (c) body ...)の短縮表記です。
;;cには#[_a-z]に含まれる任意の一文字が使えます。
;;
;;example:
;;  (map (^x (* x x)) '(1 2 3 4 5)) ==> (1 4 9 16 25)
;;
;;@param body 
;;@param ... 

;;;;;
;;@type Function
;;@name ^
;;@description [R5RS+]
;;この式は評価されると手続きを生成します。この式が評価された時点の環境が手続き中に保持されます。
;;手続きが呼ばれると、記憶された環境に引数の束縛を追加した環境中でbody が順に評価され、
;;最後の式の値が返されます。
;;
;;^はlambdaの短い別名です。これはGauche独自の拡張です。
;;
;;example:
;;  (lambda (a b) (+ a b))
;;    ==> 二つの引数を加算する手続き
;;  
;;  ((lambda (a b) (+ a b)) 1 2) ==> 3
;;  
;;  ((^(a b) (+ a b)) 1 2)       ==> 3
;;
;;Gaucheはまた、lambdaが取るformalsの構文を拡張し、
;;省略可能引数やキーワード引数を簡単に指定できるようにしています。
;;同じ機能は純粋なR5RSでも、可変長引数を自力で解析することで実現可能ですが、
;;コードはより長く冗長になってしまいます。ポータブルなコードを書いているのでなければ
;;拡張構文を使った方が良いでしょう。
;;
;;Formals は以下のいずれかの形でなければなりません。
;;  (variable ...) :
;;  手続きは決まった数の引数を取ります。
;;  実引数がそれぞれ対応するvariableに束縛されます。
;;  
;;  example:
;;    ((lambda (a) a) 1)    ==> 1
;;    
;;    ((lambda (a) a) 1 2)  ==> @i{error - wrong number of arguments}
;;  
;;  variable :
;;  手続きは不定個の引数を取ります。
;;  実引数は新しいリストに集められて、そのリストがvaribleに束縛されます。
;;  
;;  example:
;;    ((lambda a a) 1 2 3)  ==> (1 2 3)
;;  
;;  (variable_0 ... variable_N-1 . variable_N) : 
;;  手続きは少なくともN個の引数を取ります。N個までの実引数は対応するvariable
;;  に束縛されます。N個を越えた実引数は新しいリストに集められて
;;  variable_Nに束縛されます。
;;  
;;  example:
;;    ((lambda (a b . c) (print "a="a" b="b" c="c)) 1 2 3 4 5)
;;     ==> prints a=1 b=2 c=(3 4 5)
;;  
;;  (variable ... extended-spec ...) :
;;  拡張引数指定です。ゼロ個以上の必須引数を示す変数のリストの後に、
;;  キーワード:optional、:keyあるいは:restで
;;  始まるextended-specが続きます。
;;  
;;  extended-specは省略可能引数指定、キーワード引数指定、残余引数指定の
;;  任意の組み合わせにより構成されます。
;;  
;;  :optional optspec ... ------
;;    省略可能引数を指定します。各optspecは以下のいずれかの形式です。
;;    
;;    example:
;;      variable
;;      (variable init-expr)
;;    
;;    仮引数variableは、対応する実引数が与えられればその値に、
;;    与えられなければinit-exprを評価した値に束縛されます。
;;    optspecがvariableだけである場合は、
;;    実引数が省略された時の仮引数の値は#<undef>になります
;;    (Undefined values参照)。
;;    
;;    init-exprは対応する実引数が与えられなかった場合にのみ評価されます。
;;    init-exprの評価環境にはこのoptspecに先立つ仮引数が含まれます。
;;    
;;    example:
;;      ((lambda (a b :optional (c (+ a b))) (list a b c))
;;       1 2)    ==> (1 2 3)
;;      
;;      ((lambda (a b :optional (c (+ a b))) (list a b c))
;;       1 2 -1) ==> (1 2 -1)
;;      
;;      ((lambda (a b :optional c) (list a b c))
;;       1 2)    ==> (1 2 #<undef>)
;;      
;;      ((lambda (:optional (a 0) (b (+ a 1))) (list a b))
;;       )       ==> (0 1)
;;    
;;    必須引数と省略可能引数の総数よりも多い実引数が渡された場合、
;;    その手続きが:keyや:rest引数指定を持っていない限りは
;;    エラーが通知されます。
;;    
;;    example:
;;      ((lambda (:optional a b) (list a b)) 1 2 3)
;;       ==> @i{error - too many arguments}
;;      
;;      ((lambda (:optional a b :rest r) (list a b r)) 1 2 3)
;;       ==> (1 2 (3))
;;    
;;  :key keyspec ... [:allow-other-keys [variable]] ------
;;    キーワード引数を指定します。各keyspecは以下の形式のいずれかです。
;;    
;;    example:
;;      variable
;;      (variable init-expr)
;;      ((keyword variable) init-expr)
;;    
;;    仮引数variableは、実引数にvariableと同名のキーワードによる
;;    キーワード引数が与えられればその値に、そうでなければinit-exprを評価
;;    した値に束縛されます。init-exprの無い最初の形式では、実引数が
;;    与えられなければvariableは#<undef>に束縛されます。
;;    
;;    example:
;;      (define f (lambda (a :key (b (+ a 1)) (c (+ b 1)))
;;                  (list a b c)))
;;      
;;      (f 10)            ==> (10 11 12)
;;      (f 10 :b 4)       ==> (10 4 5)
;;      (f 10 :c 8)       ==> (10 11 8)
;;      (f 10 :c 1 :b 3)  ==> (10 3 1)
;;    
;;    三番目の形式では、仮引数の名前とは別に引数を与えるキーワードを指定できます。
;;    
;;    example:
;;      ((lambda (:key ((:aa a) -1)) a) :aa 2)
;;        ==> 2
;;    
;;    デフォルトでは、キーワード引数指定をもつ手続きは、認識できないキーワード引数が
;;    与えられた場合にエラーを通知します。仮引数リストに:allow-other-keysを指定することで、
;;    この動作を抑制することができます。
;;    :allow-other-keysに続いてvariableを与えれば、
;;    認識できなかったキーワード引数のリストがvariableに束縛されます。
;;    
;;    example:
;;      ((lambda (:key a) a)
;;       :a 1 :b 2)  ==> @i{error - unknown keyword :b}
;;      
;;      ((lambda (:key a :allow-other-keys) a)
;;       :a 1 :b 2)  ==> 1
;;      
;;      ((lambda (:key a :allow-other-keys z) (list a z))
;;       :a 1 :b 2)  ==> (1 (:b 2))
;;    
;;    :optional引数指定と同時に使われた場合、キーワード引数はすべての
;;    省略可能引数が束縛された後の実引数リストから探されます。
;;    
;;    example:
;;      ((lambda (:optional a b :key c) (list a b c))
;;       1 2 :c 3)  ==> (1 2 3)
;;      
;;      ((lambda (:optional a b :key c) (list a b c))
;;       :c 3)      ==> (:c 3 #<undef>)
;;      
;;      ((lambda (:optional a b :key c) (list a b c))
;;       1 :c 3)     ==> @i{error - keyword list not even}
;;    
;;    
;;  :rest variable ------
;;    
;;    残余引数を指定します。:optional引数指定が無い場合は、
;;    必須引数の束縛が済んだ後で残っている実引数のリストがvariableに
;;    束縛されます。:optional引数指定がある場合は、
;;    必須引数とすべての省略可能引数の束縛が済んだ後で残っている実引数の
;;    リストがvariableに束縛されます。
;;    
;;    example:
;;      ((lambda (a b :rest z) (list a b z))
;;       1 2 3 4 5)  ==> (1 2 (3 4 5))
;;      
;;      ((lambda (a b :optional c d :rest z) (list a b c d z))
;;       1 2 3 4 5)  ==> (1 2 3 4 (5))
;;      
;;      ((lambda (a b :optional c d :rest z) (list a b c d z))
;;       1 2 3)      ==> (1 2 3 #<undef> ())
;;    
;;    残余引数指定とキーワード引数指定の両方が与えられた場合、
;;    両者はともに、必須引数と省略可能引数が処理された後の実引数リストを処理の対象とします。
;;    
;;    example:
;;      ((lambda (:optional a :rest r :key k) (list a r k))
;;       1 :k 3)  ==> (1 (:k 3) 3)
;;    
;;  
;;  R5RSの仕様範囲内で省略可能引数、キーワード引数を受け取るように
;;  書くこともできます。Optional argument parsingの
;;  let-optionals*、let-keywords、
;;  let-keywords*を参照してください。
;;  
;;
;;
;;@param formals 
;;@param body 
;;@param ... 

;;;;;
;;@type Function
;;@name profiler-show
;;@description 格納されている標本データを表示します。
;;
;;キーワード引数 sort-by は指定する場合は、time、
;;count または time-per-call のどれかひとつです。
;;これで結果の整列順を指定します。デフォルトでは timeです。
;;
;;キーワード引数 max-rows では結果を表示する最大行数を指定します。
;;この値が #f であればすべてのデータが表示されます。
;;
;;@param :key 
;;@param sort-by 
;;@param max-rows 

;;;;;
;;@type Function
;;@name profiler-reset
;;@description もしプロファイラが動いていればそれを停止し、保存されていた標本データ
;;を破棄します。
;;
;;

;;;;;
;;@type Function
;;@name profiler-stop
;;@description 標本化プロファイラを停止し、標本データを内部データ構
;;造に保存します。既に標本データが保存されていた場合には、新
;;しく収集された標本データがその後に追加されます。もしプロファイラが動いてい
;;なかった場合には何もしません。
;;

;;;;;
;;@type Function
;;@name profiler-start
;;@description 標本化プロファイラを始動します。プロファイラが既に始動しいる場合
;;には何もしません。
;;

;;;;;
;;@type Function
;;@name disasm
;;@description コンパイル済のclosureの本体部分をディスアセンブルして印字します。
;;これはコンパイラのバグをなんとかしようという場合か、限界まで
;;チューンしようとしないかぎりは役には立たないでしょう。
;;
;;このディスアセンブラの出力結果を読む場合には、コンパイルされたコードに
;;はデッドコードが含まれている可能性があることを心してください。デッドコー
;;ドはジャンプ最適化によって生成されるのですが、コンパイラはこれをわざわ
;;ざ除去することはしていません。
;;
;;@param closure 

;;;;;
;;@type Function
;;@name debug-source-info
;;@description objに付加されているソースコード情報を検索します。ソースコード情
;;報とはソースコードファイル名と行番号のリストです。objにソースコー
;;ド情報が付加されていなければ、#fが返されます。
;;
;;@param obj 

;;;;;
;;@type Parameter
;;@name debug-print-width
;;@description このパラメータはdebug-printが印字する情報の最大幅を指定するもの
;;です。このパラメータが保持する値よりも大きいカラム数の情報は丸められま
;;す。
;;
;;すべての情報を表示したければ、このパラメータに#fを設定してくだ
;;さい。
;;

;;;;;
;;@type Macro
;;@name debug-print
;;@description このマクロはexprをそのフォームのまま印字してから、その式を評価し、
;;評価の結果を印字し、その値を返します。
;;
;;特殊リーダー構文 #?=expr は
;;(debug-print expr) に展開されます。
;;詳細については Debugging を参照してください。
;;
;;@param expr 

;;;;;
;;@type Function
;;@name sys-srandom
;;@description 擬似的な乱数ジェネレータです。
;;sys-randomは0からrand_max(それ自体を含む)までの間で乱数を
;;返します。これはrandom(3)への直接的なインターフェースです。
;;システムにrandom(3)がない場合、lrand48(3)が使われます。
;;
;;sys-srandomは乱数ジェネレータの種をセットします。
;;システムによって、srandom(3)かsrand48(3)を使います。
;;
;;これらの関数の意図は、乱数ジェネレータ(RNG; random number generator)の
;;品質や速度を気にしないアプリケーションに、簡便なRNGを提供することです。
;;本格的な統計分析には、math.mt-randomモジュールのMersenne Twister RNGを
;;使って下さい(Mersenne-Twister random number generator参照)。
;;
;;@param seed 

;;;;;
;;@type Function
;;@name sys-random
;;@description 擬似的な乱数ジェネレータです。
;;sys-randomは0からrand_max(それ自体を含む)までの間で乱数を
;;返します。これはrandom(3)への直接的なインターフェースです。
;;システムにrandom(3)がない場合、lrand48(3)が使われます。
;;
;;sys-srandomは乱数ジェネレータの種をセットします。
;;システムによって、srandom(3)かsrand48(3)を使います。
;;
;;これらの関数の意図は、乱数ジェネレータ(RNG; random number generator)の
;;品質や速度を気にしないアプリケーションに、簡便なRNGを提供することです。
;;本格的な統計分析には、math.mt-randomモジュールのMersenne Twister RNGを
;;使って下さい(Mersenne-Twister random number generator参照)。
;;

;;;;;
;;@type Function
;;@name sys-nanosleep
;;@description [POSIX]
;;指定されたナノ秒が経過するか、シグナルを受け取るまでプロセスを一時停止します。
;;引数nanosecondsは<time>オブジェクト(Time参照)か
;;実数です。nanosecondsが経過したら#fを返し、
;;sys-nanosleepがシグナルによって割り込まれると残りの時間を表す
;;<time>オブジェクトを返します。
;;
;;example:
;;  ;@r{wait for 0.5 sec}
;;  (sys-nanosleep 500000000)
;;  
;;  ;@r{wait for 1.3 sec}
;;  (sys-nanosleep (make <time> :second 1 :nanosecond 300000000))
;;
;;Windowsネイティブ環境では、この関数はSleepによってエミュレートされます。
;;引数はミリ秒の単位に切り上げられます。またシグナルによって中断されることはありません。
;;
;;@param nanoseconds 

;;;;;
;;@type Function
;;@name sys-sleep
;;@description [POSIX] 指定された秒数が経過するまで、あるいはプロセスがシグナルを受け取るまで
;;スレッドを一時停止します。指定時間が満了した場合は0を返し、
;;シグナルによって一時停止が解除された場合は、満了までの秒数を返します。
;;
;;POSIX実装間でポータブルにするためには、secondsを65536より小さく保って
;;下さい。
;;
;;@param seconds 

;;;;;
;;@type Function
;;@name sys-alarm
;;@description [POSIX] SIGALRMシグナルがseconds秒後に送出されるように準備します。
;;以前のアラームクロックのセッティングはキャンセルされます。
;;secondsに0を渡すと、新しいアラームをスケジューリングしません。
;;以前にスケジューリングされていたアラームが送出されるまでの残り時間を
;;秒数で返します(アラームがアクティブでない場合は0を返します)。
;;
;;@param seconds 

;;;;;
;;@type Function
;;@name sys-pause
;;@description [POSIX]
;;シグナルキャッチ関数の実行かプロセスの終了を指示するシグナルを
;;受け取るまでプロセスを一時停止します。この関数は、シグナルキャッチ関数が
;;戻ったときにのみ戻ります。戻り値は未定義です。
;;
;;Schemeレベルでは、pause()を呼ぶだけでは上記のセマンティクスを
;;満足しません。内部的にこの手続きは現在のシグナルマスクを伴って、
;;sigsuspend()を呼びます。
;;

;;;;;
;;@type Function
;;@name sys-select!
;;@description ステータスを変更するためにファイルディスクリプタの集合を待ちます。
;;readfds、writefds、exceptfdsは、注目するファイル
;;ディスクリプタの集合を表す<fdset>オブジェクトです。
;;readfdsにあるファイルディスクリプタは、文字を読み込む準備が
;;出来たかどうかを検査するために監視されています。
;;writefdsにあるファイルディスクリプタはそこへ書き込むことができる
;;ようになったか監視されています。exceptfdsにあるファイルディスクリプタは
;;例外のために監視されています。条件を監視する必要がない場合は、これらの引数の
;;1つ以上に#fを渡すことができます。
;;
;;timeoutはsys-selectが条件の変更を待つ最大の時間を指定します。
;;それは、マイクロ秒を表す実数か、1つ目が秒数で2つ目がマイクロ秒である
;;2つの整数からなるリストです。#fを渡すと、sys-selectは
;;永久に待ちます。
;;
;;sys-selectは4つの値を返します。1つ目の値は、ステータスの変更を
;;検知したディスクリプタの数です。timeoutが経過したら0になるでしょう。
;;2、3、4番目の値は、それぞれ読み込み、書き出し、例外のステータスを変更
;;するディスクリプタの集合を含む<fdset>オブジェクトです。
;;readfds、writefds、exceptfdsのうちの1つ以上に#fを
;;渡すと、対応する戻り値は#fになります。
;;
;;sys-select!の仲間は、それが渡された引数<fdset>を変更することを
;;除けば、sys-selectと同じように動作します。
;;sys-selectは、新しい<fdset>オブジェクトを作り、その
;;引数を変更しません。
;;
;;@param readfds 
;;@param writefds 
;;@param exceptfds 
;;@param :optional 
;;@param timeout 

;;;;;
;;@type Function
;;@name sys-select
;;@description ステータスを変更するためにファイルディスクリプタの集合を待ちます。
;;readfds、writefds、exceptfdsは、注目するファイル
;;ディスクリプタの集合を表す<fdset>オブジェクトです。
;;readfdsにあるファイルディスクリプタは、文字を読み込む準備が
;;出来たかどうかを検査するために監視されています。
;;writefdsにあるファイルディスクリプタはそこへ書き込むことができる
;;ようになったか監視されています。exceptfdsにあるファイルディスクリプタは
;;例外のために監視されています。条件を監視する必要がない場合は、これらの引数の
;;1つ以上に#fを渡すことができます。
;;
;;timeoutはsys-selectが条件の変更を待つ最大の時間を指定します。
;;それは、マイクロ秒を表す実数か、1つ目が秒数で2つ目がマイクロ秒である
;;2つの整数からなるリストです。#fを渡すと、sys-selectは
;;永久に待ちます。
;;
;;sys-selectは4つの値を返します。1つ目の値は、ステータスの変更を
;;検知したディスクリプタの数です。timeoutが経過したら0になるでしょう。
;;2、3、4番目の値は、それぞれ読み込み、書き出し、例外のステータスを変更
;;するディスクリプタの集合を含む<fdset>オブジェクトです。
;;readfds、writefds、exceptfdsのうちの1つ以上に#fを
;;渡すと、対応する戻り値は#fになります。
;;
;;sys-select!の仲間は、それが渡された引数<fdset>を変更することを
;;除けば、sys-selectと同じように動作します。
;;sys-selectは、新しい<fdset>オブジェクトを作り、その
;;引数を変更しません。
;;
;;@param readfds 
;;@param writefds 
;;@param exceptfds 
;;@param :optional 
;;@param timeout 

;;;;;
;;@type Function
;;@name sys-fdset-max-fd
;;@description fdsetにある最大のファイルディスクリプタ番号を返します。
;;
;;@param fdset 

;;;;;
;;@type Function
;;@name list->sys-fdset
;;@description fdsetを整数のファイルディスクリプタのリストに変換し、またその逆を行います。
;;実際は、list->sys-fdsetは
;;(lambda (fds) (apply sys-fdset fds)) のように動作するため、
;;整数のファイルディスクリプタ以外にポートや他のfdsetを与えることもできます。
;;
;;@param fds 

;;;;;
;;@type Function
;;@name sys-fdset->list
;;@description fdsetを整数のファイルディスクリプタのリストに変換し、またその逆を行います。
;;実際は、list->sys-fdsetは
;;(lambda (fds) (apply sys-fdset fds)) のように動作するため、
;;整数のファイルディスクリプタ以外にポートや他のfdsetを与えることもできます。
;;
;;@param fdset 

;;;;;
;;@type Function
;;@name sys-fdset-clear!
;;@description fdsetの内容をクリアし、それ自身を返します。
;;
;;@param fdset 

;;;;;
;;@type Function
;;@name sys-fdset-copy!
;;@description src-fdsetの内容をdest-fdsetにコピーします。
;;dest-fdsetを返します。
;;
;;@param dest-fdset 
;;@param src-fdset 

;;;;;
;;@type Function
;;@name sys-fdset-set!
;;@description fdsetの特定のファイルディスクリプタビットを取得・セットできます。
;;port-or-fdは関連付けられたファイルディスクリプタを持っていないポートで、
;;sys-fdset-refは#fを返し、sys-fdset-set!はfdsetを
;;変更しません。flagは真偽値でなければなりません。
;;
;;下記のように、sys-fdset-refのジェネリックなセッタが使えます。
;;example:
;;  (set! (sys-fdset-ref fdset port-or-fd) flag)
;;    ≡  (sys-fdset-set! fdset port-or-fd flag)
;;
;;@param fdset 
;;@param port-or-fd 
;;@param flag 

;;;;;
;;@type Function
;;@name sys-fdset-ref
;;@description fdsetの特定のファイルディスクリプタビットを取得・セットできます。
;;port-or-fdは関連付けられたファイルディスクリプタを持っていないポートで、
;;sys-fdset-refは#fを返し、sys-fdset-set!はfdsetを
;;変更しません。flagは真偽値でなければなりません。
;;
;;下記のように、sys-fdset-refのジェネリックなセッタが使えます。
;;example:
;;  (set! (sys-fdset-ref fdset port-or-fd) flag)
;;    ≡  (sys-fdset-set! fdset port-or-fd flag)
;;
;;@param fdset 
;;@param port-or-fd 

;;;;;
;;@type Function
;;@name sys-fdset
;;@description elt ...で指定されたファイルディスクリプタを持つ
;;新たな<sys-fdset>のインスタンスを作成して返します。
;;各eltは、ファイルディスクリプタを指定する整数、ポート、
;;もしくは<sys-fdset>のインスタンスでなければなりません。
;;最後の場合は、与えられたfdsetに含まれるディスクリプタが
;;新たなfdsetにコピーされます。
;;
;;@param elt 
;;@param ... 

;;;;;
;;@type Class
;;@name <sys-fdset>
;;@description ファイルディスクリプタの集合であるfd_setを表します。
;;makeメソッドによって、空のファイルディスクリプタの集合を作れます。
;;example:
;;  (make <sys-fdset>)
;;

;;;;;
;;@type Function
;;@name sys-wait-stopsig
;;@description [POSIX]
;;引数は、sys-waitpidの2つ目の戻り値である終了ステータスです。
;;子プロセスが停止されれば、sys-wait-stopped?は#tを
;;返します。このステータスは、sys-waitpidがuntraced引数に
;;真値を持っている場合にのみ捕捉されます。sys-wait-stopsigは
;;子プロセスを停止させたシグナルの番号を返します。
;;
;;@param status 

;;;;;
;;@type Function
;;@name sys-wait-stopped?
;;@description [POSIX]
;;引数は、sys-waitpidの2つ目の戻り値である終了ステータスです。
;;子プロセスが停止されれば、sys-wait-stopped?は#tを
;;返します。このステータスは、sys-waitpidがuntraced引数に
;;真値を持っている場合にのみ捕捉されます。sys-wait-stopsigは
;;子プロセスを停止させたシグナルの番号を返します。
;;
;;@param status 

;;;;;
;;@type Function
;;@name sys-wait-termsig
;;@description [POSIX]
;;引数は、sys-waitかsys-waitpidの2つ目の戻り値である終了ステータスです。
;;子プロセスが捕捉されないシグナルで終了した場合は、sys-wait-signaled?は
;;#tを返します。
;;sys-wait-termsigは、子プロセスを終了したシグナルの番号を返します。
;;
;;@param status 

;;;;;
;;@type Function
;;@name sys-wait-signaled?
;;@description [POSIX]
;;引数は、sys-waitかsys-waitpidの2つ目の戻り値である終了ステータスです。
;;子プロセスが捕捉されないシグナルで終了した場合は、sys-wait-signaled?は
;;#tを返します。
;;sys-wait-termsigは、子プロセスを終了したシグナルの番号を返します。
;;
;;@param status 

;;;;;
;;@type Function
;;@name sys-wait-exit-status
;;@description [POSIX]
;;引数はsys-waitかsys-waitpidの2番目の値として返される
;;終了ステータスです。子プロセスが正常終了したら、sys-wait-exited?は
;;#tを返します。sys-wait-exit-statusは、子プロセスが
;;exit(2)に渡した終了コードか、main()の戻り値を返します。
;;
;;@param status 

;;;;;
;;@type Function
;;@name sys-wait-exited?
;;@description [POSIX]
;;引数はsys-waitかsys-waitpidの2番目の値として返される
;;終了ステータスです。子プロセスが正常終了したら、sys-wait-exited?は
;;#tを返します。sys-wait-exit-statusは、子プロセスが
;;exit(2)に渡した終了コードか、main()の戻り値を返します。
;;
;;@param status 

;;;;;
;;@type Function
;;@name sys-waitpid
;;@description [POSIX] これは、waitの拡張バージョンである、waitpid(3)への
;;インターフェースです。
;;
;;pidは、待つべき子プロセスを指定する正確な整数です。正の整数ならば、
;;特定の子プロセスを待ちます。0ならば、このプロセスグループのいずれかの
;;メンバを待ちます。-1ならば、いずれかの子プロセスを待ちます。
;;-1よりも小さければ、プロセスグループIDがpidの絶対値と等しいいずれかの
;;子プロセスを待ちます。
;;
;;待つべき子プロセスが存在しない場合や、pidに具体的なプロセスIDが
;;与えられたがそれが現在のプロセスの子プロセスで内場合は
;;エラー(<system-error>, ECHILD)となります。
;;
;;
;;キーワード引数nohangに真値が指定されていなければ、
;;呼んでいるプロセスは、それらの子プロセスのうちの1つが終了するまで一時停止します。
;;
;;キーワード引数untracedに真値が指定されていれば、
;;停止した子プロセスのステータスも返ります。
;;
;;戻り値は2つの正確整数で、1つ目は子プロセスのID、2つ目はステータスコードです。
;;nohangが真で子プロセスのステータスが利用できない場合は、1つ目の値は0です。
;;
;;Windowsネイティブ環境では、この関数はpidにWindowsプロセスハンドル
;;(<win:handle>)オブジェクトを受け取ることもできます。
;;その場合はそのハンドルの指すプロセスの終了を待ちます。
;;また、-1を渡していずれかの子プロセスの終了を待つこともできますが、
;;特定のプロセスグループの中の子プロセスを待つことはできません。
;;
;;@param pid 
;;@param :key 
;;@param nohang 
;;@param untraced 

;;;;;
;;@type Function
;;@name sys-wait
;;@description [POSIX] システムのwait(2)を呼びます。プロセスは、子プロセスの1つが
;;終了するまでその実行を一時停止します。2つの正確整数、1つ目は子プロセスのID、
;;2つ目はステータスコードを返します。ステータスコードは以下の関数によって
;;解釈できます。
;;

;;;;;
;;@type Function
;;@name sys-fork-and-exec
;;@description sys-execと同じですが、ファイルディスクリプタとシグナルマスクを変更して
;;execvp(2)を実行する直前に、fork(2)を実行します。
;;子プロセスのプロセスidを返します。引数の意味はsys-execと同じです。
;;
;;他のスレッドが走っている環境下で別プログラムをspawnしたい場合は、
;;sys-forkとsys-execを別々に使うのではなく、
;;この手続きを使ってください。
;;この手続き中では、fork(2)とexecvp(2)の間で
;;メモリアロケーションもロックの獲得も行われないため、
;;マルチスレッド環境で実行しても安全になっています。
;;
;;Windowsネイティブ環境では、この手続きはプロセスIDではなく
;;作られたプロセスに対するWindowsのハンドルオブジェクト 
;;(<win:handle>) を返します。Windowsプロセスハンドル
;;特有の手続きについては後に述べます。
;;
;;また、sys-exec同様、Windowsネイティブ環境では、標準入力、標準出力、標準エラー出力に
;;関するリダイレクションのみが処理されます。
;;
;;detachedキーワード引数に真の値が与えられた場合、
;;実行されるプロセスは現在のプロセスグループからは切り離されます。
;;つまり、現在のプロセスグループに送られるシグナルを、新しいプロセスは受け取りません。
;;この動作はデーモンプロセスを作る際の標準的な手順のひとつです。
;;
;;Unixでは、実行されるプロセスがsetsid(2)を呼んで
;;独自のセッションを作るだけでなく、余分なfork(2)
;;を実行することで親をinitプロセス (pid=1) に切り替えます。
;;(つまり、実行されるプロセスは実は呼び出すプロセスの孫にあたります。
;;親子関係はなくなりますが。返されるpidは実際に走っているこのプロセスのもので、
;;すぐに終了する中間プロセスのものではありません。)
;;
;;実行されるプロセスの親が
;;また。Windowsネイティブ環境では、
;;実行されるプロセスが新たに作られたプロセスグループに属します。
;;
;;Windowsネイティブ環境では、このフラグがあると
;;プロセス作成時にCREATE_NEW_PROCESS_GROUPフラグが使われます。
;;
;;@param command 
;;@param args 
;;@param :key 
;;@param directory 
;;@param iomap 
;;@param sigmask 
;;@param detached 

;;;;;
;;@type Function
;;@name sys-exec
;;@description [POSIX+]
;;commandを引数のリストであるargsを伴って実行します。
;;現在のプロセスイメージはcommandに置き換えられるので、
;;この関数は戻りません。
;;
;;argsの全ての要素は文字列でなければなりません。
;;argsの最初の要素は、argv[0]、すなわちプログラム名として
;;使われます。
;;
;;キーワード引数directoryは文字列によるディレクトリ名
;;か#fでなければなりません。
;;文字列だった場合、sys-execはプログラムを実行する前に
;;カレントワーキングディレクトリを指定ディレクトリに移動します。
;;
;;キーワード引数のiomapは、与えられた場合は、開かれている
;;ファイルディスクリプタがどのように扱われるかを指定します。
;;この引数は以下のフォーマットでなければなりません。
;;example:
;;  ((@i{to-fd} . @i{from-port-or-fd}) ...)
;;ディスクリプタかポートでなければなりません。
;;リストのそれぞれの要素は、現在のプロセスの@i{from-port-or-fd}の
;;ファイルディスクリプタを、実行されているプロセスのファイルディスクリプタ
;;
;;iomapが与えられると、iomapリストで指定されていないいかなるファイル
;;ディスクリプタもexec()の前に閉じられます。さもなければ、現在のプロセスの
;;全てのファイルディスクリプタは開かれたままになります。
;;
;;example:
;;  (sys-exec "ls" '("ls" "-l")) ==> ;; ls is executed.
;;  
;;  (let ((out (open-output-file "ls.out")))
;;    (sys-exec "ls" '("ls" "-l") :iomap `((2 . 1) (1 . ,out)))
;;     ==>
;;    ;; ls is executed, with its stderr redirected
;;    ;; to the current process's stdout, and its
;;    ;; stdout redirected to the file "ls.out".
;;
;;sigmaskキーワード引数には、<sys-sigset>のインスタンスか
;;#fを渡すことができます (シグナルマスクについては@xref{Signal}を
;;参照して下さい)。<sys-sigset>のインスタンスを渡した場合、
;;この関数を呼び出したスレッドのシグナルマスクが、exec(2)を呼ぶ
;;直前にそれによって置き換えられます。
;;これは、全てのシグナルをブロックしているスレッドから外部プログラムを走らせる
;;ような場合に便利です (Signals and threadsで述べるように、
;;新たなスレッドは全てのシグナルをデフォルトでブロックします)。
;;このような場合にsigmaskを設定しないと、execされたプロセスは
;;スレッドのシグナルマスクを継承し、ほとんどのシグナルを受け付けないプロセスと
;;なってしまうからです。通常、それはあまり便利ではありません。
;;
;;sys-execがエラーに遭遇すると、たいていの場合エラー条件を投げます。
;;しかし一旦ファイルディスクリプタの順番が変えられると、合理的な方法でエラーを処理する
;;ことは実行不可能です(標準エラーがまだ有効かどうかさえ知る術がありません)。
;;したがって、その場合はGaucheはエラー時には単に終了するだけです。
;;
;;Windowsネイティブ環境では、標準入力、標準出力、標準エラー出力に
;;関するリダイレクションのみが処理されます。Windowsはプロセス間通信としての
;;シグナルをサポートしないので、シグナルマスクは無視されます。
;;
;;@param command 
;;@param args 
;;@param :key 
;;@param directory 
;;@param iomap 
;;@param sigmask 

;;;;;
;;@type Function
;;@name sys-fork
;;@description [POSIX]
;;現在のプロセスをフォークします。子プロセスにいるならば0が返り、
;;親プロセスにいるならば子プロセスのプロセスIDが返ります。
;;全ての開かれているファイルディスクリプタは、親プロセスと子プロセスで
;;共有されます。詳細は、システムのfork(2)を参照して下さい。
;;
;;子プロセスがsys-execを呼ぶ代わりにSchemeコードを実行して
;;終了する場合は、exitではなくsys-exitを呼ぶ必要があります。
;;通常のexitの呼び出しはファイルバッファのフラッシュを試み、
;;OSによっては親のファイルバッファを混乱させるでしょう。
;;
;;sys-forkは複数のスレッドが走っている時には安全ではないことに
;;注意してください。fork(2)システムコールはプロセスのメモリイメージを
;;複製しますが、それには他のスレッドでロックされているmutexも含まれます。
;;もしsys-forkの瞬間に他のスレッドが何かをロックしていたとすれば、
;;子プロセスでもその資源はロックされたままになりますが、
;;その時子プロセスはもはやその資源をアンロックするスレッドを持っていません。
;;(これは内部で使っているmutexにも起こり得るため、Schemeレベルでmutexを
;;全く使っていないとしても防ぐことはできません)。
;;
;;やりたいことが、マルチスレッドアプリケーションで別プログラムをspawnする
;;ことであるなら、下に説明するsys-fork-and-execを使ってください。
;;どうしても別プロセスでSchemeコードを走らせたいのなら、よくある方法は、
;;アプリケーションの起動後すぐにマネージャプロセスとなる子プロセスをfork
;;しておき、新たなプロセスが欲しくなったらそのマネージャプロセスに
;;forkを依頼するという方法です。
;;
;;Windowsネイティブな環境ではこの手続きは使えません。
;;

;;;;;
;;@type Function
;;@name sys-system
;;@description [POSIX]
;;サブプロセスでcommandを実行します。commandは通常、
;;shへ渡されるので、シェルのメタキャラクタは解釈されます。
;;
;;この関数は、system()が返した整数値を返します。
;;POSIXはsystem()が何を返すかを定義していないので、
;;戻り値をポータブルな方法で解釈することができません。
;;
;;Windowsネイティブな環境では、引数はcmd.exeに渡されます。
;;
;;@param command 

;;;;;
;;@type Function
;;@name seconds->time
;;@description [SRFI-18][SRFI-21]
;;timeオブジェクトと秒数(POSIX時間)を変換します。
;;time->secondsの引数timeは、<time>オブジェクトで
;;なければなりません。
;;
;;@param seconds 

;;;;;
;;@type Function
;;@name time->seconds
;;@description [SRFI-18][SRFI-21]
;;timeオブジェクトと秒数(POSIX時間)を変換します。
;;time->secondsの引数timeは、<time>オブジェクトで
;;なければなりません。
;;
;;@param time 

;;;;;
;;@type Function
;;@name time?
;;@description [SRFI-18][SRFI-19][SRFI-21]
;;objがtimeオブジェクトなら#tを返します。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name current-time
;;@description [SRFI-18][SRFI-21]
;;現在の時間をtime-utcで表す<time>オブジェクトを返します。
;;Time data types and proceduresでは、current-timeが再定義され、
;;timeの型を指定するオプショナル引数を受け付けるようにされています。
;;

;;;;;
;;@type Class
;;@name <time>
;;@description ある時刻を表す<time>オブジェクトです。
;;
;;timeの型を表します。デフォルトはtime-utcで、Unixエポックからの
;;秒数を表します。SRFI-19(Time data types and procedures参照)
;;ではさらに型が追加されています。
;;timeの秒の部分です。
;;timeのナノ秒の部分です。
;;

;;;;;
;;@type Function
;;@name sys-tm->alist
;;@description (Deprecated function)
;;
;;@param tm 

;;;;;
;;@type Function
;;@name sys-mktime
;;@description [POSIX] ローカルタイムとして表現された <sys-tm> オブジェクトである
;;tm を POSIX 時間(エポックからの秒数)に変換します。
;;
;;@param tm 

;;;;;
;;@type Function
;;@name sys-strftime
;;@description [POSIX] <sys-tm> オブジェクトである tm を、フォーマット文字列
;;format に従って文字列表現に変換します。
;;
;;@param format 
;;@param tm 

;;;;;
;;@type Function
;;@name sys-asctime
;;@description [POSIX] <sys-tm> オブジェクトである tm を文字列表現に変換します。
;;
;;@param tm 

;;;;;
;;@type Function
;;@name sys-difftime
;;@description [POSIX] 2つの時間の差を、秒の実数で返します。Time0 とtime1 は
;;POSIX 時間か SRFI 時間です。
;;
;;@param time1 
;;@param time0 

;;;;;
;;@type Function
;;@name sys-ctime
;;@description [POSIX] time を POSIX の ctime() を使って文字列表現に変換します。
;;Time は POSIX 時間か SRFI 時間です。
;;
;;@param time 

;;;;;
;;@type Function
;;@name sys-localtime
;;@description [POSIX] time を <sys-tm> オブジェクトに変換します。
;;標準時での表現かローカルタイムゾーンでの表現かで使い分けます。
;;Time は POSIX 時間か SRFI 時間です。
;;
;;@param time 

;;;;;
;;@type Function
;;@name sys-gmtime
;;@description [POSIX] time を <sys-tm> オブジェクトに変換します。
;;標準時での表現かローカルタイムゾーンでの表現かで使い分けます。
;;Time は POSIX 時間か SRFI 時間です。
;;
;;@param time 

;;;;;
;;@type Class
;;@name <sys-tm>
;;@description カレンダーである、struct tm を表します。以下のスロットを持ちます。
;;秒。0-61。
;;分。0-59。
;;時。0-23。
;;月の日。1 から数える。1-31。
;;月。0 から数える。0-11。
;;1900年からの年数。例えば、102 なら 2002年。
;;曜日。日曜は 0 .. 土曜は 6。
;;1年の中での日数。1月1日は 0 .. 12月31日は 364 か 365。
;;夏時間が有効であるかどうかを指定するフラグ。有効なら正の数、無効なら 0、
;;分からなければ負の数。
;;

;;;;;
;;@type Function
;;@name sys-gettimeofday
;;@description 2つの値を返します。1970/1/1 0:00:00 UTC を基準として、
;;1つ目の値は秒数、2つ目の値は端数をマイクロ秒で表したものです。
;;システムが gettimeofday 呼び出しをサポートしていない場合、
;;この手続きは time() を呼び出し、その場合はマイクロ秒の
;;部分はいつも 0 です。
;;

;;;;;
;;@type Function
;;@name sys-time
;;@description [POSIX] 現在の時間を POSIX 時間(エポック(00:00:00 UTC, January 1, 1970)
;;からの秒数)で返します。マシンのアーキテクチャによっては、不正確数で
;;あるかもしれません。
;;

;;;;;
;;@type Function
;;@name sys-strerror
;;@description errorはシステムエラー番号を表現する非負正確整数でなければなりま
;;せん。この関数はエラーを説明する文字列を返します。
;;
;;errnoを表現するのに、以下の定義済み定数が使えます。各定数はシス
;;テムエラーを表現する非負正確整数に束縛されています。実際の値はシステム
;;ごとに違い、またシステムによっては定義されていない定数があるということ
;;に注意してください。
;;
;;example:
;;  E2BIG             EHOSTDOWN         ENETDOWN          ENXIO
;;  EACCES            EHOSTUNREACH      ENETRESET         EOPNOTSUPP
;;  EADDRINUSE        EIDRM             ENETUNREACH       EOVERFLOW
;;  EADDRNOTAVAIL     EILSEQ            ENFILE            EPERM
;;  EADV              EINPROGRESS       ENOANO            EPFNOSUPPORT
;;  EAFNOSUPPORT      EINTR             ENOBUFS           EPIPE
;;  EAGAIN            EINVAL            ENOCSI            EPROTO
;;  EALREADY          EIO               ENODATA           EPROTONOSUPPORT
;;  EBADE             EISCONN           ENODEV            EPROTOTYPE
;;  EBADF             EISDIR            ENOENT            ERANGE
;;  EBADFD            EISNAM            ENOEXEC           EREMCHG
;;  EBADMSG           EKEYEXPIRED       ENOKEY            EREMOTE
;;  EBADR             EKEYREJECTED      ENOLCK            EREMOTEIO
;;  EBADRQC           EKEYREVOKED       ENOLINK           ERESTART
;;  EBADSLT           EL2HLT            ENOMEDIUM         EROFS
;;  EBFONT            EL2NSYNC          ENOMEM            ESHUTDOWN
;;  EBUSY             EL3HLT            ENOMSG            ESOCKTNOSUPPORT
;;  ECANCELED         EL3RST            ENONET            ESPIPE
;;  ECHILD            ELIBACC           ENOPKG            ESRCH
;;  ECHRNG            ELIBBAD           ENOPROTOOPT       ESRMNT
;;  ECOMM             ELIBEXEC          ENOSPC            ESTALE
;;  ECONNABORTED      ELIBMAX           ENOSR             ESTRPIPE
;;  ECONNREFUSED      ELIBSCN           ENOSTR            ETIME
;;  ECONNRESET        ELNRNG            ENOSYS            ETIMEDOUT
;;  EDEADLK           ELOOP             ENOTBLK           ETOOMANYREFS
;;  EDEADLOCK         EMEDIUMTYPE       ENOTCONN          ETXTBSY
;;  EDESTADDRREQ      EMFILE            ENOTDIR           EUCLEAN
;;  EDOM              EMLINK            ENOTEMPTY         EUNATCH
;;  EDOTDOT           EMSGSIZE          ENOTNAM           EUSERS
;;  EDQUOT            EMULTIHOP         ENOTSOCK          EWOULDBLOCK
;;  EEXIST            ENAMETOOLONG      ENOTTY            EXDEV
;;  EFAULT            ENAVAIL           ENOTUNIQ          EXFULL
;;  EFBIG
;;
;;@param errno 

;;;;;
;;@type Function
;;@name sys-setrlimit
;;@description [POSIX] Get and set resource limits respectively.
;;Resource is an integer constant to specify the resource
;;of concern.  The following constants are defined.
;;(The constants marked as bsd and/or linux indicates that they
;;are not defined in POSIX but defined in BSD and/or Linux.
;;Other systems may or may not have them.  Consult getrlimit
;;manpage of your system for the details.)
;;
;;example:
;;  RLIMIT_AS                      RLIMIT_CORE
;;  RLIMIT_CPU                     RLIMIT_DATA
;;  RLIMIT_FSIZE                   RLIMIT_LOCKS
;;  RLIMIT_MEMLOCK (bsd/linux)     RLIMIT_MSGQUEUE (linux)
;;  RLIMIT_NICE (linux)            RLIMIT_NOFILE
;;  RLIMIT_NPROC (bsd/linux)       RLIMIT_RSS (bsd/linux)
;;  RLIMIT_RTPRIO (linux)          RLIMIT_SIGPENDING (linux)
;;  RLIMIT_SBSIZE                  RLIMIT_STACK
;;  RLIMIT_OFILE
;;
;;@param resource 
;;@param current 
;;@param :optional 
;;@param maximum 

;;;;;
;;@type Function
;;@name sys-getrlimit
;;@description [POSIX] Get and set resource limits respectively.
;;Resource is an integer constant to specify the resource
;;of concern.  The following constants are defined.
;;(The constants marked as bsd and/or linux indicates that they
;;are not defined in POSIX but defined in BSD and/or Linux.
;;Other systems may or may not have them.  Consult getrlimit
;;manpage of your system for the details.)
;;
;;example:
;;  RLIMIT_AS                      RLIMIT_CORE
;;  RLIMIT_CPU                     RLIMIT_DATA
;;  RLIMIT_FSIZE                   RLIMIT_LOCKS
;;  RLIMIT_MEMLOCK (bsd/linux)     RLIMIT_MSGQUEUE (linux)
;;  RLIMIT_NICE (linux)            RLIMIT_NOFILE
;;  RLIMIT_NPROC (bsd/linux)       RLIMIT_RSS (bsd/linux)
;;  RLIMIT_RTPRIO (linux)          RLIMIT_SIGPENDING (linux)
;;  RLIMIT_SBSIZE                  RLIMIT_STACK
;;  RLIMIT_OFILE
;;
;;@param resource 

;;;;;
;;@type Function
;;@name sys-ctermid
;;@description [POSIX] プロセスの制御端末の名前を返します。
;;これは単に``/dev/tty''かもしれません。sys-ttynameも参照して下さい。
;;

;;;;;
;;@type Function
;;@name sys-times
;;@description [POSIX]
;;

;;;;;
;;@type Function
;;@name sys-getppid
;;@description [POSIX] 現在のプロセスIDと親プロセスのIDをそれぞれ返します。
;;

;;;;;
;;@type Function
;;@name sys-getpid
;;@description [POSIX] 現在のプロセスIDと親プロセスのIDをそれぞれ返します。
;;

;;;;;
;;@type Function
;;@name sys-setsid
;;@description [POSIX] 呼んでいるプロセスがプロセスグループリーダでなければ、
;;新しいセッションを作ります。
;;

;;;;;
;;@type Function
;;@name sys-setpgid
;;@description [POSIX] プロセスpidのプロセスグループIDをpgidにセットします。
;;pidが0ならば、現在のプロセスのプロセスIDが使われます。
;;pgidが0ならば、pidで指定されたプロセスのプロセスIDが
;;使われます。
;;(したがって、sys-getpgid(0, 0)は、現在のプロセスのプロセス
;;グループIDを現在のプロセスIDにセットします。)
;;
;;@param pid 
;;@param pgid 

;;;;;
;;@type Function
;;@name sys-getpgid
;;@description pidで指定されたプロセスのプロセスグループIDを返します。
;;pidが0の場合、現在のプロセスが使われます。
;;
;;getpgid()はPOSIXではないことに注意して下さい。
;;システムにgetpgid()がない場合、pidが0ならば
;;sys-getpgidがまだ動作しますが(それは単にsys-getpgrpを呼びます)
;;、pidが0でない場合はエラーが通知されます。
;;
;;@param pid 

;;;;;
;;@type Function
;;@name sys-getpgrp
;;@description [POSIX] 現在のプロセスのプロセスグループIDを返します。
;;

;;;;;
;;@type Function
;;@name sys-getlogin
;;@description [POSIX] 現在のプロセスの制御端末にログインしているユーザの名前を文字列で
;;返します。システムがその情報を決定できない場合、#fが返されます。
;;

;;;;;
;;@type Function
;;@name sys-getgroups
;;@description [POSIX] 補助的なグループのIDの整数のリストを返します。
;;

;;;;;
;;@type Function
;;@name sys-setuid
;;@description [POSIX] 現在のプロセスの実効ユーザIDをセットします。
;;
;;@param uid 

;;;;;
;;@type Function
;;@name sys-geteuid
;;@description [POSIX] 現在のプロセスの実ユーザIDと実効ユーザIDをそれぞれ整数で返します。
;;返されたユーザIDからユーザ名その他の情報を得るには
;;sys-uid->user-nameやsys-getpwuidを使って下さい
;;(Unix groups and users参照)。
;;

;;;;;
;;@type Function
;;@name sys-getuid
;;@description [POSIX] 現在のプロセスの実ユーザIDと実効ユーザIDをそれぞれ整数で返します。
;;返されたユーザIDからユーザ名その他の情報を得るには
;;sys-uid->user-nameやsys-getpwuidを使って下さい
;;(Unix groups and users参照)。
;;

;;;;;
;;@type Function
;;@name sys-setgid
;;@description [POSIX] 現在のプロセスの実効グループIDをセットします。
;;
;;@param gid 

;;;;;
;;@type Function
;;@name sys-getegid
;;@description [POSIX] 現在のプロセスの実グループIDと実効グループIDをそれぞれ整数で返します。
;;返されたグループIDからグループ名その他の情報を得るには
;;sys-gid->group-nameやsys-getgrgidを使って下さい
;;(Unix groups and users参照)。
;;

;;;;;
;;@type Function
;;@name sys-getgid
;;@description [POSIX] 現在のプロセスの実グループIDと実効グループIDをそれぞれ整数で返します。
;;返されたグループIDからグループ名その他の情報を得るには
;;sys-gid->group-nameやsys-getgrgidを使って下さい
;;(Unix groups and users参照)。
;;

;;;;;
;;@type Function
;;@name sys-getcwd
;;@description [POSIX] 現在の作業ディレクトリを文字列で返します。
;;システムから現在の作業ディレクトリが得られない場合は、エラーが通知されます。
;;sys-chdir(Other file operations参照)、current-directory
;;(Directory utilities参照)も参照して下さい。
;;

;;;;;
;;@type Function
;;@name sys-getdomainname
;;@description ドメイン名を返します。システムでgetdomainname()が使えない場合、
;;"localdomain"が返されます。
;;

;;;;;
;;@type Function
;;@name sys-gethostname
;;@description ホスト名を返します。システムでgethostname()が使えない場合、
;;sys-unameが返すリストの2番目の要素が使われます。
;;

;;;;;
;;@type Function
;;@name sys-uname
;;@description [POSIX] 次の5要素のリストを返します。
;;(sysname nodename release version machine)。
;;

;;;;;
;;@type Function
;;@name sys-sigwait
;;@description [POSIX]
;;maskは<sys-sigset>オブジェクトでなければなりません。
;;アトミックに、保留されたシグナルからmaskにあるシグナルの1つを
;;クリアし、クリアしたシグナルの番号を返します。maskにある
;;シグナルが1つも保留されていなければ、sys-sigwaitはシグナルが
;;届くまでブロックします。
;;
;;sys-sigwaitを呼ぶ前に、maskにある全てのシグナルを、
;;全スレッドからブロックしておく必要があります。シグナルをブロックして
;;いないスレッドがある場合、sys-sigwaitの動作は未定義です。
;;
;;註：sys-sigwaitはシステムのsigwait関数を呼び出しますが、
;;この関数は待つべきシグナルにシグナルハンドラが設定されていた場合の
;;振る舞いが未定義となっています。困ったことになるのを避けるために、
;;sys-sigwaitはまずmaskに含まれるシグナルに
;;ハンドラが設定されていたらそれをSIG_DFLにリセットしてから
;;sigwaitを呼び出し、それが戻った後でハンドラを元に戻します。
;;sys-sigwaitが待っている間に他のスレッドでシグナルハンドラを
;;変更してはいけません。そうした場合の動作は不定です。
;;
;;@param mask 

;;;;;
;;@type Function
;;@name sys-sigsuspend
;;@description アトミックに、スレッドのシグナルマスクをmaskにセットし、
;;呼び出しているスレッドを一時停止します。ブロックされておらずシグナル
;;ハンドラがインストールされているシグナルが送出されると、関連
;;付けられたハンドラが呼ばれ、sys-sigsuspendは戻ります。
;;
;;@param mask 

;;;;;
;;@type Function
;;@name sys-sigmask
;;@description 現在のスレッドのシグナルマスクを変更し、以前のシグナルマスクを返します。
;;maskには新しいマスクを指定する<sys-sigset>オブジェクトか、
;;あるいはマスクを変更せず現在のマスクを得るだけなら#fを渡します。
;;
;;maskに<sys-sigset>オブジェクトを渡した場合、
;;引数howは以下の整数定数のうちの1つでなければなりません。
;;SIG_SETMASK ------
;;  maskをそのスレッドのシグナルマスクとしてセットします。
;;SIG_BLOCK ------
;;  そのスレッドのシグナルマスクにmaskにあるシグナルを追加します。
;;SIG_UNBLOCK ------
;;  そのスレッドのシグナルマスクからmaskにあるシグナルを削除します。
;;
;;@param how 
;;@param mask 

;;;;;
;;@type Macro
;;@name with-signal-handlers
;;@description thunkの実行中だけシグナルハンドラを一時的に設定する便利なマクロです
;;(このマクロは便利ですが下に述べるような多少危険な性質もあるので、
;;注意して使って下さい)。
;;
;;handler-clauseは以下のいずれかの形式です
;;(signals expr ...) ------
;;  signalsは、評価された時に単独のシグナル番号、シグナル番号のリスト、
;;  あるいは<sys-sigset>オブジェクトを生成する式でなければなりません。
;;  signalsに含まれるシグナルを受け取った時に、expr ...を
;;  評価するようなハンドラを設定します。
;;  
;;(signals => handler) ------
;;  signalsは上と同じです。signalsに含まれるシグナルに
;;  対して、処理handlerを設定します。
;;  
;;  handlerは#t、#f、一つの引数を取る手続きのいずれか
;;  でなければなりません。
;;  handlerが手続きの場合、プロセスが指定されたシグナル(のうちのいずれか)を
;;  受けた時に、そのシグナル番号を引数としてhandlerが呼ばれます。
;;  handlerが#tの場合、指定されたシグナルにはオペレーティングシステムの
;;  デフォルトの振るまいが設定されます。
;;  handlerが#fの場合、指定されたシグナルは無視されます。
;;
;;thunkから制御が抜けた時に、with-signal-handlersが呼ばれた時点での
;;シグナルハンドラが再設定されます。
;;
;;注意： このフォームで一つ以上のシグナルハンドラを設定する場合、
;;それらは順にシステムに設定されます。全てのハンドラの設定が終る前に
;;シグナルが届いた場合、シグナルハンドラの設定や再設定が不完全なままになる
;;かもしれません。また、シグナルハンドラはグローバルな設定であり、
;;「スレッドローカル」なハンドラを設定することはできませんが、
;;with-signal-handlersの形式はそれを誤解させるかもしれません。
;;
;;@param (handler-clause ...) thunk 

;;;;;
;;@type Function
;;@name set-signal-pending-limit
;;@description 
;;
;;@param limit 

;;;;;
;;@type Function
;;@name get-signal-pending-limit
;;@description 
;;

;;;;;
;;@type Function
;;@name get-signal-handlers
;;@description 現在の全てのシグナルハンドラの設定を連想リストにして返します。
;;返されるリストの各要素のcarには<sys-sigset>オブジェクトが、
;;cdrにはそれらのシグナルに対応するハンドラ(手続きもしくはブール値)がセットされて
;;います。
;;

;;;;;
;;@type Function
;;@name get-signal-handler-mask
;;@description シグナルsignumに設定されたハンドラもしくはシグナルマスクを
;;それぞれ返します。get-signal-handlerが返す値の意味については
;;set-signal-handler!を参照してください。
;;
;;@param signum 

;;;;;
;;@type Function
;;@name get-signal-handler
;;@description シグナルsignumに設定されたハンドラもしくはシグナルマスクを
;;それぞれ返します。get-signal-handlerが返す値の意味については
;;set-signal-handler!を参照してください。
;;
;;@param signum 

;;;;;
;;@type Function
;;@name set-signal-handler!
;;@description signalsはシグナル番号か<sys-sigset>オブジェクト、
;;handlerは#t、#f、#<undef>、
;;一つの引数を取る手続きのいずれかでなければなりません。
;;handlerが手続きの場合、プロセスが指定されたシグナル(のうちのいずれか)を
;;受けた時に、そのシグナル番号を引数としてhandlerが呼ばれます。
;;
;;デフォルトでは、handlerは、signalsに含まれる
;;シグナルが(その時点で有効なシグナルマスクに加えて)ブロックされた状態で
;;実行されます。オプショナルなsigmask引数に
;;<sys-sigset>オブジェクトを渡すことで、
;;ブロックすべきシグナルを明示することもできます。
;;ただ、シグナルマスクはスレッド毎であることに注意して下さい。
;;もし複数のスレッドがあるシグナルをブロックしていない場合、例えsigmask
;;を指定していたとしても、ひとつのスレッドでhandlerを実行中に
;;別のスレッドで並行してhandlerが呼ばれる可能性はあります。
;;各スレッドのシグナルマスクを適切に設定することでそのようなケースを
;;避けるようにして下さい。
;;
;;handlerの中でできる操作にはほとんど制限がありません。
;;handlerからエラーを投げたり、他の場所で補捉された継続を呼ぶことも
;;できます。但し、handler内で補捉した継続はhandlerから
;;戻った時点で無効になります。
;;
;;handlerが#tの場合、指定されたシグナルにはオペレーティングシステムの
;;デフォルトの振るまいが設定されます。
;;handlerが#fの場合、指定されたシグナルは無視されます。
;;
;;handlerが#<undef>
;;(Undefined values参照) であった場合は、
;;Gaucheはその時点のOSレベルのシグナルハンドラを変更しません。
;;この引数はset-signal-handler!に対してはあまり
;;意味を持ちません; 何もせずに返るだけだからです。
;;しかし、get-signal-handlerで#<undef>が
;;返った場合、Gaucheがそのシグナルハンドラを一度もいじっていないことを
;;示します。
;;(一度でもGaucheがシグナルハンドラをインストールした場合、
;;get-signal-handlerが#<undef>を再び
;;返すことはありません。)
;;
;;マルチスレッドプログラムでは、
;;シグナルハンドラの設定はスレッド間で共有されることに注意して下さい。
;;ハンドラはシグナルを受けたスレッドで実行されます。
;;詳しくはSignals and threadsを参照して下さい。
;;
;;@param signals 
;;@param handler 
;;@param :optional 
;;@param sigmask 

;;;;;
;;@type Function
;;@name sys-kill
;;@description [POSIX]
;;シグナルsigを指定されたプロセス(群)に送ります。
;;sigは正確な正整数でなければなりません。pidは正確な整数でなければ
;;ならず、次のルールで対象となるプロセスを指定します。
;;  pidが正ならば、それがそのまま対象となるプロセスIDです。
;;  pidがゼロならば、シグナルは現在のプロセスのプロセスグループ内の全ての
;;  プロセスに送られます。
;;  pidが-1より小さければ、シグナルはプロセスグループIDが-pidである
;;  全てのプロセスに送られます。
;;
;;Windowsネイティブ環境では、sys-killはpidに正整数か
;;プロセスハンドル(<win:handle>のインスタンス)を取ります。
;;sigがサポートするのはSIGKILL、SIGINT、SIGABRT
;;のみです。SIGKILLに対してはTerminateProcessを使って
;;対象プロセスを終了させます。SIGINTとSIGABRTに対しては
;;対象プロセスにそれぞれCTRL_C_EVENTとCTRL_BREAK_EVENTを
;;送ります。
;;
;;@param pid 
;;@param sig 

;;;;;
;;@type Function
;;@name sys-signal-name
;;@description シグナル番号の名前を返します。(シグナル番号はシステムに依存します)。
;;
;;example:
;;  (sys-signal-name 2) ==> "SIGINT"
;;
;;@param signal 

;;;;;
;;@type Function
;;@name sys-sigset-empty!
;;@description システムで定義された全てのシグナルをsigsetにセット、
;;もしくはsigsetを空にします。
;;
;;@param sigset 

;;;;;
;;@type Function
;;@name sys-sigset-fill!
;;@description システムで定義された全てのシグナルをsigsetにセット、
;;もしくはsigsetを空にします。
;;
;;@param sigset 

;;;;;
;;@type Function
;;@name sys-sigset-delete!
;;@description sigsetは<sys-sigset>オブジェクトでなければなりません。
;;これらの手続きはsigsetに指定されたシグナルを追加、
;;もしくはsigsetから指定されたシグナルを削除します。
;;変更されたsigsetが返されます。
;;
;;signalにはシグナル番号、他の<sys-sigset>オブジェクト、あるいは
;;#tを渡すことができます。#tを渡した場合は全てのシグナルが
;;対象となります。
;;
;;@param sigset 
;;@param signal 
;;@param ... 

;;;;;
;;@type Function
;;@name sys-sigset-add!
;;@description sigsetは<sys-sigset>オブジェクトでなければなりません。
;;これらの手続きはsigsetに指定されたシグナルを追加、
;;もしくはsigsetから指定されたシグナルを削除します。
;;変更されたsigsetが返されます。
;;
;;signalにはシグナル番号、他の<sys-sigset>オブジェクト、あるいは
;;#tを渡すことができます。#tを渡した場合は全てのシグナルが
;;対象となります。
;;
;;@param sigset 
;;@param signal 
;;@param ... 

;;;;;
;;@type Function
;;@name sys-sigset
;;@description signal ...をメンバーとする<sys-sigset>の
;;インスタンスを作成して返します。
;;各signalにはシグナル番号、他の<sys-sigset>オブジェクト、あるいは
;;#tを渡すことができます。#tを渡した場合は全てのシグナルが
;;対象となります。
;;
;;example:
;;  (sys-sigset SIGHUP SIGINT) ==> #<sys-sigset [HUP|INT]>
;;
;;@param signal 
;;@param ... 

;;;;;
;;@type Class
;;@name <sys-sigset>
;;@description シグナルの集合を表します。空のシグナルの集合は次の式で作成できます：
;;example:
;;  (make <sys-sigset>) ==> #<sys-sigset []>
;;

;;;;;
;;@type Function
;;@name sys-localeconv
;;@description [POSIX]
;;現在のロケールで数値をフォーマットする際に必要な様々な情報をassoc listに
;;して返します。
;;

;;;;;
;;@type Function
;;@name sys-setlocale
;;@description [POSIX]
;;カテゴリーcategoryのロケールをlocaleにセットします。
;;categoryは整数でなければなりません；以下の変数がcategoryの
;;ために定義されています。localeはロケールを表す文字列です。
;;成功した場合は新しいロケール名を、ロケールが変更できなかった場合は#fを
;;返します。
;;
;;@param category 
;;@param locale 

;;;;;
;;@type Function
;;@name sys-crypt
;;@description これは、crypt(3)へのインターフェースです。keyとsaltは
;;文字列でなければならず、暗号化された文字列が返されます。
;;crypt(3)が利用できないシステムでこの関数を呼ぶとエラーが通知されます。
;;
;;このルーチンは、システムのパスワードデータベースを使ってパスワードチェックを
;;しなければならない時以外に使うべきではありません。独自のパスワードデータベースを
;;新たに作る場合は、crypt.bcryptモジュール(Password hashing)を
;;使ってください。
;;
;;@param key 
;;@param salt 

;;;;;
;;@type Function
;;@name sys-user-name->uid
;;@description ユーザIDとユーザ名を相互変換する便利な手続きです。
;;
;;@param name 

;;;;;
;;@type Function
;;@name sys-uid->user-name
;;@description ユーザIDとユーザ名を相互変換する便利な手続きです。
;;
;;@param uid 

;;;;;
;;@type Function
;;@name sys-getpwnam
;;@description [POSIX]
;;ユーザIDuidもしくはユーザ名nameで示されるユーザの情報を
;;<sys-passwd>で返します。該当するユーザが存在しない場合は
;;#fが返されます。
;;
;;@param name 

;;;;;
;;@type Function
;;@name sys-getpwuid
;;@description [POSIX]
;;ユーザIDuidもしくはユーザ名nameで示されるユーザの情報を
;;<sys-passwd>で返します。該当するユーザが存在しない場合は
;;#fが返されます。
;;
;;@param uid 

;;;;;
;;@type Class
;;@name <sys-passwd>
;;@description Unixのユーザの情報です。以下のスロットを持ちます。
;;
;;ユーザ名。
;;
;;ユーザID
;;
;;ユーザのプライマリグループID。
;;
;;ユーザの(暗号化された)パスワード。システムがシャドウパスワードファイルを
;;使っている場合は、 "x" のような無意味な文字列が入っています。
;;
;;Gecosフィールド。
;;
;;ユーザのホームディレクトリ。
;;
;;ユーザのログインシェル。
;;
;;ユーザのクラス。(特定のシステムでのみ有効)。
;;
;;

;;;;;
;;@type Function
;;@name sys-group-name->gid
;;@description グループIDとグループ名を相互変換する便利な手続きです。
;;
;;@param name 

;;;;;
;;@type Function
;;@name sys-gid->group-name
;;@description グループIDとグループ名を相互変換する便利な手続きです。
;;
;;@param gid 

;;;;;
;;@type Function
;;@name sys-getgrnam
;;@description [POSIX]
;;グループIDgidもしくはグループ名nameで示されるグループの情報を
;;<sys-group>で返します。該当するグループが存在しない場合は
;;#fが返されます。
;;
;;@param name 

;;;;;
;;@type Function
;;@name sys-getgrgid
;;@description [POSIX]
;;グループIDgidもしくはグループ名nameで示されるグループの情報を
;;<sys-group>で返します。該当するグループが存在しない場合は
;;#fが返されます。
;;
;;@param gid 

;;;;;
;;@type Class
;;@name <sys-group>
;;@description Unixのグループの情報です。以下のスロットを持ちます。
;;
;;グループ名。
;;
;;グループID
;;
;;グループパスワード。
;;
;;このグループに属するユーザ名のリスト。
;;
;;

;;;;;
;;@type Function
;;@name sys-ftruncate
;;@description [POSIX]
;;pathあるいはport-or-fdによって指定される通常ファイルの長さを
;;lengthにします。
;;ファイルがlengthより長かった場合、余分なデータは捨てられます。
;;ファイルがlengthより短かった場合、残りの部分にはゼロが詰められます。
;;
;;@param port-or-fd 
;;@param length 

;;;;;
;;@type Function
;;@name sys-truncate
;;@description [POSIX]
;;pathあるいはport-or-fdによって指定される通常ファイルの長さを
;;lengthにします。
;;ファイルがlengthより長かった場合、余分なデータは捨てられます。
;;ファイルがlengthより短かった場合、残りの部分にはゼロが詰められます。
;;
;;@param path 
;;@param length 

;;;;;
;;@type Function
;;@name sys-ttyname
;;@description [POSIX] port-or-fdはポートか整数のファイルディスクリプタです。
;;ポートに接続された端末の名前か、ポートが端末に接続されていなければ
;;#fを返します。
;;
;;@param port-or-fd 

;;;;;
;;@type Function
;;@name sys-isatty
;;@description [POSIX] port-or-fdはポートか整数のファイルディスクリプタです。
;;ポートがコンソールに接続されていれば#tを、そうでなければ#fを
;;返します。
;;
;;@param port-or-fd 

;;;;;
;;@type Function
;;@name sys-mkfifo
;;@description [POSIX] 名前がpathでモードがmodeのFIFO(名前付きパイプ)を
;;作ります。modeはファイルのモードを表す正の正確整数でなければ
;;なりません。
;;
;;@param path 
;;@param mode 

;;;;;
;;@type Function
;;@name sys-pipe
;;@description [POSIX] パイプを作り、ポートを2つ返します。
;;最初に返されるポートは入力ポートで、2番目に返されるポートは出力ポートです。
;;出力ポートへ書き出したデータは、入力ポートから読み込めます。
;;
;;bufferingは:full、:line、:noneのいずれかで、
;;パイプ上に開かれたポートのバッファリングモードを指定します。
;;バッファリングモードの詳細については、File portsを参照して下さい。
;;通常のケースでは、デフォルトのモードで間に合うでしょう。
;;
;;example:
;;  (receive (in out) (sys-pipe)
;;    (display "abc\n" out)
;;    (flush out)
;;    (read-line in)) ==> "abc"
;;
;;注意: 戻り値はバージョン0.3.15から変更されています。それまでは、
;;sys-pipeは2つのポートのリストを返します。
;;
;;@param :key 
;;@param (buffering :line) 

;;;;;
;;@type Function
;;@name sys-chdir
;;@description [POSIX]
;;chdir(2)へのインタフェースです。
;;current-directory(Directory utilities)も参照して下さい。
;;
;;@param dir 

;;;;;
;;@type Function
;;@name sys-utime
;;@description ファイルのアクセスタイムと変更タイムをatimeとmtimeが示す
;;値にセットします。atimeとmtimeが省略された場合は現在の時刻が
;;使われます。
;;File operationsのtouch-fileも参照して下さい。
;;
;;@param path 
;;@param :optional 
;;@param atime 
;;@param mtime 

;;;;;
;;@type Function
;;@name sys-chown
;;@description ファイルpathのオーナーとグループをowner-idとgruop-id
;;で示されるものに変更します。owner-idとgruop-idは正確な整数で
;;なければなりません。どちらかに-1が渡された場合は、対応する情報は変更されません。
;;
;;@param path 
;;@param owner-id 
;;@param group-id 

;;;;;
;;@type Function
;;@name sys-fchmod
;;@description 名前pathを持つ、もしくはport-or-fdで指定される
;;ファイルのパーミッションビットをmodeに変更します。
;;modeは小さな正の正確な整数で、POSIXスタイルのパーミッションビットマスク
;;でなければなりません。
;;
;;@param port-or-fd 
;;@param mode 

;;;;;
;;@type Function
;;@name sys-chmod
;;@description 名前pathを持つ、もしくはport-or-fdで指定される
;;ファイルのパーミッションビットをmodeに変更します。
;;modeは小さな正の正確な整数で、POSIXスタイルのパーミッションビットマスク
;;でなければなりません。
;;
;;@param path 
;;@param mode 

;;;;;
;;@type Function
;;@name sys-access
;;@description [POSIX]
;;pathnameへのアクセスが
;;modeに示されるモードで許可されているかどうかを示す真偽値を返します。
;;この手続きは、suid/sgidプログラムで使われるとエラーとなります(下記註参照)。
;;modeは以下に示す定数のコンビネーション(logical or)です。
;;R_OK ------
;;  pathnameをカレントユーザが読み出し可能かどうか
;;W_OK ------
;;  pathnameへカレントユーザが書き込み可能かどうか
;;X_OK ------
;;  pathnameをカレントユーザが実行可能かどうか(pathnameが
;;  ディレクトリの場合はサーチ可能かどうか)
;;F_OK ------
;;  pathnameのパーミッションフラグにかかわらず、pathnameが
;;  存在するかどうか (但しpathnameがあるディレクトリの読みだし許可は必要)。
;;
;;註: access(2)は、suid/sgidプログラム中で
;;実ユーザの権限を確かめるために使われた場合、セキュリティホールと
;;なります。
;;
;;@param pathname 
;;@param amode 

;;;;;
;;@type Function
;;@name sys-stat->file-type
;;@description Deprecated.
;;<sys-stat>オブジェクトの情報にアクセスするにはslot-refを
;;使って下さい。
;;
;;@param stat 

;;;;;
;;@type Function
;;@name sys-stat->ctime
;;@description Deprecated.
;;<sys-stat>オブジェクトの情報にアクセスするにはslot-refを
;;使って下さい。
;;
;;@param stat 

;;;;;
;;@type Function
;;@name sys-stat->mtime
;;@description Deprecated.
;;<sys-stat>オブジェクトの情報にアクセスするにはslot-refを
;;使って下さい。
;;
;;@param stat 

;;;;;
;;@type Function
;;@name sys-stat->atime
;;@description Deprecated.
;;<sys-stat>オブジェクトの情報にアクセスするにはslot-refを
;;使って下さい。
;;
;;@param stat 

;;;;;
;;@type Function
;;@name sys-stat->gid
;;@description Deprecated.
;;<sys-stat>オブジェクトの情報にアクセスするにはslot-refを
;;使って下さい。
;;
;;@param stat 

;;;;;
;;@type Function
;;@name sys-stat->uid
;;@description Deprecated.
;;<sys-stat>オブジェクトの情報にアクセスするにはslot-refを
;;使って下さい。
;;
;;@param stat 

;;;;;
;;@type Function
;;@name sys-stat->size
;;@description Deprecated.
;;<sys-stat>オブジェクトの情報にアクセスするにはslot-refを
;;使って下さい。
;;
;;@param stat 

;;;;;
;;@type Function
;;@name sys-stat->nlink
;;@description Deprecated.
;;<sys-stat>オブジェクトの情報にアクセスするにはslot-refを
;;使って下さい。
;;
;;@param stat 

;;;;;
;;@type Function
;;@name sys-stat->rdev
;;@description Deprecated.
;;<sys-stat>オブジェクトの情報にアクセスするにはslot-refを
;;使って下さい。
;;
;;@param stat 

;;;;;
;;@type Function
;;@name sys-stat->dev
;;@description Deprecated.
;;<sys-stat>オブジェクトの情報にアクセスするにはslot-refを
;;使って下さい。
;;
;;@param stat 

;;;;;
;;@type Function
;;@name sys-stat->ino
;;@description Deprecated.
;;<sys-stat>オブジェクトの情報にアクセスするにはslot-refを
;;使って下さい。
;;
;;@param stat 

;;;;;
;;@type Function
;;@name sys-stat->mode
;;@description Deprecated.
;;<sys-stat>オブジェクトの情報にアクセスするにはslot-refを
;;使って下さい。
;;
;;@param stat 

;;;;;
;;@type Function
;;@name sys-lstat
;;@description sys-statと同じですが、pathがシンボリックリンクであった
;;場合はリンクそのものの情報を返します。
;;
;;@param path 

;;;;;
;;@type Function
;;@name sys-fstat
;;@description [POSIX]
;;与えられたパス名path、またはポートかファイルディスクリプタ
;;port-or-fdで示されるファイルの情報を<sys-stat>オブジェクトで
;;返します。
;;
;;sys-statは、pathがシンボリックリンクであった場合は
;;リンクの指す先のファイルに関する情報を返します。
;;
;;sys-fstatは、port-or-fdがファイルに関係ないポートであった
;;場合は#fを返します。
;;
;;@param port-or-fd 

;;;;;
;;@type Function
;;@name sys-stat
;;@description [POSIX]
;;与えられたパス名path、またはポートかファイルディスクリプタ
;;port-or-fdで示されるファイルの情報を<sys-stat>オブジェクトで
;;返します。
;;
;;sys-statは、pathがシンボリックリンクであった場合は
;;リンクの指す先のファイルに関する情報を返します。
;;
;;sys-fstatは、port-or-fdがファイルに関係ないポートであった
;;場合は#fを返します。
;;
;;@param path 

;;;;;
;;@type Class
;;@name <sys-stat>
;;@description ファイルシステム内のエントリの属性を表す、struct statのラッパー
;;オブジェクトです。以下に示す読みだし専用のスロットを持ちます。
;;
;;ファイルのタイプを示すシンボルです。
;;  socket @tab ソケット        
;;  symlink @tab シンボリックリンク  
;;  fifo @tab FIFO          
;;  block @tab ブロックデバイス     
;;  character @tab キャラクタデバイス
;;  directory @tab ディレクトリ   
;;  regular @tab 通常のファイル    
;;以上のどれにも当てはまらない場合は#fが返されます。
;;
;;注：いくつかのオペレーティングシステムではsocketファイルタイプを
;;fifoと区別せず、どちらに対してもfifoを返します。
;;ポータブルなプログラムを書くときは注意して下さい。
;;
;;パーミッションビットマスク。"mode"スロットの下位9ビットと同じですが、
;;便利なので独立したスロットとして提供されます。
;;
;;struct statの該当するフィールドの値。正確な整数です。
;;
;;struct statの該当するフィールドの値を、Unix Epochからの秒数で。
;;

;;;;;
;;@type Function
;;@name file-is-directory?
;;@description それぞれ、pathが存在するか、存在してそれがレギュラーファイルであるか、
;;存在してそれがディレクトリであれば#tを返します。
;;
;;これらの手続きは便利であり、STkとの互換性もあるので定義されていますが、
;;実体は下に説明されている低レベル手続きの上に作成されています。
;;
;;@param path 

;;;;;
;;@type Function
;;@name file-is-regular?
;;@description それぞれ、pathが存在するか、存在してそれがレギュラーファイルであるか、
;;存在してそれがディレクトリであれば#tを返します。
;;
;;これらの手続きは便利であり、STkとの互換性もあるので定義されていますが、
;;実体は下に説明されている低レベル手続きの上に作成されています。
;;
;;@param path 

;;;;;
;;@type Function
;;@name file-exists?
;;@description それぞれ、pathが存在するか、存在してそれがレギュラーファイルであるか、
;;存在してそれがディレクトリであれば#tを返します。
;;
;;これらの手続きは便利であり、STkとの互換性もあるので定義されていますが、
;;実体は下に説明されている低レベル手続きの上に作成されています。
;;
;;@param path 

;;;;;
;;@type Function
;;@name sys-tmpdir
;;@description 一時ファイルを置くためのデフォルトのディレクトリ名を返します。
;;
;;Unix系システムでは、環境変数TMPDIRとTMPがこの順でチェックされ、
;;フォールバックとして/tmpが返されます。
;;
;;Windowsネイティブの環境では、GetTempPath Windows APIを呼びます。
;;これは環境変数TMP、TEMP、USERPROFILEを順に調べ、
;;いずれも定義されていなければWindowsシステムディレクトリを返します。
;;
;;いずれのプラットフォームでも、返されたパス名は存在しないかもしれず、
;;また書き込み可能ではないかもしれないことに注意してください。
;;
;;一般的に、ユーザプログラムやライブラリはtemporary-directory 
;;(Directory utilities参照) の方を利用するのが良いでしょう。
;;sys-tmpdirはプラットフォームが推奨する生の値を知りたい場合に
;;限り使ってください。
;;

;;;;;
;;@type Function
;;@name sys-realpath
;;@description sys-realpathは``.'', ``..''およびシンボリックリン
;;クを含まないpathnameの絶対パスを返します。pathname自体が存在しなかったり、
;;存在しないパスを指すシンボリックリンクが含まれていたり、関連するパスへのアクセス権限が
;;不足している場合はエラーが通知されます。
;;
;;注：POSIXのrealpath(3)は安全でない場合があるので、
;;Gaucheは内部でCランタイムのrealpathを呼ばずに、
;;独自にsys-realpathの機能を実装しています。
;;
;;@param pathname 

;;;;;
;;@type Function
;;@name sys-dirname
;;@description sys-basenameは与えられたパスのベース名、すなわち最後のコンポーネントを返します。
;;sys-dirnameは与えられたパスのディレクトリ名、すなわち最後のコンポーネント以外の
;;コンポーネントを返します。pathnameの末尾が`/'である場合、その文字は
;;無視されます。
;;example:
;;  (sys-basename "foo/bar/bar.z") ==> "bar.z"
;;  (sys-basename "coo.scm") ==> "coo.scm"
;;  (sys-basename "x/y/") ==> "y"
;;  (sys-dirname "foo/bar/bar.z") ==> "foo/bar"
;;  (sys-dirname "coo.scm") ==> "."
;;  (sys-dirname "x/y/") ==> "x"
;;この手続きはpathnameが存在するかどうかはチェックしません。
;;
;;特殊なケース：
;;example:
;;  (sys-basename "") ==> ""
;;  (sys-dirname "") ==> "."
;;  
;;  (sys-basename "/") ==> ""
;;  (sys-dirname "/") ==> "/"
;;註：このふるまいはPerlのbasenameおよびdirnameと同様です。
;;システムによっては、コマンドのbasenameは"/"に対して"/"を、
;;"."に対して"."を返すものがあります。
;;
;;@param pathname 

;;;;;
;;@type Function
;;@name sys-basename
;;@description sys-basenameは与えられたパスのベース名、すなわち最後のコンポーネントを返します。
;;sys-dirnameは与えられたパスのディレクトリ名、すなわち最後のコンポーネント以外の
;;コンポーネントを返します。pathnameの末尾が`/'である場合、その文字は
;;無視されます。
;;example:
;;  (sys-basename "foo/bar/bar.z") ==> "bar.z"
;;  (sys-basename "coo.scm") ==> "coo.scm"
;;  (sys-basename "x/y/") ==> "y"
;;  (sys-dirname "foo/bar/bar.z") ==> "foo/bar"
;;  (sys-dirname "coo.scm") ==> "."
;;  (sys-dirname "x/y/") ==> "x"
;;この手続きはpathnameが存在するかどうかはチェックしません。
;;
;;特殊なケース：
;;example:
;;  (sys-basename "") ==> ""
;;  (sys-dirname "") ==> "."
;;  
;;  (sys-basename "/") ==> ""
;;  (sys-dirname "/") ==> "/"
;;註：このふるまいはPerlのbasenameおよびdirnameと同様です。
;;システムによっては、コマンドのbasenameは"/"に対して"/"を、
;;"."に対して"."を返すものがあります。
;;
;;@param pathname 

;;;;;
;;@type Function
;;@name sys-normalize-pathname
;;@description 与えられたキーワード引数によってpathnameを以下のように変換します。
;;キーワード引数は同時に複数指定できます。
;;absolute ------
;;    このキーワード引数に真の値が与えられて、pathnameが絶対パスでない場合、
;;    pathnameの前にプロセスのワーキングディレクトリを足して絶対パスにします。
;;expand ------
;;    このキーワード引数に真の値が与えられて、pathnameが`~' で始まっていた
;;    場合、以下のように展開されます。
;;        pathnameが``~''のみであるか、または``~/''で始まっている
;;        場合、文字``~''が現在のプロセスのユーザのホームディレクトリに置き換えられます。
;;        上記以外の場合、`~'以降、`/'かpathnameの終端までの文字列
;;        がユーザ名とみなされ、そのユーザのホームディレクトリに置換されます。もし該当するユーザが
;;        いなければエラーとなります。
;;canonicalize ------
;;    パス名から ``.'' や ``..'' を除き、単純化します。
;;    この操作は実際のファイルシステムを参照せずに行われます。元のパス名がディレクトリへの
;;    シンボリックリンクを含んでいた場合、単純化されたパス名は正しくないかもしれません。
;;
;;@param pathname 
;;@param :key 
;;@param absolute 
;;@param expand 
;;@param canonicalize 

;;;;;
;;@type Function
;;@name sys-umask
;;@description [POSIX] 
;;umaskをmodeにセットします。変更される前のumaskを返します。
;;modeが省略されるか#fが渡された場合、
;;現在のumaskを変更せずにその値を返します。
;;umaskについてはman umaskを参照してください。
;;
;;@param :optional 
;;@param mode 

;;;;;
;;@type Function
;;@name sys-rmdir
;;@description [POSIX]
;;ディレクトリpathnameを消去します。ディレクトリは空でなければなりません。
;;ディレクトリの内容も一緒に消去するには、file.utilのremove-directory*
;;が使えます(Directory utilities)。
;;
;;@param pathname 

;;;;;
;;@type Function
;;@name sys-mkdir
;;@description [POSIX] 
;;ディレクトリpathnameをモードmodeで作成します。
;;(modeはさらにumaskでマスクされることに注意して下さい；下のsys-umask
;;参照)。
;;pathnameの親ディレクトリは存在して、プロセスが書き込めるようになっていなければ
;;なりません。中間のディレクトリも一度に作成するには、
;;file.utilのmake-directory*が使えます
;;(Directory utilities)。
;;
;;@param pathname 
;;@param mode 

;;;;;
;;@type Function
;;@name sys-readlink
;;@description pathで示されるファイルがシンボリックリンクならば、それが指すパスを返します。
;;もしpathが存在しなかったり、シンボリックリンクでなければ、エラーが通知されます。
;;シンボリックリンクをサポートしないシステムでは、この手続きは定義されません。
;;
;;@param path 

;;;;;
;;@type Function
;;@name sys-symlink
;;@description existingを指すnewという名のシンボリックを作成します。
;;シンボリックリンクをサポートしないシステムでは、この手続きは定義されません。
;;
;;@param existing 
;;@param new 

;;;;;
;;@type Function
;;@name sys-unlink
;;@description [POSIX]
;;pathnameで示されるファイルを消去します。
;;pathnameはディレクトリであってはなりません。
;;もし消去に成功したら#tが、pathnameが存在しなければ#fが返されます。
;;他の場合はエラーが通知されます。
;;
;;@param pathname 

;;;;;
;;@type Function
;;@name sys-link
;;@description [POSIX] 
;;既存のファイルexistingに対し、newという名のハードリンクを作成します。
;;
;;@param existing 
;;@param new 

;;;;;
;;@type Function
;;@name sys-mkstemp
;;@description ユニークな名前を持つファイルを作成してオープンし、オープンされたポートとファイル名の
;;二つの値を返します。ファイルは排他的に作成されるため、レースコンディションは起こりません。
;;templateはファイル名のプレフィックスに使われます。Unixのmkstempと違って、
;;パディングキャラクタをつける必要はありません。ファイルは書き込み用としてオープンされ、
;;パーミッションは600にセットされます。
;;
;;@param template 

;;;;;
;;@type Function
;;@name sys-tmpnam
;;@description [POSIX]
;;ユニークなファイル名を作成して返します。この関数はPOSIXに含まれていますが、
;;セキュリティ上の問題が指摘されており、使わない方が良いとされています。
;;可能なら下にあげるsys-mkstempを使って下さい。
;;

;;;;;
;;@type Function
;;@name sys-rename
;;@description [POSIX]
;;ファイルoldをnewにリネームします。新しい名前は
;;古い名前と異なるディレクトリにあってもかまいませんが、両者は同じデバイス上に
;;なければなりません。
;;
;;@param old 
;;@param new 

;;;;;
;;@type Function
;;@name sys-remove
;;@description [POSIX] 
;;filenameがファイルであればそれを消去します。
;;システムによってはfilenameが空のディレクトリであっても動作しますが、
;;移植性を気にする場合はその動作に依存しない方が良いでしょう。
;;
;;@param filename 

;;;;;
;;@type Function
;;@name make-glob-fs-fold
;;@description これはglob-foldやglobのfolderキーワード引数に
;;渡せる形の手続きを作るユーティリティ手続きです。
;;引数を渡さなければ、glob-foldやglobがデフォルトで使うのと
;;同じ手続きが返ります。
;;
;;キーワード引数root-pathおよびcurrent-pathはそれぞれ、
;;glob-foldが探索を開始するディレクトリを指定します。
;;
;;example:
;;  gosh> (glob "/tmp/*.scm")
;;  ("/tmp/x.scm" "/tmp/y.scm")
;;  gosh> (glob "/*.scm" 
;;              :folder (make-glob-fs-fold :root-path "/tmp"))
;;  ("/tmp/x.scm" "/tmp/y.scm")
;;  gosh> (glob "*.scm" 
;;              :folder (make-glob-fs-fold :current-path "/tmp"))
;;  ("/tmp/x.scm" "/tmp/y.scm")
;;
;;@param :key 
;;@param root-path 
;;@param current-path 

;;;;;
;;@type Function
;;@name glob-fold
;;@description これはグロブ関数の低レベル版です。実際globは以下のように書いたの
;;と同じです。
;;example:
;;  (define (glob patterns . opts)
;;    (apply glob-fold patterns cons '() opts))
;;
;;pattern、separatorおよびfolderの意味を前述のものと同
;;じです。
;;
;;patternにパス名ごとにglob-foldはprocをパス名とシー
;;ド値で呼びます。最初のシード値はseedで、procが返す値は次の
;;シード値になります。最後のprocの呼び出し結果はglob-foldの
;;結果となります。マッチするパス名が存在しないときは、procは呼ばれ
;;ずに、seedが返ります。
;;
;;@param pattern 
;;@param proc 
;;@param seed 
;;@param :key 
;;@param separator 
;;@param folder 

;;;;;
;;@type Function
;;@name sys-glob
;;@description 伝統的なUnixのglob(3)の機能を提供します。この手続きはpatternとマッ
;;チするパス名のリストを返します。
;;
;;この機能は、かつてはプラットフォームが提供するglob関数をラップする
;;もので、sys-globという名前でした。しかし、プラットフォーム間の非互
;;換性を解消し機能の追加を容易にするために、Gauche 0.8.12以降、システムコー
;;ルの上にSchemeで再実装されています。そのため、globと改名してあ
;;ります。古い方の名前sys-globは互換性のために残してありますが、
;;新たにプログラムを書くときはglobを使ってください。
;;
;;引数patternは単一のグロブパターンもしくは、グ
;;ロブパターンのリストです。リストが渡されたときには、
;;最低1つのパターンにマッチするパス名がすべて返されます。
;;Unixのユーザならglobの動作は馴染み深いものでしょう。
;;
;;example:
;;  gosh> (glob "*.scm")
;;  ("test.scm" "ext.scm")
;;  gosh> (glob "src/*.[ch]")
;;  ("src/ext.c" "src/ext.h")
;;  gosh> (glob '("*.scm" "src/*.c"))
;;  ("src/ext.c" "test.scm" "ext.scm")
;;
;;シェルのグロブとはちがって、マッチするパス名がないときは、()が返ります。
;;
;;グロブはファイルシステムに限らず階層的なデータ構造を検索するのに非常に便利なツールです。
;;したがって、glob関数はファイルシステムからは切り離して実装されています。
;;キーワード引数を使うことで、どのようなツリー状のデータ構造からでもグロブできます。
;;デフォルト値がファイルシステム用に設定されているにすぎません。
;;
;;引数separatorは文字の集合を与えます。これを使ってpatternを
;;コンポーネントに分割します。デフォルトは#[/]です。実際のパス名
;;をマッチさせるのには使われません。
;;
;;folderはデータ構造をトラバースするための手続きです。この手続きは
;;引数を5つとります。
;;
;;example:
;;  (folder proc seed parent regexp non-leaf?)
;;
;;procは引数を2つ取る手続きです。folderは、parent内で
;;コンポーネントとなる名前がregexpとマッチする各ノードと、
;;foldと同様に順に渡されるシード値とで、procを呼びます。
;;folderはprocが最後に返した値を返します。たとえば、
;;consがprocとして、()がseedとして渡されれば、
;;folder手続きが返す値はregexpとマッチするノードのリストになります。
;;
;;ノードの表現がどうなるかはfolderの実装によります。
;;パス名であったり、オブジェクトであったりするかもしれません。
;;glob手続きはノードの表現については感知しません。
;;glob手続きがやることはノードを次に呼ぶ
;;folderにparent引数として渡して、
;;その結果のノードリストを返すだけです。
;;
;;parent引数は基本的にはノードで、folderはその子ノードを
;;対象にマッチするものを探索します。
;;例外は最初にfolderが呼ばれる時です。その時点ではglobは
;;ノードについて何も知らないので、
;;絶対パスでマッチをかける場合は#tを、
;;相対パスでマッチをかける場合は#fを最初のparentの値として渡します。
;;
;;regexp引数は子ノードをフィルターするのに使い、ディレクトリ名を含
;;まない、子のコンポーネントである名前に対して照合されるものです。特別な
;;場合として、シンボルdirにすることができます。この場合は、folder
;;はnodeそのものを返し、nodeはディレクトリと見なされ
;;ます。すなわち、nodeがパス名を表わす場合には、folderはディレクト
;;リ区切り子が最後に付いたパス名を返します。
;;特別な場合として、nodeがブール値でかつ
;;regexpがdirである場合、folderはルートノードをあらわすノー
;;ドあるいはカレントノードを返すことになっています。すなわち、node
;;はパス名を表す場合、folderは"/"または"./"を返します。
;;
;;non-leaf引数はブール値フラッグです。真なら、フィルタは結果からリー
;;フノードをのぞきます(すなわち、ディレクトリだけが含まれるようになり
;;ます)。
;;
;;ここからはグロブパターンマッチングの細かい仕様をみていきます。
;;
;;各グロブパターンはパス名様式文字列にマッチする文字列です。
;;
;;パス名様式文字列は1つ以上のセパレータで区切られた
;;コンポーネントから構成される文字列です。
;;デフォルトのセパレータは#[/]です。キーワード引数separator
;;を使うとこれを変更できます。コンポーネントにはセパレータを含められませ
;;ん。また空文字列にすることもできません。連続したセパレータは単一のセパ
;;レータとみなされます。パス名様式の文字列は状況に応じてセパレータから始
;;めたり、セパレータで終端したりできます(両方をやるのも可)。
;;
;;グロブパターンもコンポーネントとセパレータ文字から構成されます。コンポー
;;ネントにおいては、以下の文字、構文は特別な意味を持ちます。
;;
;;* ------
;;  これがコンポーネントの先頭に表われた場合、0個以上のピリオド(.)
;;  を除く文字にマッチします。入力文字列のコンポーネントがピリオドではじま
;;  るような文字列の場合にはマッチしません。
;;  
;;  先頭以外の場所では、0個以上の文字の列にマッチします。
;;  
;;** ------
;;  コンポーネントが**だけの場合、これは*にマッチする0個以上の
;;  コンポーネントにマッチします。例えばsrc/**/*.hは
;;  次のようなパターン全てにマッチします。
;;  example:
;;    src/*.h
;;    src/*/*.h
;;    src/*/*/*.h
;;    src/*/*/*/*.h
;;    ...
;;  
;;? ------
;;  コンポーネントの先頭にあらわれた場合、ピリオド(.)以外の一文字に
;;  マッチします。先頭以外の場所では任意の一文字にマッチします。
;;  
;;[@i{chars}] ------
;;  文字の集合を指定します。その集合に含まれる文字のどれかにマッチします。
;;  @i{chars}の構文はGaucheの文字集合を表す構文と同じです
;;  (Character set参照)。伝統的なグロブとの互換性のために、!
;;  文字をつかって、補集合で文字集合を表わすこともできるようになっています。
;;  すなわち、[!abc]は[^abc]と同じです。
;;
;;@param pattern 
;;@param :key 
;;@param separator 
;;@param folder 

;;;;;
;;@type Function
;;@name glob
;;@description 伝統的なUnixのglob(3)の機能を提供します。この手続きはpatternとマッ
;;チするパス名のリストを返します。
;;
;;この機能は、かつてはプラットフォームが提供するglob関数をラップする
;;もので、sys-globという名前でした。しかし、プラットフォーム間の非互
;;換性を解消し機能の追加を容易にするために、Gauche 0.8.12以降、システムコー
;;ルの上にSchemeで再実装されています。そのため、globと改名してあ
;;ります。古い方の名前sys-globは互換性のために残してありますが、
;;新たにプログラムを書くときはglobを使ってください。
;;
;;引数patternは単一のグロブパターンもしくは、グ
;;ロブパターンのリストです。リストが渡されたときには、
;;最低1つのパターンにマッチするパス名がすべて返されます。
;;Unixのユーザならglobの動作は馴染み深いものでしょう。
;;
;;example:
;;  gosh> (glob "*.scm")
;;  ("test.scm" "ext.scm")
;;  gosh> (glob "src/*.[ch]")
;;  ("src/ext.c" "src/ext.h")
;;  gosh> (glob '("*.scm" "src/*.c"))
;;  ("src/ext.c" "test.scm" "ext.scm")
;;
;;シェルのグロブとはちがって、マッチするパス名がないときは、()が返ります。
;;
;;グロブはファイルシステムに限らず階層的なデータ構造を検索するのに非常に便利なツールです。
;;したがって、glob関数はファイルシステムからは切り離して実装されています。
;;キーワード引数を使うことで、どのようなツリー状のデータ構造からでもグロブできます。
;;デフォルト値がファイルシステム用に設定されているにすぎません。
;;
;;引数separatorは文字の集合を与えます。これを使ってpatternを
;;コンポーネントに分割します。デフォルトは#[/]です。実際のパス名
;;をマッチさせるのには使われません。
;;
;;folderはデータ構造をトラバースするための手続きです。この手続きは
;;引数を5つとります。
;;
;;example:
;;  (folder proc seed parent regexp non-leaf?)
;;
;;procは引数を2つ取る手続きです。folderは、parent内で
;;コンポーネントとなる名前がregexpとマッチする各ノードと、
;;foldと同様に順に渡されるシード値とで、procを呼びます。
;;folderはprocが最後に返した値を返します。たとえば、
;;consがprocとして、()がseedとして渡されれば、
;;folder手続きが返す値はregexpとマッチするノードのリストになります。
;;
;;ノードの表現がどうなるかはfolderの実装によります。
;;パス名であったり、オブジェクトであったりするかもしれません。
;;glob手続きはノードの表現については感知しません。
;;glob手続きがやることはノードを次に呼ぶ
;;folderにparent引数として渡して、
;;その結果のノードリストを返すだけです。
;;
;;parent引数は基本的にはノードで、folderはその子ノードを
;;対象にマッチするものを探索します。
;;例外は最初にfolderが呼ばれる時です。その時点ではglobは
;;ノードについて何も知らないので、
;;絶対パスでマッチをかける場合は#tを、
;;相対パスでマッチをかける場合は#fを最初のparentの値として渡します。
;;
;;regexp引数は子ノードをフィルターするのに使い、ディレクトリ名を含
;;まない、子のコンポーネントである名前に対して照合されるものです。特別な
;;場合として、シンボルdirにすることができます。この場合は、folder
;;はnodeそのものを返し、nodeはディレクトリと見なされ
;;ます。すなわち、nodeがパス名を表わす場合には、folderはディレクト
;;リ区切り子が最後に付いたパス名を返します。
;;特別な場合として、nodeがブール値でかつ
;;regexpがdirである場合、folderはルートノードをあらわすノー
;;ドあるいはカレントノードを返すことになっています。すなわち、node
;;はパス名を表す場合、folderは"/"または"./"を返します。
;;
;;non-leaf引数はブール値フラッグです。真なら、フィルタは結果からリー
;;フノードをのぞきます(すなわち、ディレクトリだけが含まれるようになり
;;ます)。
;;
;;ここからはグロブパターンマッチングの細かい仕様をみていきます。
;;
;;各グロブパターンはパス名様式文字列にマッチする文字列です。
;;
;;パス名様式文字列は1つ以上のセパレータで区切られた
;;コンポーネントから構成される文字列です。
;;デフォルトのセパレータは#[/]です。キーワード引数separator
;;を使うとこれを変更できます。コンポーネントにはセパレータを含められませ
;;ん。また空文字列にすることもできません。連続したセパレータは単一のセパ
;;レータとみなされます。パス名様式の文字列は状況に応じてセパレータから始
;;めたり、セパレータで終端したりできます(両方をやるのも可)。
;;
;;グロブパターンもコンポーネントとセパレータ文字から構成されます。コンポー
;;ネントにおいては、以下の文字、構文は特別な意味を持ちます。
;;
;;* ------
;;  これがコンポーネントの先頭に表われた場合、0個以上のピリオド(.)
;;  を除く文字にマッチします。入力文字列のコンポーネントがピリオドではじま
;;  るような文字列の場合にはマッチしません。
;;  
;;  先頭以外の場所では、0個以上の文字の列にマッチします。
;;  
;;** ------
;;  コンポーネントが**だけの場合、これは*にマッチする0個以上の
;;  コンポーネントにマッチします。例えばsrc/**/*.hは
;;  次のようなパターン全てにマッチします。
;;  example:
;;    src/*.h
;;    src/*/*.h
;;    src/*/*/*.h
;;    src/*/*/*/*.h
;;    ...
;;  
;;? ------
;;  コンポーネントの先頭にあらわれた場合、ピリオド(.)以外の一文字に
;;  マッチします。先頭以外の場所では任意の一文字にマッチします。
;;  
;;[@i{chars}] ------
;;  文字の集合を指定します。その集合に含まれる文字のどれかにマッチします。
;;  @i{chars}の構文はGaucheの文字集合を表す構文と同じです
;;  (Character set参照)。伝統的なグロブとの互換性のために、!
;;  文字をつかって、補集合で文字集合を表わすこともできるようになっています。
;;  すなわち、[!abc]は[^abc]と同じです。
;;
;;@param pattern 
;;@param :key 
;;@param separator 
;;@param folder 

;;;;;
;;@type Function
;;@name sys-readdir
;;@description pathは存在するディレクトリを示すパス名でなければなりません。
;;この手続きはディレクトリの全エントリを文字列のリストとして返します。
;;リストはソートされません。pathが存在しなかったり、ディレクトリでなかった場合は
;;エラーとなります。
;;
;;@param path 

;;;;;
;;@type Function
;;@name gauche-site-architecture-directory
;;@description これらの手続きはGaucheインタプリタの情報を文字列で返します。
;;

;;;;;
;;@type Function
;;@name gauche-site-library-directory
;;@description これらの手続きはGaucheインタプリタの情報を文字列で返します。
;;

;;;;;
;;@type Function
;;@name gauche-architecture-directory
;;@description これらの手続きはGaucheインタプリタの情報を文字列で返します。
;;

;;;;;
;;@type Function
;;@name gauche-library-directory
;;@description これらの手続きはGaucheインタプリタの情報を文字列で返します。
;;

;;;;;
;;@type Function
;;@name gauche-architecture
;;@description これらの手続きはGaucheインタプリタの情報を文字列で返します。
;;

;;;;;
;;@type Function
;;@name gauche-version
;;@description これらの手続きはGaucheインタプリタの情報を文字列で返します。
;;

;;;;;
;;@type Function
;;@name sys-clearenv
;;@description Remove the environment variable with name (sys-unsetenv),
;;or all enviornment variables.  sys-clearenv is handy
;;when you need to run subprocess, but you cannot trust the inherited
;;environment.
;;
;;These procedures are only available when a feature identifier
;;gauche.sys.unsetenv exists.  Use cond-expand
;;(@xref{Feature conditional}) to check their availability.
;;
;;example:
;;  (cond-expand
;;   [gauche.sys.unsetenv 
;;     ... use sys-unsetenv or sys-clearenv ... ]
;;   [else
;;     ... fallback code ...])
;;

;;;;;
;;@type Function
;;@name sys-unsetenv
;;@description Remove the environment variable with name (sys-unsetenv),
;;or all enviornment variables.  sys-clearenv is handy
;;when you need to run subprocess, but you cannot trust the inherited
;;environment.
;;
;;These procedures are only available when a feature identifier
;;gauche.sys.unsetenv exists.  Use cond-expand
;;(@xref{Feature conditional}) to check their availability.
;;
;;example:
;;  (cond-expand
;;   [gauche.sys.unsetenv 
;;     ... use sys-unsetenv or sys-clearenv ... ]
;;   [else
;;     ... fallback code ...])
;;
;;@param name 

;;;;;
;;@type Function
;;@name sys-putenv
;;@description sys-setenv inserts an environment variable name with
;;the value value.
;;Both name and value must be a string.
;;If the optional argument overwrite is #f (default),
;;the enviornment is untouched if a variable with name already
;;exists.   If overwrite is #t, the variable is overwritten.
;;
;;Fir sys-putenv, you have to give a single string
;;with the form of NAME=VALUE, that is, concatenating name
;;and value with #\=.  If the enviornmet variable with
;;the same name exists, it will be overwritten.
;;
;;These API reflects POSIX setenv(3) and putenv(3).
;;However, unlike putenv(3), modifying the string passed
;;to sys-putenv afterwards won't affect the environment.
;;
;;These procedures are only available when a feature identifier
;;gauche.sys.setenv exists.  Use cond-expand
;;(@xref{Feature conditional}) to check their availability.
;;
;;example:
;;  (cond-expand
;;   [gauche.sys.setenv 
;;     ... use sys-setenv or sys-putenv ... ]
;;   [else
;;     ... fallback code ...])
;;
;;@param name=value 

;;;;;
;;@type Function
;;@name sys-setenv
;;@description sys-setenv inserts an environment variable name with
;;the value value.
;;Both name and value must be a string.
;;If the optional argument overwrite is #f (default),
;;the enviornment is untouched if a variable with name already
;;exists.   If overwrite is #t, the variable is overwritten.
;;
;;Fir sys-putenv, you have to give a single string
;;with the form of NAME=VALUE, that is, concatenating name
;;and value with #\=.  If the enviornmet variable with
;;the same name exists, it will be overwritten.
;;
;;These API reflects POSIX setenv(3) and putenv(3).
;;However, unlike putenv(3), modifying the string passed
;;to sys-putenv afterwards won't affect the environment.
;;
;;These procedures are only available when a feature identifier
;;gauche.sys.setenv exists.  Use cond-expand
;;(@xref{Feature conditional}) to check their availability.
;;
;;example:
;;  (cond-expand
;;   [gauche.sys.setenv 
;;     ... use sys-setenv or sys-putenv ... ]
;;   [else
;;     ... fallback code ...])
;;
;;@param name 
;;@param value 
;;@param &optional 
;;@param overwrite 

;;;;;
;;@type Function
;;@name sys-environ->alist
;;@description sys-environの便利版。環境リスト(sys-environが返すような
;;形式のもの)をenvlistとして与えると、この手続きは各環境変数を名前
;;と値に分けて連想リストにして返します。
;;
;;envlistを省略すると、この手続きはsys-environを呼んで現在
;;の環境変数を取得します。
;;
;;example:
;;  (sys-environ->alist '("A=B" "C=D=E"))
;;    => (("A" . "B") ("C" . "D=E"))
;;
;;@param :optional 
;;@param envlist 

;;;;;
;;@type Function
;;@name sys-environ
;;@description 現在の環境を文字列のリストとして返します。それぞれの文字列は
;;NAME=VALUEというフォーマットになっています。ここでNAMEは
;;環境変数名、VALUEはその値です。NAMEが文字#\=を含
;;むことはありません。この手続きは現在のプロセスの環境変数をすべて取得し
;;たい場合に便利です。特定の環境変数の値が欲しい場合には
;;sys-getenvを使ってください。
;;

;;;;;
;;@type Function
;;@name sys-getenv
;;@description [POSIX]
;;環境変数nameの値を文字列で返します。もしnameが定義されていなければ、
;;#fが返ります。
;;
;;@param name 

;;;;;
;;@type Function
;;@name sys-abort
;;@description [POSIX]
;;POSIXのabort()を呼びます。通常、現在のプロセスは終了され、コアダンプされます。
;;クリーンアップは一切行われません。
;;

;;;;;
;;@type Function
;;@name sys-exit
;;@description [POSIX]
;;現在のプロセスを終了し、codeを終了コードにします。
;;codeはゼロもしくは正の正確な整数でなければなりません。
;;この手続きは_exit(2)を直接コールします。
;;クリーンアップは一切行われません。
;;フラッシュされてないファイルバッファの内容は捨てられます。
;;
;;@param code 

;;;;;
;;@type Function
;;@name exit-handler
;;@description 引数なしで呼ばれた場合、現在のexit handlerの値を返します。
;;引数つきで呼ばれた場合は、new-handlerを現在のexit handlerの
;;値とし、以前の値を返します。new-handlerは3つの引数をとる
;;手続きか、#fでなければなりません。
;;
;;exit handlerの値はスレッドごとに固有で、デフォルト値はスレッドが作られた時点の
;;親スレッドのexit handlerの値から引き継がれます。
;;exit-handlerはあたかもパラメータのようにparameterizeマクロで
;;使うことができます (Parameters参照)。
;;
;;@param :optional 
;;@param new-handler 

;;;;;
;;@type Function
;;@name exit
;;@description [POSIX]
;;現在のプロセスを終了し、codeを終了コードにします。
;;codeはゼロもしくは正の正確な整数でなければなりません。
;;fmtstr文字列が与えられた場合、それは残りの引数argsと
;;ともにformatに渡され、standard error portにメッセージとして
;;印字されます (current-error-portではありません。
;;Common port operations参照。また、formatについては
;;Output参照。)
;;
;;実のところ、プロセス終了の手続きはもう少し複雑です。
;;正確な段階を次に説明します。
;;
;;パラメータexit-handlerの値がチェックされます。
;;もしそれが#fでなければ、それは3引数の手続きとみなされ、
;;code、fmtstr、そして残りの引数のリストを引数として
;;呼び出されます。実はメッセージを標準エラー出力に出しているのは
;;デフォルトのexit-handlerです。
;;終了ハンドラの中でエラーが起きた場合、そのエラーは捕捉され捨てられます。
;;エラー以外の例外は捕捉されません。
;;
;;アクティブなdynamic-windのafterサンクが順に呼び出されます。
;;afterサンク中で発生した例外は捕捉され捨てられます。
;;
;;C APIのScm_AddCleanupHandlerで登録されたクリーンアップハンドラが
;;呼ばれます。このハンドラは通常、Gaucheを内蔵しているアプリケーション特有の
;;クリーンアップをするために使われます。Schemeの世界からはあまり気にする必要は
;;ないでしょう。
;;
;;まだ閉じられていない出力ポートのバッファが掃き出されます。
;;
;;exit(3)を呼び、プロセスはcodeを終了コードとして終了します。
;;
;;exit-handlerのメカニズムはアプリケーションが終了処理をフックすることを
;;可能にします。ただし、単純なクリーンアップ処理のためのものではありません
;;(クリーンアップ処理には
;;dynamic-wind, guardあるいはunwind-protectを使う方が
;;適切です。)
;;exit-handlerはもっと「アプリケーションの終了」という特定の事態に
;;対して何か処理を行いたい場合に使います。
;;例えばGUIアプリケーションはメッセージを標準エラー出力ではなく
;;ダイアログとして表示する、というようなことです。
;;
;;従って、ライブラリコードはexit-handlerに触るべきではありません。
;;アプリケーションの終了時に何をすべきかを知っているのはアプリケーション自身なのですから。
;;
;;別の使いどころとしては、サードパーティ製のコードで中でexitが
;;呼ばれる可能性のあるものを安全に呼び出したいという場合があります。
;;そのコードを呼び出している間だけ、exit-handlerを
;;エラーではない例外を発生させる手続きへと差し替えます。
;;エラーではない例外はexitでは捕捉されないので、実質的に
;;上で説明したような終了処理のステップは中断されることになります
;;(但し、ダイナミックハンドラのafterサンクは通常の例外発生時と
;;同じように処理されます)。
;;アプリケーションコードの方でその例外を捕捉してやればよいのです。
;;parameterizeを使えばexit-handlerを動的に、
;;かつスレッドセーフに差し替えることが容易になります
;;(Parameters参照)。
;;
;;example:
;;  (guard (e [(eq? e 'exit-called) (handle-exit-as-desired)])
;;    (parameterize ((exit-handler (lambda (c f a) (raise 'exit-called))))
;;      (call-third-party-library)))
;;
;;一般的に、他のスレッドが走っている時にexitを呼ぶことは推奨されません。
;;exit手続きは該当スレッド上でアクティブなダイナミックハンドラしか巻き
;;戻さないので、他のスレッドはいきなり終了させられてしまいます。
;;しかしexitを呼ばざるを得ない場合には、
;;exit-handlerを使って他のスレッドにアプリケーションが終了しつつあることを
;;伝えられるかもしれません (但しGauche自身は走っているスレッドのリストといった
;;情報は持っていないので、アプリケーションごとに固有のロジックを実装する必要が
;;あります。)
;;
;;設計に関する覚書: 終了を一種の例外とすることで、
;;終了処理を例外処理と統合している言語もあります。
;;良いアイディアに思えたので我々もそのような実装を試してみましたが、
;;Gaucheではうまくいきませんでした。大きな理由のひとつは、
;;dynamic-windの巻き戻し中にafterで例外が
;;発生すると、その例外がもともとの「終了」例外を隠してしまうことでした。
;;
;;@param :optional 
;;@param (code 0) (fmtstr #f) args ... 

;;;;;
;;@type Function
;;@name stable-sort-by!
;;@description keyをシーケンスseqの各要素に適用して得られる値の比較をもとに
;;seqをソートします。(stable-sort-by seq key cmp)は次のコードと
;;同じ結果を返します:
;;
;;example:
;;  (stable-sort seq (lambda (a b) (cmp (key a) (key b))))
;;
;;よりコンパクトに書けるという以外に、
;;sort-by族の手続きはkey手続きをたかだかseqの要素数
;;しか呼び出さないという性質があります。上記のstable-sortを
;;使った例では、keyはseqの要素数をnとする時
;;nlogn 回以上呼び出される可能性があります。
;;したがって、sort-by族はkey手続きが比較的高価な場合に
;;威力を発揮します。
;;
;;トレードオフは空間です。sort-by族はあらかじめ比較対象となる
;;値を計算しておくために、seqの要素数に比例した余分なメモリを
;;必要とします。
;;
;;@param seq 
;;@param key 
;;@param :optional 
;;@param cmpfn 

;;;;;
;;@type Function
;;@name stable-sort-by
;;@description keyをシーケンスseqの各要素に適用して得られる値の比較をもとに
;;seqをソートします。(stable-sort-by seq key cmp)は次のコードと
;;同じ結果を返します:
;;
;;example:
;;  (stable-sort seq (lambda (a b) (cmp (key a) (key b))))
;;
;;よりコンパクトに書けるという以外に、
;;sort-by族の手続きはkey手続きをたかだかseqの要素数
;;しか呼び出さないという性質があります。上記のstable-sortを
;;使った例では、keyはseqの要素数をnとする時
;;nlogn 回以上呼び出される可能性があります。
;;したがって、sort-by族はkey手続きが比較的高価な場合に
;;威力を発揮します。
;;
;;トレードオフは空間です。sort-by族はあらかじめ比較対象となる
;;値を計算しておくために、seqの要素数に比例した余分なメモリを
;;必要とします。
;;
;;@param seq 
;;@param key 
;;@param :optional 
;;@param cmpfn 

;;;;;
;;@type Function
;;@name sort-by!
;;@description keyをシーケンスseqの各要素に適用して得られる値の比較をもとに
;;seqをソートします。(stable-sort-by seq key cmp)は次のコードと
;;同じ結果を返します:
;;
;;example:
;;  (stable-sort seq (lambda (a b) (cmp (key a) (key b))))
;;
;;よりコンパクトに書けるという以外に、
;;sort-by族の手続きはkey手続きをたかだかseqの要素数
;;しか呼び出さないという性質があります。上記のstable-sortを
;;使った例では、keyはseqの要素数をnとする時
;;nlogn 回以上呼び出される可能性があります。
;;したがって、sort-by族はkey手続きが比較的高価な場合に
;;威力を発揮します。
;;
;;トレードオフは空間です。sort-by族はあらかじめ比較対象となる
;;値を計算しておくために、seqの要素数に比例した余分なメモリを
;;必要とします。
;;
;;@param seq 
;;@param key 
;;@param :optional 
;;@param cmpfn 

;;;;;
;;@type Function
;;@name sort-by
;;@description keyをシーケンスseqの各要素に適用して得られる値の比較をもとに
;;seqをソートします。(stable-sort-by seq key cmp)は次のコードと
;;同じ結果を返します:
;;
;;example:
;;  (stable-sort seq (lambda (a b) (cmp (key a) (key b))))
;;
;;よりコンパクトに書けるという以外に、
;;sort-by族の手続きはkey手続きをたかだかseqの要素数
;;しか呼び出さないという性質があります。上記のstable-sortを
;;使った例では、keyはseqの要素数をnとする時
;;nlogn 回以上呼び出される可能性があります。
;;したがって、sort-by族はkey手続きが比較的高価な場合に
;;威力を発揮します。
;;
;;トレードオフは空間です。sort-by族はあらかじめ比較対象となる
;;値を計算しておくために、seqの要素数に比例した余分なメモリを
;;必要とします。
;;
;;@param seq 
;;@param key 
;;@param :optional 
;;@param cmpfn 

;;;;;
;;@type Function
;;@name stable-sort!
;;@description 安定ソートアルゴリズム(現時点ではマージソート)を使って、並び seq
;;(リストまたはベクタ)をソートします。ソート順は cmpfn で指定します。
;;cmpfn は list のふたつの要素を引数として取る関数で、
;;厳密に、最初の引数が第二の引数の前にくるものである場合に #t
;;を返します。
;;
;;@param seq 
;;@param :optional 
;;@param cmpfn 

;;;;;
;;@type Function
;;@name stable-sort
;;@description 安定ソートアルゴリズム(現時点ではマージソート)を使って、並び seq
;;(リストまたはベクタ)をソートします。ソート順は cmpfn で指定します。
;;cmpfn は list のふたつの要素を引数として取る関数で、
;;厳密に、最初の引数が第二の引数の前にくるものである場合に #t
;;を返します。
;;
;;@param seq 
;;@param :optional 
;;@param cmpfn 

;;;;;
;;@type Function
;;@name sort!
;;@description シーケンスseq(リストかベクタ)の要素を昇順にソートし、
;;ソートされたシーケンスを返します。
;;sort!は、オリジナルのシーケンスを破壊的に再利用します。
;;ソート順はcmpfnで指定されます。cmpfnはseqのふたつの要素を
;;引数に取り、最初の要素が厳密に2番目の要素より先行するものの場合は
;;#tを返す手続きです。
;;
;;sort!の後でseqが必ずしもソート済みのシーケンスを
;;指すとは限らないことに注意してください。
;;seqがリストの場合、オリジナルのリストの最初のペアが
;;ソート済みリストでも最初に来るとは限りません。
;;常にsort!の戻り値を使うようにしてください。
;;
;;example:
;;  (sort '(("Chopin" "Frederic") 
;;          ("Liszt" "Franz")
;;          ("Alkan" "Charles-Valentin"))
;;        (lambda (x y) (string<? (car x) (car y))))
;;    ==> (("Alkan" "Charles-Valentin")
;;        ("Chopin" "Frederic")
;;        ("Liszt" "Franz"))
;;
;;cmpfnが省略された場合はcompare手続きが
;;どちらの要素がより「小さい」かを判定するのに使われます。
;;
;;現在の実装では、cmpfnが省略された場合は
;;クィックソートとヒープソートを使い、
;;cmpfnが与えられた場合はマージソートを使っています。
;;これは将来変更されるかもしれません。
;;
;;なお、オブジェクトをひとつづつ集合に追加しつつ、常にソートされた
;;状態に保ちたい場合は、treemapの使用を考えても良いでしょう (Treemaps参照)。
;;
;;@param seq 
;;@param :optional 
;;@param cmpfn 

;;;;;
;;@type Function
;;@name sort
;;@description シーケンスseq(リストかベクタ)の要素を昇順にソートし、
;;ソートされたシーケンスを返します。
;;sort!は、オリジナルのシーケンスを破壊的に再利用します。
;;ソート順はcmpfnで指定されます。cmpfnはseqのふたつの要素を
;;引数に取り、最初の要素が厳密に2番目の要素より先行するものの場合は
;;#tを返す手続きです。
;;
;;sort!の後でseqが必ずしもソート済みのシーケンスを
;;指すとは限らないことに注意してください。
;;seqがリストの場合、オリジナルのリストの最初のペアが
;;ソート済みリストでも最初に来るとは限りません。
;;常にsort!の戻り値を使うようにしてください。
;;
;;example:
;;  (sort '(("Chopin" "Frederic") 
;;          ("Liszt" "Franz")
;;          ("Alkan" "Charles-Valentin"))
;;        (lambda (x y) (string<? (car x) (car y))))
;;    ==> (("Alkan" "Charles-Valentin")
;;        ("Chopin" "Frederic")
;;        ("Liszt" "Franz"))
;;
;;cmpfnが省略された場合はcompare手続きが
;;どちらの要素がより「小さい」かを判定するのに使われます。
;;
;;現在の実装では、cmpfnが省略された場合は
;;クィックソートとヒープソートを使い、
;;cmpfnが与えられた場合はマージソートを使っています。
;;これは将来変更されるかもしれません。
;;
;;なお、オブジェクトをひとつづつ集合に追加しつつ、常にソートされた
;;状態に保ちたい場合は、treemapの使用を考えても良いでしょう (Treemaps参照)。
;;
;;@param seq 
;;@param :optional 
;;@param cmpfn 

;;;;;
;;@type Method
;;@name object-compare
;;@description このジェネリックファンクションを特殊化することで
;;compare手続きをユーザ定義クラスに対して動作するように拡張できます。
;;
;;@param obj1 
;;@param obj2 

;;;;;
;;@type Function
;;@name compare
;;@description 一般的な比較手続きです。obj1がobj2より小さければ-1を、
;;等しければ0を、大きければ1を返します。obj1とobj2が
;;比較できない場合はエラーとなります。
;;
;;いくつかの組み込み型は「自然な」比較順を用いて比較されます。
;;他の組み込み型は通常比較不可能です。Schemeで定義されたクラスについては、
;;この手続きはジェネリックファンクションobject-compareを
;;呼び出します。
;;
;;@param obj1 
;;@param obj2 

;;;;;
;;@type Function
;;@name library-has-module?
;;@description path で指定したファイルが存在し、かつ、module で名指しされた
;;モジュールが実装されている場合でその場合に限り、#t を返します。
;;path は実際のファイル名でなければなりません。
;;
;;example:
;;  (library-has-module? "./test/foo/bar.scm" 'foo.bar)
;;   ==> #t ;; @r{if ./test/foo/bar.scm implements module foo.bar}.
;;
;;この手続きは典型的なソースコードの配置を仮定して、与えられたファイルが
;;そのモジュールを実装しているかどうかを決定します。すなわち、
;;まずそのコードのフォームを読み、与えられたモジュールを定義している
;;define-module フォームかどうかを見ます。
;;
;;@param path 
;;@param module 

;;;;;
;;@type Function
;;@name library-exists?
;;@description mod/path で指定されたライブラリあるいはモジュールを検索し、
;;もしあれば、真値を返します。キーワード引数 paths および 
;;strict? は library-fold のそれと同じ意味です。
;;
;;上述のイテレータ手続きとはちがい、この手続きは呼び出しの過程で
;;最初に既にロードされているライブラリおよびモジュールをチェックします。
;;もしそのときに mod/path を見つけたら、真値を返し、ファイル
;;システムを見にいくことはありません。キーワード引数 force-search?
;;に #t を渡せば、すでにロードされいるライブラリおよびモジュール
;;のチェックはスキップされます。
;;
;;@param mod/path 
;;@param :key 
;;@param paths 
;;@param force-search? 
;;@param strict? 

;;;;;
;;@type Function
;;@name library-for-each
;;@description マッチしたライブラリ/モジュール上のイテレータの map版および
;;for-each版。照合操作とキーワード引数の詳細については上述の
;;library-foldを参照してください。
;;
;;procは、マッチしたモジュール/ファイル名と、そのファイルの
;;フルパスの 2 つの引数をうけとります。library-for-each は
;;結果を捨てます。
;;
;;example:
;;  (library-map 'srfi-4 list :allow-duplicates? #t)
;;   ==> ((srfi-4 "../lib/srfi-4.scm")
;;              (srfi-4 "/usr/share/gauche/0.7.1/lib/srfi-4.scm"))
;;  
;;  (library-map 'dbm.* (lambda (m p) m))
;;   ==> (dbm.odbm dbm.ndbm dbm.gdbm dbm.cdb)
;;
;;@param pattern 
;;@param proc 
;;@param :key 
;;@param paths 
;;@param allow-duplicates? 
;;@param strict? 

;;;;;
;;@type Function
;;@name library-map
;;@description マッチしたライブラリ/モジュール上のイテレータの map版および
;;for-each版。照合操作とキーワード引数の詳細については上述の
;;library-foldを参照してください。
;;
;;procは、マッチしたモジュール/ファイル名と、そのファイルの
;;フルパスの 2 つの引数をうけとります。library-for-each は
;;結果を捨てます。
;;
;;example:
;;  (library-map 'srfi-4 list :allow-duplicates? #t)
;;   ==> ((srfi-4 "../lib/srfi-4.scm")
;;              (srfi-4 "/usr/share/gauche/0.7.1/lib/srfi-4.scm"))
;;  
;;  (library-map 'dbm.* (lambda (m p) m))
;;   ==> (dbm.odbm dbm.ndbm dbm.gdbm dbm.cdb)
;;
;;@param pattern 
;;@param proc 
;;@param :key 
;;@param paths 
;;@param allow-duplicates? 
;;@param strict? 

;;;;;
;;@type Function
;;@name library-fold
;;@description ライブラリ/モジュールファイルに対する基本イテレータ。この手続きは
;;pattern にマッチする Scheme のプログラムファイルを検索します。
;;検索は paths (デフォルトは標準のファイルロードパス、
;;*load-path*)にリストされたディレクトリ以下でおこなわれます。
;;マッチしたファイル毎に、proc が、そのマッチしたモジュール名あるいは
;;ライブラリ名、そのプログラムファイルのフルパス、状態値、の3つの引数を
;;ともなって呼びだされます。seedは、初期状態値として使われ、
;;proc が返す値は次の proc の呼出し時に状態値として使われます。
;;最後の proc から返された値は library-fold の値として返ります。
;;
;;
;;pattern がシンボルでかつ、キーワード引数 strict? が
;;#t (デフォルト値)であれば、この手続きは
;;あたえられたモジュール名のパターンにマッチするようにみえるファイル名に
;;たいして library-has-module? を適用して、
;;本当にそのモジュールを実装しているファイルを見付けます。
;;大量のモジュールにマッチさせようとすると、時間がかる可能性があります。
;;#f を strict? に渡すことで、余分なチェックを回避できます。
;;pattern が文字列だった場合、照合はファイル名に対してのみ行われ、
;;strict?は無視されます。
;;
;;デフォルトでは、path 中の pattern にマッチする同じ名前をもつ
;;2つ以上のファイルがあるばあい、path に最初に出現したものだけが
;;採用されます。そのライブラリに対して、require あるいは
;;use を用いたをつかった場合に得られるのはこのファイルです。
;;すべてのマッチしたファイルについて反復したければ、allow-duplicates?
;;キーワード引数に #t を渡します。
;;example:
;;  (library-fold 'srfi-1 acons '())
;;   ==> ((srfi-1 . "../lib/srfi-1.scm"))
;;  
;;  (library-fold "srfi-1" acons '())
;;   ==> (("srfi-1" . "../lib/srfi-1.scm"))
;;  
;;  ;; acons が呼ばれるのとは逆順のリストが
;;  ;; 返ることに注意してください
;;  (library-fold 'srfi-1 acons '() :allow-duplicates? #t)
;;   ==> ((srfi-1 . "/usr/share/gauche/0.7.1/lib/srfi-1.scm")
;;     (srfi-1 . "../lib/srfi-1.scm"))
;;  
;;  ;; 以下の場合は、モジュール名ではマッチしませんが、
;;  ;; ファイル名ではマッチします
;;  (library-fold 'srfi-19.* acons '())
;;   ==> ()
;;  
;;  (library-fold "srfi-19/*" acons '())
;;   ==> (("srfi-19/read-tai" . "../lib/srfi-19/read-tai.scm")
;;     ("srfi-19/format" . "../lib/srfi-19/format.scm"))
;;  
;;  ;; 利用可能な dbm の実装を見付けます
;;  (library-fold 'dbm.* acons '())
;;   ==> ((dbm.cdb . "/usr/share/gauche/0.7.4.2/lib/dbm/cdb.scm")
;;     (dbm.gdbm . "../lib/dbm/gdbm.scm")
;;     (dbm.ndbm . "../lib/dbm/ndbm.scm")
;;     (dbm.odbm . "../lib/dbm/odbm.scm"))
;;
;;@param pattern 
;;@param proc 
;;@param seed 
;;@param :key 
;;@param paths 
;;@param strict? 
;;@param allow-duplicates? 

;;;;;
;;@type Macro
;;@name autoload
;;@description item ... がオートロードされるように設定します。すなわち、
;;次にitemが参照された時、それが実際に評価される前にfile/moduleがロード
;;されるようにします。これによって、必要とされる時までfile/moduleのロードを遅らせる
;;ことができます。
;;
;;引数file/moduleには、文字列かシンボルを指定できます。文字列の場合は
;;そのファイルがロードされます。シンボルの場合、その名のモジュールが(useと
;;同じルールで)ロードされ、itemがfile/moduleから
;;オートロードを呼び出したモジュールへとインポートされます。
;;(モジュールのuseの詳細についてはDefining and selecting modulesを参照して下さい)。
;;
;;itemは変数名(シンボル)か、(:macro symbol)というフォーム
;;でなければなりません。変数名の場合は、その変数が評価されようとした時に
;;指定のファイル／モジュールがロードされます。後者のフォームの場合は、
;;(symbol arg ...) というフォームがコンパイルされようとした
;;時に指定のファイル／モジュールがロードされます。後者はマクロのオートロードになります。
;;
;;symbolはfile/moduleの中で定義されなければなりません。
;;そうでなければロード時にエラーが報告されます。
;;
;;手続きのオートロードの例を示します。
;;example:
;;  (autoload "foo" foo0 foo1)
;;  (autoload "bar" bar0 bar1)
;;  
;;  (define (foobar x)
;;    (if (list? x)
;;        (map bar0 x)
;;        (foo0)))
;;  
;;  (foobar '(1 2)) ; @r{この時点で "bar" がロードされる}
;;  
;;  (foobar #f)     ; @r{この時点で "foo" がロードされる}
;;
;;マクロのオートロードを設定した場合、指定のファイルまたはモジュールは、
;;そのマクロを使っているフォームが実行されるされないにかかわらず、
;;コンパイラがそのフォームを見た時点でロードされることに注意してください。
;;
;;@param file/module 
;;@param item 
;;@param ... 

;;;;;
;;@type Function
;;@name provided?
;;@description featureが既にprovideされていれば#tを返します。
;;
;;@param feature 

;;;;;
;;@type Function
;;@name provide
;;@description featureをシステムのprovideされたフィーチャーリストに加えます。
;;以降、featureがrequireされてもファイルはふたたびロードされません。
;;
;;requireが要求された機能を自動的にprovideされたかのように
;;扱うAutoprovide機能があるために、provideを明示的に呼ぶ必要は
;;ほとんど無いでしょう。provideを使いたいシチュエーションとしては
;;次のようなものが考えられます。
;;
;;
;;そのファイルをロードすることになったfeatureとは異なるfeature (複数可) を
;;provideしたい場合。
;;
;;例えばfeature Xがfeature Yを置き換えるものだとします。
;;XはYのAPIを全て提供しますが、実装は異なります。この場合、
;;X.scmが一度ロードされたら、Y.scmをロードしてほしくないと思うでしょう。
;;X.scmに (provide "X") と (provide "Y") の両方を
;;書いておくことで、X.scmがfeature Yもprovideすると明示すれば、それが実現できます。
;;(注：provideが呼ばれると、requireのautoprovide機能は
;;抑制されるため、X.scm中で(provide "X")も指定する必要があります。)
;;
;;もちろんの方法では、ユーザが (require "Y") を (require "X")
;;より先に書いてしまったらY.scmはロードされてしまいます。
;;この方法は、現場において、永久的な解決が高コストになるような場合のとりあえずの
;;回避処置と考えるべきでしょう。
;;
;;featureを全くprovideしない。
;;feature引数に#fを渡すことで、何のfeatureもprovideすることなく
;;requireによるautoprovidingを抑制できます。
;;
;;これもまた、何らかの一時的な解決と考えるべきです。たとえば開発中に、
;;X.scmを頻繁に変更するために(require "X")が常に
;;そのファイルをロードするようにさせたい、といった場合が考えられます。
;;X.scmのリリースの前に (provide #f) を消しておくことを
;;忘れないように。また、インタラクティブにリロードしたいならば
;;gauche.reload (Reloading modules参照) を使うことを
;;おすすめします。
;;
;;
;;@param feature 

;;;;;
;;@type Function
;;@name require
;;@description featureがまだロードされていなければロードします。featureは文字列で
;;なければなりません。それがそのまま(サフィックスを除く)ファイル名としてロードパスから
;;探されます。requireの解釈はコンパイル時に行われます。
;;
;;SLIBモジュールをロードすると、requireが拡張されます。詳しくはSLIBを
;;参照して下さい。
;;
;;もしロードされたファイルがprovideフォームを含んでいなかった場合、
;;あたかもファイルの最後に(provide feature)があったかのように、
;;featureが自動的にprovideされます。これを
;;autoprovide機能と呼んでいます。
;;
;;@param feature 

;;;;;
;;@type Function
;;@name dynamic-load
;;@description ダイナミックローダブルライブラリ(共有ライブラリ)fileをロードしてリンクします。
;;fileにはサフィックス(``.so'' 等) を含めないで下さい。システムによって
;;サフィックスは異なるため、dynamic-loadがそれを追加します。
;;
;;キーワード引数init-functionは共有ライブラリ中の初期化関数の名前を
;;指定します。デフォルトでは、サフィックスを除くファイル名が ``foo'' の場合、
;;初期化関数名は ``Scm_Init_foo'' となります。
;;
;;キーワード引数export-symbolsは、ロードされるライブラリ中の外部シンボルを
;;プロセスのシンボルテーブルに追加すべきかどうかを指定します。(註：ここでの「シンボル」
;;とはCの関数名や変数名のことで、Schemeのシンボルのことではありません)。
;;デフォルトでは共有ライブラリの外部シンボルはプロセスのシンボルテーブルに追加されず、
;;それぞれの共有ライブラリは他の共有ライブラリのシンボルを見ることができません。
;;export-symbolsに真の値を渡すと、フラグRTLD_GLOBALが
;;dlopen()に渡されて、その共有ライブラリ中のシンボルがこれからロードされる
;;共有ライブラリからも見えるようになります。
;;
;;通常、共有ライブラリはSchemeモジュール中でロードされるので、モジュールユーザが
;;直接この手続きを呼ぶ必要はほとんどないでしょう。
;;
;;一度ロードされた共有ライブラリをアンロードすることはできません。
;;
;;@param file 
;;@param :key 
;;@param init-function 
;;@param export-symbols 

;;;;;
;;@type Function
;;@name current-load-next
;;@description これらの手続きによって、現在のロードのコンテクストを知ることができます。
;;ロードされているファイルの中でこれらの手続きを呼ぶと、次のような値が返されます。
;;current-load-port ------
;;  現在のフォームがロードされている入力ポート。
;;current-load-path ------
;;  現在のフォームがロードされているファイル。
;;  ロードのソースがファイルでない場合、この値は#f。
;;current-load-history ------
;;  入力ポートと行番号のペアのリストで、ロードのネスティングを示したもの。
;;  例えばあなたがfoo.scmをロードし、そのファイルの7行目で
;;  bar.scmがロードされ、そのファイルの18行目でbaz.scmが
;;  ロードされたとします。current-load-historyをbaz.scm中で
;;  呼ぶと、それは次のような値を返します。
;;  example:
;;    ((#<port "foo.scm"> . 7) (#<port "bar.scm"> . 18))
;;current-load-next ------
;;  現在のファイルがロードされた時点での、ファイルサーチパスの残りを返します。
;;  例えば *load-path* が
;;  ("." "../lib" "/home/gauche/lib" "/share/gauche/lib")で、
;;  あなたがfoo.scmをロードしたところ、それが../lib/中に見つかったと
;;  しましょう。このとき、foo.scm中でcurrent-load-nextを呼べば
;;  example:
;;    ("/home/gauche/lib" "/share/gauche/lib")
;;  が返されます。
;;
;;loadされていない状態で呼ばれた時は、これらの手続きはそれぞれ#f、
;;#f、()、()を返します。
;;

;;;;;
;;@type Function
;;@name current-load-history
;;@description これらの手続きによって、現在のロードのコンテクストを知ることができます。
;;ロードされているファイルの中でこれらの手続きを呼ぶと、次のような値が返されます。
;;current-load-port ------
;;  現在のフォームがロードされている入力ポート。
;;current-load-path ------
;;  現在のフォームがロードされているファイル。
;;  ロードのソースがファイルでない場合、この値は#f。
;;current-load-history ------
;;  入力ポートと行番号のペアのリストで、ロードのネスティングを示したもの。
;;  例えばあなたがfoo.scmをロードし、そのファイルの7行目で
;;  bar.scmがロードされ、そのファイルの18行目でbaz.scmが
;;  ロードされたとします。current-load-historyをbaz.scm中で
;;  呼ぶと、それは次のような値を返します。
;;  example:
;;    ((#<port "foo.scm"> . 7) (#<port "bar.scm"> . 18))
;;current-load-next ------
;;  現在のファイルがロードされた時点での、ファイルサーチパスの残りを返します。
;;  例えば *load-path* が
;;  ("." "../lib" "/home/gauche/lib" "/share/gauche/lib")で、
;;  あなたがfoo.scmをロードしたところ、それが../lib/中に見つかったと
;;  しましょう。このとき、foo.scm中でcurrent-load-nextを呼べば
;;  example:
;;    ("/home/gauche/lib" "/share/gauche/lib")
;;  が返されます。
;;
;;loadされていない状態で呼ばれた時は、これらの手続きはそれぞれ#f、
;;#f、()、()を返します。
;;

;;;;;
;;@type Function
;;@name current-load-path
;;@description これらの手続きによって、現在のロードのコンテクストを知ることができます。
;;ロードされているファイルの中でこれらの手続きを呼ぶと、次のような値が返されます。
;;current-load-port ------
;;  現在のフォームがロードされている入力ポート。
;;current-load-path ------
;;  現在のフォームがロードされているファイル。
;;  ロードのソースがファイルでない場合、この値は#f。
;;current-load-history ------
;;  入力ポートと行番号のペアのリストで、ロードのネスティングを示したもの。
;;  例えばあなたがfoo.scmをロードし、そのファイルの7行目で
;;  bar.scmがロードされ、そのファイルの18行目でbaz.scmが
;;  ロードされたとします。current-load-historyをbaz.scm中で
;;  呼ぶと、それは次のような値を返します。
;;  example:
;;    ((#<port "foo.scm"> . 7) (#<port "bar.scm"> . 18))
;;current-load-next ------
;;  現在のファイルがロードされた時点での、ファイルサーチパスの残りを返します。
;;  例えば *load-path* が
;;  ("." "../lib" "/home/gauche/lib" "/share/gauche/lib")で、
;;  あなたがfoo.scmをロードしたところ、それが../lib/中に見つかったと
;;  しましょう。このとき、foo.scm中でcurrent-load-nextを呼べば
;;  example:
;;    ("/home/gauche/lib" "/share/gauche/lib")
;;  が返されます。
;;
;;loadされていない状態で呼ばれた時は、これらの手続きはそれぞれ#f、
;;#f、()、()を返します。
;;

;;;;;
;;@type Function
;;@name current-load-port
;;@description これらの手続きによって、現在のロードのコンテクストを知ることができます。
;;ロードされているファイルの中でこれらの手続きを呼ぶと、次のような値が返されます。
;;current-load-port ------
;;  現在のフォームがロードされている入力ポート。
;;current-load-path ------
;;  現在のフォームがロードされているファイル。
;;  ロードのソースがファイルでない場合、この値は#f。
;;current-load-history ------
;;  入力ポートと行番号のペアのリストで、ロードのネスティングを示したもの。
;;  例えばあなたがfoo.scmをロードし、そのファイルの7行目で
;;  bar.scmがロードされ、そのファイルの18行目でbaz.scmが
;;  ロードされたとします。current-load-historyをbaz.scm中で
;;  呼ぶと、それは次のような値を返します。
;;  example:
;;    ((#<port "foo.scm"> . 7) (#<port "bar.scm"> . 18))
;;current-load-next ------
;;  現在のファイルがロードされた時点での、ファイルサーチパスの残りを返します。
;;  例えば *load-path* が
;;  ("." "../lib" "/home/gauche/lib" "/share/gauche/lib")で、
;;  あなたがfoo.scmをロードしたところ、それが../lib/中に見つかったと
;;  しましょう。このとき、foo.scm中でcurrent-load-nextを呼べば
;;  example:
;;    ("/home/gauche/lib" "/share/gauche/lib")
;;  が返されます。
;;
;;loadされていない状態で呼ばれた時は、これらの手続きはそれぞれ#f、
;;#f、()、()を返します。
;;

;;;;;
;;@type Function
;;@name load-from-port
;;@description 入力ポートportから、EOFを読むまで繰り返しScheme式を読み込み評価します。
;;
;;portにコーディング認識ポートを渡さない限り、"coding:"コメント
;;による文字コード変換は行われないことに注意して下さい。
;;
;;@param port 

;;;;;
;;@type Function
;;@name add-load-path
;;@description パスpathをライブラリロードパスのリストに加えます。
;;afterpに真の値が与えられていればpathは既存のリストの末尾に
;;追加されます。そうでなければpathは既存のリストの先頭に追加されます。
;;
;;ロードパスを変更したい場合、*load-path*を直接替えずにこのフォームを
;;使って下さい。このフォームはコンパイル時に解釈されるのに対し、*load-path*を
;;書き換えるコードは実行時に解釈されます。``use'' や ``require'' は
;;コンパイル時のロードパスを使うので、*load-path*への変更は反映されないかもしれません。
;;
;;更に、add-load-pathはpathの下にアーキテクチャ依存のディレクトリが
;;ないかどうかを探し、あればそれを内部の共有ライブラリサーチパスに追加します。
;;例えばあなたが自分のSchemeモジュールを/home/yours/libに入れていて、
;;それが共有ライブラリを必要としていたとします。手続きgauche-architecture
;;(Environment Inquiry参照)が返す値をARCHとして、
;;共有ライブラリを/home/yours/lib/ARCH/に置いておくと、
;;共有ライブラリはそこからロードされます。この方法を取ると、複数のプラットフォーム用に
;;別々にコンパイルされた共有ライブラリを管理することができます。
;;
;;@param path 
;;@param :optional 
;;@param (afterp #f) 

;;;;;
;;@type Function
;;@name format
;;@description [SRFI-28+]
;;string の指示に従い、arg ...をフォーマットします。
;;この手続きはCommonLispのformatのサブセットに、Gauche独自の拡張を
;;加えたものです。また、これはSRFI-28 "Basic format strings" のスーパーセットに
;;なっています (srfi-28,[SRFI-28],SRFI-28)。
;;
;;portは出力先を指定します。それが出力ポートであれば、フォーマットされた
;;結果はそのポートに書き出されます。portが#tであれば、結果は
;;現在の出力ポートに書き出されます。portが#fであれば、結果は
;;文字列としてformatから返されます。
;;portは省略することもできます。その場合は、portに#f
;;を指定したのと同じ動作をします(SRFI-28のformat)。
;;
;;stringはフォーマット指示子を含んだ文字列です。
;;フォーマット指示子はチルダ`~'から始まり、特定の文字で終了する文字の並びで、
;;それぞれのフォーマット指示子が対応するargを取りフォーマットします。
;;string内のフォーマット指示子以外の文字列はそのまま出力されます。
;;
;;example:
;;  (format #f "the answer is ~s" 42)
;;    ==> "the answer is 42"
;;
;;フォーマット指示子は一つ以上のコンマで区切られたパラメータを取ることもできます。
;;パラメータは整数か文字です。文字の場合、クオート文字に続けてその文字を置きます。
;;パラメータが省略された場合は既定値が使われます。パラメータの意味はフォーマット指示子毎に
;;異なります。
;;
;;さらに、フォーマット指示子は2種類のフラグ、`@@' と `:' を
;;取ることができます。これらの組合せでフォーマットの動作が変わります。フラグは
;;(もしあれば)パラメータの後、指示子の文字の直前に置かれなければなりません。
;;
;;パラメータの位置に文字 `v' か `V' を置くこともできます。
;;その場合、パラメータの値が引数リストから取られます。対応する引数は整数か
;;文字、または#fでなければなりません。#fの場合はそのパラメータが
;;省略されたのと同じになります。
;;
;;いくつかの例です。
;;
;;~10,2s ------
;;  パラメータ10と2を伴う、フォーマット指示子~s。
;;~12,,,'*A ------
;;  第1パラメータに数値12、第4パラメータに文字`*'を取るフォーマット指示子~a。
;;  第2と第3のパラメータは省略されています。
;;~10@@d ------
;;  フォーマット指示子~d。パラメータ10と`@@'フラグがついています。
;;~v,vx ------
;;  フォーマット指示子~x。第1パラメータと第2パラメータは引数リストから取られます。
;;
;;以下にサポートされているフォーマット指示子を示します。フォーマット指示子の文字自体は
;;大文字であっても小文字であっても構いません。特に断りのない限り両者は同じ動作をします。
;;
;;  ASCII出力。対応する引数がdisplayを使ってフォーマットされます。
;;  整数がmincolに与えられた場合、それは出力される最小の文字数を指定します。
;;  引数のフォーマット結果がmincolより短ければ、空白が右に追加されます(つまり、
;;  左詰めになります)。
;;  
;;  colinc、minpad、そしてpadcharは更に細かいパディング方法を
;;  指定します。padcharに文字が与えられた場合、それが空白文字の代わりにパディング文字と
;;  して使われます。minpadに0以上の整数が与えられた場合、少なくともその数だけの
;;  パディング文字が追加されます。colincが指定された場合、
;;  追加されるパディング文字の数がcolincの倍数に調整されます。
;;  
;;  アトマーク `@@' フラグが与えられた場合、結果は右詰めになります。
;;  
;;  maxcolパラメータは与えられていれば書かれる文字数の上限を指定します。
;;  フォーマット後の文字列の長さがmaxcolを超えた場合、maxcol文字だけが
;;  書かれます。コロン `:' フラグが同時に与えられていれば、
;;  maxcol - 4 文字が書かれた後、文字列`` ...''が書かれます。
;;  
;;  example:
;;    (format #f "|~a|" "oops")
;;      ==> "|oops|"
;;    (format #f "|~10a|" "oops")
;;      ==> "|oops      |"
;;    (format #f "|~10@@a|" "oops")
;;      ==> "|      oops|"
;;    (format #f "|~10,,,'*@@a|" "oops")
;;      ==> "|******oops|"
;;    (format #f "|~10,,,'☆a|" "oops")
;;      ==> "|oops☆☆☆☆☆☆|"
;;    
;;    (format #f "|~,,,,10a|" '(abc def ghi jkl))
;;      ==> "|(abc def gh|" 
;;    (format #f "|~,,,,10:a|" '(abc def ghi jkl))
;;      ==> "|(abc de ...|" 
;;  
;;  S式出力。対応する引数がwriteを使ってフォーマットされます。
;;  パラメータの意味は~A指示子と同じです。
;;  
;;  example:
;;    (format #f "|~s|" "oops")
;;      ==> "|\"oops\"|"
;;    (format #f "|~10s|" "oops")
;;      ==> "|\"oops\"    |"
;;    (format #f "|~10@@s|" "oops")
;;      ==> "|    \"oops\"|"
;;    (format #f "|~10,,,'*@@s|" "oops")
;;      ==> "|****\"oops\"|"
;;    (format #f "|~10,,,'★s|" "oops")
;;      ==> "|\"oops\"★★★★|"
;;  
;;  10進出力。対応する引数が10進数表記でフォーマットされます。もし引数が数値でなければ、
;;  全てのパラメータは(`v'パラメータの処理後に)無視され、
;;  引数は~Aでフォーマットされます。
;;  
;;  もしmincolに整数が与えられたら、それが最小の文字数を指定します。
;;  結果の文字数がそれより少なければ、文字padcharが左に追加されます(右詰めになります)。
;;  padcharが省略された場合は空白文字が使われます。
;;  
;;  example:
;;    (format #f "|~d|" 12345)
;;      ==> "|12345|"
;;    (format #f "|~10d|" 12345)
;;      ==> "|     12345|"
;;    (format #f "|~10,'0d|" 12345)
;;      ==> "|0000012345|"
;;  
;;  アトマーク `@@' フラグが与えられた場合、正の引数に対して `+' が
;;  先頭につけられます。
;;  
;;  コロンフラグ `:' が与えられた場合、結果の文字はinterval文字毎に
;;  まとめられ、間に文字commacharが挿入されます。デフォルトでは3文字毎にコンマが
;;  挿入されます。
;;  
;;  example:
;;    (format #f "|~:d|" 12345)
;;      ==> "|12,345|"
;;    (format #f "|~,,'_,4:d|" -12345678)
;;      ==> "|-1234_5678|"
;;  
;;  2進出力。対応する引数が2進数の整数としてフォーマットされます。
;;  パラメータの意味は~Dと同じです。
;;  
;;  8進出力。対応する引数が8進数の整数としてフォーマットされます。
;;  パラメータの意味は~Dと同じです。
;;  
;;  16進出力。対応する引数が16進数の整数としてフォーマットされます。
;;  フォーマット指示文字に `X' が与えられた場合は `ABCDEF' が桁文字として
;;  使われ、 `x' が与えられた場合は `abcdef' が桁文字として使われます。
;;  パラメータの意味は~Dと同じです。
;;  
;;  example:
;;    (format #f "~8,'0x" 259847592)
;;      ==> "0f7cf5a8"
;;    (format #f "~8,'0X" 259847592)
;;      ==> "0F7CF5A8"
;;  
;;  引数のカウンタをcountだけ後方にずらします。つまり、count個の引数が
;;  無視されることになります。countのデフォルト値は1です。
;;  コロンフラグが与えられた場合は引数カウンタを前方に動かします。
;;  例えば~:*は次のディレクティブが直前に使った引数を再び使うようにします。
;;  アトマークフラグが与えられた場合は、countが引数の絶対位置を示します。
;;  0が最初の引数です。
;;
;;
;;@param string 
;;@param arg 
;;@param ... 

;;;;;
;;@type Function
;;@name format
;;@description [SRFI-28+]
;;string の指示に従い、arg ...をフォーマットします。
;;この手続きはCommonLispのformatのサブセットに、Gauche独自の拡張を
;;加えたものです。また、これはSRFI-28 "Basic format strings" のスーパーセットに
;;なっています (srfi-28,[SRFI-28],SRFI-28)。
;;
;;portは出力先を指定します。それが出力ポートであれば、フォーマットされた
;;結果はそのポートに書き出されます。portが#tであれば、結果は
;;現在の出力ポートに書き出されます。portが#fであれば、結果は
;;文字列としてformatから返されます。
;;portは省略することもできます。その場合は、portに#f
;;を指定したのと同じ動作をします(SRFI-28のformat)。
;;
;;stringはフォーマット指示子を含んだ文字列です。
;;フォーマット指示子はチルダ`~'から始まり、特定の文字で終了する文字の並びで、
;;それぞれのフォーマット指示子が対応するargを取りフォーマットします。
;;string内のフォーマット指示子以外の文字列はそのまま出力されます。
;;
;;example:
;;  (format #f "the answer is ~s" 42)
;;    ==> "the answer is 42"
;;
;;フォーマット指示子は一つ以上のコンマで区切られたパラメータを取ることもできます。
;;パラメータは整数か文字です。文字の場合、クオート文字に続けてその文字を置きます。
;;パラメータが省略された場合は既定値が使われます。パラメータの意味はフォーマット指示子毎に
;;異なります。
;;
;;さらに、フォーマット指示子は2種類のフラグ、`@@' と `:' を
;;取ることができます。これらの組合せでフォーマットの動作が変わります。フラグは
;;(もしあれば)パラメータの後、指示子の文字の直前に置かれなければなりません。
;;
;;パラメータの位置に文字 `v' か `V' を置くこともできます。
;;その場合、パラメータの値が引数リストから取られます。対応する引数は整数か
;;文字、または#fでなければなりません。#fの場合はそのパラメータが
;;省略されたのと同じになります。
;;
;;いくつかの例です。
;;
;;~10,2s ------
;;  パラメータ10と2を伴う、フォーマット指示子~s。
;;~12,,,'*A ------
;;  第1パラメータに数値12、第4パラメータに文字`*'を取るフォーマット指示子~a。
;;  第2と第3のパラメータは省略されています。
;;~10@@d ------
;;  フォーマット指示子~d。パラメータ10と`@@'フラグがついています。
;;~v,vx ------
;;  フォーマット指示子~x。第1パラメータと第2パラメータは引数リストから取られます。
;;
;;以下にサポートされているフォーマット指示子を示します。フォーマット指示子の文字自体は
;;大文字であっても小文字であっても構いません。特に断りのない限り両者は同じ動作をします。
;;
;;  ASCII出力。対応する引数がdisplayを使ってフォーマットされます。
;;  整数がmincolに与えられた場合、それは出力される最小の文字数を指定します。
;;  引数のフォーマット結果がmincolより短ければ、空白が右に追加されます(つまり、
;;  左詰めになります)。
;;  
;;  colinc、minpad、そしてpadcharは更に細かいパディング方法を
;;  指定します。padcharに文字が与えられた場合、それが空白文字の代わりにパディング文字と
;;  して使われます。minpadに0以上の整数が与えられた場合、少なくともその数だけの
;;  パディング文字が追加されます。colincが指定された場合、
;;  追加されるパディング文字の数がcolincの倍数に調整されます。
;;  
;;  アトマーク `@@' フラグが与えられた場合、結果は右詰めになります。
;;  
;;  maxcolパラメータは与えられていれば書かれる文字数の上限を指定します。
;;  フォーマット後の文字列の長さがmaxcolを超えた場合、maxcol文字だけが
;;  書かれます。コロン `:' フラグが同時に与えられていれば、
;;  maxcol - 4 文字が書かれた後、文字列`` ...''が書かれます。
;;  
;;  example:
;;    (format #f "|~a|" "oops")
;;      ==> "|oops|"
;;    (format #f "|~10a|" "oops")
;;      ==> "|oops      |"
;;    (format #f "|~10@@a|" "oops")
;;      ==> "|      oops|"
;;    (format #f "|~10,,,'*@@a|" "oops")
;;      ==> "|******oops|"
;;    (format #f "|~10,,,'☆a|" "oops")
;;      ==> "|oops☆☆☆☆☆☆|"
;;    
;;    (format #f "|~,,,,10a|" '(abc def ghi jkl))
;;      ==> "|(abc def gh|" 
;;    (format #f "|~,,,,10:a|" '(abc def ghi jkl))
;;      ==> "|(abc de ...|" 
;;  
;;  S式出力。対応する引数がwriteを使ってフォーマットされます。
;;  パラメータの意味は~A指示子と同じです。
;;  
;;  example:
;;    (format #f "|~s|" "oops")
;;      ==> "|\"oops\"|"
;;    (format #f "|~10s|" "oops")
;;      ==> "|\"oops\"    |"
;;    (format #f "|~10@@s|" "oops")
;;      ==> "|    \"oops\"|"
;;    (format #f "|~10,,,'*@@s|" "oops")
;;      ==> "|****\"oops\"|"
;;    (format #f "|~10,,,'★s|" "oops")
;;      ==> "|\"oops\"★★★★|"
;;  
;;  10進出力。対応する引数が10進数表記でフォーマットされます。もし引数が数値でなければ、
;;  全てのパラメータは(`v'パラメータの処理後に)無視され、
;;  引数は~Aでフォーマットされます。
;;  
;;  もしmincolに整数が与えられたら、それが最小の文字数を指定します。
;;  結果の文字数がそれより少なければ、文字padcharが左に追加されます(右詰めになります)。
;;  padcharが省略された場合は空白文字が使われます。
;;  
;;  example:
;;    (format #f "|~d|" 12345)
;;      ==> "|12345|"
;;    (format #f "|~10d|" 12345)
;;      ==> "|     12345|"
;;    (format #f "|~10,'0d|" 12345)
;;      ==> "|0000012345|"
;;  
;;  アトマーク `@@' フラグが与えられた場合、正の引数に対して `+' が
;;  先頭につけられます。
;;  
;;  コロンフラグ `:' が与えられた場合、結果の文字はinterval文字毎に
;;  まとめられ、間に文字commacharが挿入されます。デフォルトでは3文字毎にコンマが
;;  挿入されます。
;;  
;;  example:
;;    (format #f "|~:d|" 12345)
;;      ==> "|12,345|"
;;    (format #f "|~,,'_,4:d|" -12345678)
;;      ==> "|-1234_5678|"
;;  
;;  2進出力。対応する引数が2進数の整数としてフォーマットされます。
;;  パラメータの意味は~Dと同じです。
;;  
;;  8進出力。対応する引数が8進数の整数としてフォーマットされます。
;;  パラメータの意味は~Dと同じです。
;;  
;;  16進出力。対応する引数が16進数の整数としてフォーマットされます。
;;  フォーマット指示文字に `X' が与えられた場合は `ABCDEF' が桁文字として
;;  使われ、 `x' が与えられた場合は `abcdef' が桁文字として使われます。
;;  パラメータの意味は~Dと同じです。
;;  
;;  example:
;;    (format #f "~8,'0x" 259847592)
;;      ==> "0f7cf5a8"
;;    (format #f "~8,'0X" 259847592)
;;      ==> "0F7CF5A8"
;;  
;;  引数のカウンタをcountだけ後方にずらします。つまり、count個の引数が
;;  無視されることになります。countのデフォルト値は1です。
;;  コロンフラグが与えられた場合は引数カウンタを前方に動かします。
;;  例えば~:*は次のディレクティブが直前に使った引数を再び使うようにします。
;;  アトマークフラグが与えられた場合は、countが引数の絶対位置を示します。
;;  0が最初の引数です。
;;
;;
;;@param port 
;;@param string 
;;@param arg 
;;@param ... 

;;;;;
;;@type Function
;;@name write-byte
;;@description 出力ポートに1バイトのデータbyteを書き出します。
;;byteは0から255の間の正確な整数でなければなりません。
;;
;;@param byte 
;;@param :optional 
;;@param port 

;;;;;
;;@type Function
;;@name flush-all-ports
;;@description それぞれ、port、および全てのポートにバッファされているデータを
;;全て書き出します。
;;
;;手続き"flush"はScheme実装によって様々な名前で呼ばれています：
;;force-output (Scsh, SCM)、
;;flush-output (Gambit)、flush-output-port (Bigloo) 等。
;;flushの名前はSTkとSTklosから取りました。
;;

;;;;;
;;@type Function
;;@name flush
;;@description それぞれ、port、および全てのポートにバッファされているデータを
;;全て書き出します。
;;
;;手続き"flush"はScheme実装によって様々な名前で呼ばれています：
;;force-output (Scsh, SCM)、
;;flush-output (Gambit)、flush-output-port (Bigloo) 等。
;;flushの名前はSTkとSTklosから取りました。
;;
;;@param :optional 
;;@param port 

;;;;;
;;@type Method
;;@name write-object
;;@description このメソッドをつかって、オブジェクトをどのように印字するかをカスタマイズ
;;できます。
;;
;;@param (obj <object>) port 

;;;;;
;;@type Function
;;@name print
;;@description expr ... をdisplayを使って現在の出力ポートに表示し、
;;最後に改行を書き出します。
;;
;;@param expr 
;;@param ... 

;;;;;
;;@type Function
;;@name write*
;;@description [SRFI-38]
;;writeと同じような出力を生成しますが、これらの手続きはさらに
;;共有される部分構造や循環構造を認識し、#n=, #n#構文を使って
;;それらを表現します。
;;
;;example:
;;  (write/ss 
;;    (let ((x (list 'a)))
;;      (list x x)))
;;   ==> ;; writes (#0=(a) #0#)
;;  
;;  (write/ss 
;;    (let ((x (list 'a)))
;;      (set-cdr! x x)
;;      x))
;;   ==> ;; writes #0=(a . #0#)
;;
;;read手続きもこの構文を認識するので、読み込めば
;;もとの構造と同型の構造が得られます。
;;
;;3つの手続きは等価です。
;;Gaucheは、STklosから取ったwrite*という名前を長く使ってきましたが、
;;srfi-38によってwrite-with-shared-structureとwrite/ssが
;;定義されました。今後は後者の名前を使った方がポータブルでしょう。
;;
;;註: ユーザ定義のwrite-objectメソッドはこれらの手続きに対して
;;透過的に動作します。
;;
;;@param obj 
;;@param :optional 
;;@param port 

;;;;;
;;@type Function
;;@name write/ss
;;@description [SRFI-38]
;;writeと同じような出力を生成しますが、これらの手続きはさらに
;;共有される部分構造や循環構造を認識し、#n=, #n#構文を使って
;;それらを表現します。
;;
;;example:
;;  (write/ss 
;;    (let ((x (list 'a)))
;;      (list x x)))
;;   ==> ;; writes (#0=(a) #0#)
;;  
;;  (write/ss 
;;    (let ((x (list 'a)))
;;      (set-cdr! x x)
;;      x))
;;   ==> ;; writes #0=(a . #0#)
;;
;;read手続きもこの構文を認識するので、読み込めば
;;もとの構造と同型の構造が得られます。
;;
;;3つの手続きは等価です。
;;Gaucheは、STklosから取ったwrite*という名前を長く使ってきましたが、
;;srfi-38によってwrite-with-shared-structureとwrite/ssが
;;定義されました。今後は後者の名前を使った方がポータブルでしょう。
;;
;;註: ユーザ定義のwrite-objectメソッドはこれらの手続きに対して
;;透過的に動作します。
;;
;;@param obj 
;;@param :optional 
;;@param port 

;;;;;
;;@type Function
;;@name write-with-shared-structure
;;@description [SRFI-38]
;;writeと同じような出力を生成しますが、これらの手続きはさらに
;;共有される部分構造や循環構造を認識し、#n=, #n#構文を使って
;;それらを表現します。
;;
;;example:
;;  (write/ss 
;;    (let ((x (list 'a)))
;;      (list x x)))
;;   ==> ;; writes (#0=(a) #0#)
;;  
;;  (write/ss 
;;    (let ((x (list 'a)))
;;      (set-cdr! x x)
;;      x))
;;   ==> ;; writes #0=(a . #0#)
;;
;;read手続きもこの構文を認識するので、読み込めば
;;もとの構造と同型の構造が得られます。
;;
;;3つの手続きは等価です。
;;Gaucheは、STklosから取ったwrite*という名前を長く使ってきましたが、
;;srfi-38によってwrite-with-shared-structureとwrite/ssが
;;定義されました。今後は後者の名前を使った方がポータブルでしょう。
;;
;;註: ユーザ定義のwrite-objectメソッドはこれらの手続きに対して
;;透過的に動作します。
;;
;;@param obj 
;;@param :optional 
;;@param port 

;;;;;
;;@type Function
;;@name port-map
;;@description readerによって読まれる入力に対する便利な繰り返し手続きです。
;;基本的に、readerが引数無しでEOFを返すまで繰り返し呼ばれ、
;;それが返した値に対してfnが呼ばれます。
;;readerはいずれEOFを返す手続きなら、入力ポートと関係している必要はありません。
;;
;;readerが要素 @{X0, X1, ..., Xn@} を返したとすると、
;;port-fold は次の値を返します。
;;example:
;;  (fn Xn (fn Xn-1 ... (fn X0 knil)))
;;一方、port-fold-rightは次の値を返します。
;;example:
;;  (fn X0 (fn X1 ... (fn Xn knil)))
;;すなわち、(port-fold cons '() read)は全ての入力の逆リストを
;;返し、(port-fold-right cons '() read)は
;;(port->list read port)と同じものを返します。
;;
;;port-for-eachとport-mapはfnを読まれた要素に
;;次々と適用します。前者はfnの結果を捨てますが、後者はfnの
;;結果をリストにして返します。
;;
;;@param fn 
;;@param reader 

;;;;;
;;@type Function
;;@name port-for-each
;;@description readerによって読まれる入力に対する便利な繰り返し手続きです。
;;基本的に、readerが引数無しでEOFを返すまで繰り返し呼ばれ、
;;それが返した値に対してfnが呼ばれます。
;;readerはいずれEOFを返す手続きなら、入力ポートと関係している必要はありません。
;;
;;readerが要素 @{X0, X1, ..., Xn@} を返したとすると、
;;port-fold は次の値を返します。
;;example:
;;  (fn Xn (fn Xn-1 ... (fn X0 knil)))
;;一方、port-fold-rightは次の値を返します。
;;example:
;;  (fn X0 (fn X1 ... (fn Xn knil)))
;;すなわち、(port-fold cons '() read)は全ての入力の逆リストを
;;返し、(port-fold-right cons '() read)は
;;(port->list read port)と同じものを返します。
;;
;;port-for-eachとport-mapはfnを読まれた要素に
;;次々と適用します。前者はfnの結果を捨てますが、後者はfnの
;;結果をリストにして返します。
;;
;;@param fn 
;;@param reader 

;;;;;
;;@type Function
;;@name port-fold-right
;;@description readerによって読まれる入力に対する便利な繰り返し手続きです。
;;基本的に、readerが引数無しでEOFを返すまで繰り返し呼ばれ、
;;それが返した値に対してfnが呼ばれます。
;;readerはいずれEOFを返す手続きなら、入力ポートと関係している必要はありません。
;;
;;readerが要素 @{X0, X1, ..., Xn@} を返したとすると、
;;port-fold は次の値を返します。
;;example:
;;  (fn Xn (fn Xn-1 ... (fn X0 knil)))
;;一方、port-fold-rightは次の値を返します。
;;example:
;;  (fn X0 (fn X1 ... (fn Xn knil)))
;;すなわち、(port-fold cons '() read)は全ての入力の逆リストを
;;返し、(port-fold-right cons '() read)は
;;(port->list read port)と同じものを返します。
;;
;;port-for-eachとport-mapはfnを読まれた要素に
;;次々と適用します。前者はfnの結果を捨てますが、後者はfnの
;;結果をリストにして返します。
;;
;;@param fn 
;;@param knil 
;;@param reader 

;;;;;
;;@type Function
;;@name port-fold
;;@description readerによって読まれる入力に対する便利な繰り返し手続きです。
;;基本的に、readerが引数無しでEOFを返すまで繰り返し呼ばれ、
;;それが返した値に対してfnが呼ばれます。
;;readerはいずれEOFを返す手続きなら、入力ポートと関係している必要はありません。
;;
;;readerが要素 @{X0, X1, ..., Xn@} を返したとすると、
;;port-fold は次の値を返します。
;;example:
;;  (fn Xn (fn Xn-1 ... (fn X0 knil)))
;;一方、port-fold-rightは次の値を返します。
;;example:
;;  (fn X0 (fn X1 ... (fn Xn knil)))
;;すなわち、(port-fold cons '() read)は全ての入力の逆リストを
;;返し、(port-fold-right cons '() read)は
;;(port->list read port)と同じものを返します。
;;
;;port-for-eachとport-mapはfnを読まれた要素に
;;次々と適用します。前者はfnの結果を捨てますが、後者はfnの
;;結果をリストにして返します。
;;
;;@param fn 
;;@param knil 
;;@param reader 

;;;;;
;;@type Function
;;@name port->sexp-list
;;@description 便利な入力手続きです。APIはScshとSTkから取りました。
;;
;;port->stringはportをEOFまで読み込み、
;;読んだものを文字列として返します。
;;
;;port->listは手続きreaderをportに繰り返し適用し、
;;結果をリストに蓄積します。readerがEOFを返したら
;;蓄積されたリストを返します。
;;
;;port->string-listはport->listを
;;read-lineで特定化したもので、
;;port->sexp-listはport->listを
;;readで特定化したものです。
;;
;;もし入力にGaucheの内部エンコーディングにおいて有効な文字をつくらない
;;バイト列が含まれていた場合、port->stringとport->string-list
;;の返り値には不完全な文字列が含まれている可能性があります。
;;
;;@param port 

;;;;;
;;@type Function
;;@name port->string-list
;;@description 便利な入力手続きです。APIはScshとSTkから取りました。
;;
;;port->stringはportをEOFまで読み込み、
;;読んだものを文字列として返します。
;;
;;port->listは手続きreaderをportに繰り返し適用し、
;;結果をリストに蓄積します。readerがEOFを返したら
;;蓄積されたリストを返します。
;;
;;port->string-listはport->listを
;;read-lineで特定化したもので、
;;port->sexp-listはport->listを
;;readで特定化したものです。
;;
;;もし入力にGaucheの内部エンコーディングにおいて有効な文字をつくらない
;;バイト列が含まれていた場合、port->stringとport->string-list
;;の返り値には不完全な文字列が含まれている可能性があります。
;;
;;@param port 

;;;;;
;;@type Function
;;@name port->list
;;@description 便利な入力手続きです。APIはScshとSTkから取りました。
;;
;;port->stringはportをEOFまで読み込み、
;;読んだものを文字列として返します。
;;
;;port->listは手続きreaderをportに繰り返し適用し、
;;結果をリストに蓄積します。readerがEOFを返したら
;;蓄積されたリストを返します。
;;
;;port->string-listはport->listを
;;read-lineで特定化したもので、
;;port->sexp-listはport->listを
;;readで特定化したものです。
;;
;;もし入力にGaucheの内部エンコーディングにおいて有効な文字をつくらない
;;バイト列が含まれていた場合、port->stringとport->string-list
;;の返り値には不完全な文字列が含まれている可能性があります。
;;
;;@param reader 
;;@param port 

;;;;;
;;@type Function
;;@name port->string
;;@description 便利な入力手続きです。APIはScshとSTkから取りました。
;;
;;port->stringはportをEOFまで読み込み、
;;読んだものを文字列として返します。
;;
;;port->listは手続きreaderをportに繰り返し適用し、
;;結果をリストに蓄積します。readerがEOFを返したら
;;蓄積されたリストを返します。
;;
;;port->string-listはport->listを
;;read-lineで特定化したもので、
;;port->sexp-listはport->listを
;;readで特定化したものです。
;;
;;もし入力にGaucheの内部エンコーディングにおいて有効な文字をつくらない
;;バイト列が含まれていた場合、port->stringとport->string-list
;;の返り値には不完全な文字列が含まれている可能性があります。
;;
;;@param port 

;;;;;
;;@type Function
;;@name define-reader-ctor
;;@description [SRFI-10]
;;読み込みコンストラクタprocedureをtagに関連付けます。
;;
;;例:
;;example:
;;  (define-reader-ctor 'pi (lambda () (* (atan 1) 4)))
;;  
;;  #,(pi) ==> 3.141592653589793
;;  
;;  '(#,(pi)) ==> (3.141592653589793)
;;  
;;  (define-reader-ctor 'hash
;;    (lambda (type . pairs)
;;      (let ((tab (make-hash-table type)))
;;        (for-each (lambda (pair)
;;                    (hash-table-put! tab (car pair) (cdr pair)))
;;                  pairs)
;;        tab)))
;;  
;;  (define table
;;   #,(hash eq? (foo . bar) (duh . dah) (bum . bom)))
;;  
;;  table ==> #<hash-table eq? 0x80f9398>
;;  (hash-table-get table 'duh) ==> dah
;;
;;write-objectメソッド(Output参照)と組み合わせて、
;;読み戻ることが可能なフォームで書かれたユーザ定義のクラスを
;;作ることが簡単になります。
;;
;;example:
;;  (define-class <point> ()
;;    ((x :init-value 0 :init-keyword :x)
;;     (y :init-value 0 :init-keyword :y)))
;;  
;;  (define-method write-object ((p <point>) out)
;;    (format out "#,(<point> ~s ~s)" (ref p 'x) (ref p 'y)))
;;  
;;  (define-reader-ctor '<point>
;;    (lambda (x y) (make <point> :x x :y y)))
;;
;;
;;@param tag 
;;@param procedure 

;;;;;
;;@type Function
;;@name byte-ready?
;;@description If one byte (octet) is ready to be read from port, returns
;;#t.
;;
;;@param port 

;;;;;
;;@type Function
;;@name eof-object
;;@description [R6RS]
;;EOFオブジェクトを返します。
;;

;;;;;
;;@type Function
;;@name read-block
;;@description nbytesバイトのデータをiportから読み込み、
;;不完全な文字列として返します。iportに十分なデータが無い場合、
;;返される文字列はnbytesより短いかもしれません。
;;nbytesが0の場合は、常に空文字列が返されます。
;;
;;iportが既にEOFに達していた場合はEOFオブジェクトが返されます。
;;
;;iportがファイルポートだった場合、read-blockは
;;ポートのバッファリングモードによってふるまいが異なります
;;(バッファリングモードの詳細についてはFile portsを参照して下さい)。
;;  バッファリングモードが:fullの場合、read-blockは
;;  EOFを読まない限り、nbytesのデータが読まれるまで待ちます。
;;  バッファリングモードが:modestか:noneである場合、
;;  read-blockはEOFが読まれなくても、すぐに読めるデータがnbytesよりも
;;  少ない場合はそのデータだけを返します。
;;
;;read-blockは呼ばれるたびに新たな文字列をアロケートします。
;;アロケーションを避け、あらかじめ用意された固定長のバッファにデータを読み込みたい
;;場合は、gauche.uvectorモジュールのread-block!
;;を使って下さい (Uvector block I/O参照)。
;;Read-block!はuniform vectorをバッファとして用います。
;;
;;データブロックをポートに書き出すには、データが文字列で表現されている
;;場合は単純にdisplayが使えます。データがuniform vectorで表現されている
;;場合はgauche.uvectorモジュールのwrite-blockが
;;使えます (Uvector block I/O参照)。
;;
;;@param nbytes 
;;@param :optional 
;;@param iport 

;;;;;
;;@type Function
;;@name read-line
;;@description 入力ポートから、行末もしくはEOFまで読み込んで文字列として返します。
;;よく使われる行末 (LF only, CRLF, and CR only) を認識します。
;;戻り値にはこれらの行末文字は含まれません。
;;iportが既にEOFに達していた場合はeofオブジェクトを返します。
;;
;;iportから、内部文字エンコーディングでは文字を構成し得ないバイトシーケンスが
;;読まれた場合、デフォルトではread-lineはエラーを通知します。
;;しかし、省略可能な引数allow-byte-string?に真の値が与えられた場合は、
;;read-lineはエラーを通知せず、かわりにバイト文字列 (不完全な文字列) を
;;返します。この動作は、特に文字エンコーディングが不明なソースから読み込む際に
;;便利です。例えばXMLドキュメントを読み込む際、最初の行のcharsetパラメータを
;;チェックしてから適切な文字エンコーディング変換ポートを使うといった用途などです。
;;
;;@param :optional 
;;@param iport 
;;@param allow-byte-string? 

;;;;;
;;@type Function
;;@name peek-byte
;;@description 入力ポートiportの先頭の1バイトを見て、それを0から255までの整数値として返します。
;;iportが既にEOFに達していた場合はeofオブジェクトを返します。
;;
;;@param :optional 
;;@param iport 

;;;;;
;;@type Function
;;@name read-byte
;;@description 入力ポートiportから1バイト読み込み、0から255までの整数値として返します。
;;iportが既にEOFに達していた場合はeofオブジェクトを返します。
;;
;;@param :optional 
;;@param iport 

;;;;;
;;@type Function
;;@name read/ss
;;@description [SRFI-38]
;;これらの手続きは、SRFI-38 で定義されていて、共有構造を表す記法
;;(#n=, #n#)を認識できます。Gauche の組み込み read は
;;この SRFI-38 の記法を認識します。それゆえ、これらの手続きは、read
;;と同じで、SRFI-38 との互換性のために用意されています。
;;
;;@param :optional 
;;@param iport 

;;;;;
;;@type Function
;;@name read-with-shared-structure
;;@description [SRFI-38]
;;これらの手続きは、SRFI-38 で定義されていて、共有構造を表す記法
;;(#n=, #n#)を認識できます。Gauche の組み込み read は
;;この SRFI-38 の記法を認識します。それゆえ、これらの手続きは、read
;;と同じで、SRFI-38 との互換性のために用意されています。
;;
;;@param :optional 
;;@param iport 

;;;;;
;;@type Function
;;@name open-coding-aware-port
;;@description 入力ポートを引数としてとりコーディング認識入力ポートを返します。
;;基本的には iport からの入力データをリーダにわたしているだけです。
;;しかし、iport からの入力データの最初の2行以内に、特別な呪文コメント
;;が現れた場合、コーディング認識ポートは、その後に読み込まれるデータについて
;;必要な文字エンコーディング変換を行います。
;;
;;引数として渡されたポート、iport は生成されたコーディング認識
;;ポートによって所有されます。つまり、コーディング認識ポートがクローズ
;;されると、iport もクローズされます。iport から読み込まれた
;;内容はコーディング認識ポート内でバッファリングさます、したがって、
;;別のコードで iport から読み出しを行うべきではありません。
;;
;;デフォルトでは、Gauche の load はプログラムソースを読むのに
;;コーディング認識ポートを使います。したがって、文字エンコーディングを
;;示す特別な呪文コメントは、Gauche のソースプログラムでは有効になります
;;(Loading Scheme file参照)。ただし、この機構自身は load とは
;;独立しており、このポートを別の目的で利用できます。特にコーディングの
;;呪文コメントがある Scheme のソースプログラムを処理する関数を書くときに
;;便利です。
;;
;;@param iport 

;;;;;
;;@type Function
;;@name read-from-string
;;@description 文字列ポートを使う定型句をユーティリティ関数にしました。
;;example:
;;  (write-to-string obj writer)
;;    ≡ 
;;    (with-output-to-string (lambda () (writer obj)))
;;  
;;  (read-from-string string)
;;    ≡ 
;;    (with-input-from-string string read)
;;writerの既定値はwriteです。start, endは
;;省略されればそれぞれ0と文字列の長さになります。
;;
;;移植性への註：Common Lispに同名の関数があります。必須引数の動作は同じですが、
;;省略可能な引数は異なります。
;;STkにはread-from-stringがありますが、省略可能な引数は取りません。
;;
;;@param string 
;;@param :optional 
;;@param start 
;;@param end 

;;;;;
;;@type Function
;;@name write-to-string
;;@description 文字列ポートを使う定型句をユーティリティ関数にしました。
;;example:
;;  (write-to-string obj writer)
;;    ≡ 
;;    (with-output-to-string (lambda () (writer obj)))
;;  
;;  (read-from-string string)
;;    ≡ 
;;    (with-input-from-string string read)
;;writerの既定値はwriteです。start, endは
;;省略されればそれぞれ0と文字列の長さになります。
;;
;;移植性への註：Common Lispに同名の関数があります。必須引数の動作は同じですが、
;;省略可能な引数は異なります。
;;STkにはread-from-stringがありますが、省略可能な引数は取りません。
;;
;;@param obj 
;;@param :optional 
;;@param writer 

;;;;;
;;@type Function
;;@name with-string-io
;;@description example:
;;  (define (call-with-string-io str proc)
;;    (let ((out (open-output-string))
;;          (in  (open-input-string str)))
;;      (proc in out)
;;      (get-output-string out)))
;;  
;;  (define (with-string-io str thunk)
;;    (with-output-to-string
;;      (lambda ()
;;        (with-input-from-string str
;;          thunk))))
;;
;;@param str 
;;@param thunk 

;;;;;
;;@type Function
;;@name call-with-string-io
;;@description example:
;;  (define (call-with-string-io str proc)
;;    (let ((out (open-output-string))
;;          (in  (open-input-string str)))
;;      (proc in out)
;;      (get-output-string out)))
;;  
;;  (define (with-string-io str thunk)
;;    (with-output-to-string
;;      (lambda ()
;;        (with-input-from-string str
;;          thunk))))
;;
;;@param str 
;;@param proc 

;;;;;
;;@type Function
;;@name with-output-to-string
;;@description これらのユーティリティ関数は次に定義されるような動作をします。
;;インタフェースはファイルポートを扱う類似の関数と揃えてあります。
;;example:
;;  (define (call-with-output-string proc)
;;    (let ((out (open-output-string)))
;;      (proc out)
;;      (get-output-string out)))
;;  
;;  (define (call-with-input-string str proc)
;;    (let ((in (open-input-string str)))
;;      (proc in)))
;;  
;;  (define (with-output-to-string thunk)
;;    (let ((out (open-output-string)))
;;      (with-output-to-port out thunk)
;;      (get-output-string out)))
;;  
;;  (define (with-input-from-string str thunk)
;;    (with-input-from-port (open-input-string str) thunk))
;;
;;@param thunk 

;;;;;
;;@type Function
;;@name with-input-from-string
;;@description これらのユーティリティ関数は次に定義されるような動作をします。
;;インタフェースはファイルポートを扱う類似の関数と揃えてあります。
;;example:
;;  (define (call-with-output-string proc)
;;    (let ((out (open-output-string)))
;;      (proc out)
;;      (get-output-string out)))
;;  
;;  (define (call-with-input-string str proc)
;;    (let ((in (open-input-string str)))
;;      (proc in)))
;;  
;;  (define (with-output-to-string thunk)
;;    (let ((out (open-output-string)))
;;      (with-output-to-port out thunk)
;;      (get-output-string out)))
;;  
;;  (define (with-input-from-string str thunk)
;;    (with-input-from-port (open-input-string str) thunk))
;;
;;@param string 
;;@param thunk 

;;;;;
;;@type Function
;;@name call-with-output-string
;;@description これらのユーティリティ関数は次に定義されるような動作をします。
;;インタフェースはファイルポートを扱う類似の関数と揃えてあります。
;;example:
;;  (define (call-with-output-string proc)
;;    (let ((out (open-output-string)))
;;      (proc out)
;;      (get-output-string out)))
;;  
;;  (define (call-with-input-string str proc)
;;    (let ((in (open-input-string str)))
;;      (proc in)))
;;  
;;  (define (with-output-to-string thunk)
;;    (let ((out (open-output-string)))
;;      (with-output-to-port out thunk)
;;      (get-output-string out)))
;;  
;;  (define (with-input-from-string str thunk)
;;    (with-input-from-port (open-input-string str) thunk))
;;
;;@param proc 

;;;;;
;;@type Function
;;@name call-with-input-string
;;@description これらのユーティリティ関数は次に定義されるような動作をします。
;;インタフェースはファイルポートを扱う類似の関数と揃えてあります。
;;example:
;;  (define (call-with-output-string proc)
;;    (let ((out (open-output-string)))
;;      (proc out)
;;      (get-output-string out)))
;;  
;;  (define (call-with-input-string str proc)
;;    (let ((in (open-input-string str)))
;;      (proc in)))
;;  
;;  (define (with-output-to-string thunk)
;;    (let ((out (open-output-string)))
;;      (with-output-to-port out thunk)
;;      (get-output-string out)))
;;  
;;  (define (with-input-from-string str thunk)
;;    (with-input-from-port (open-input-string str) thunk))
;;
;;@param string 
;;@param proc 

;;;;;
;;@type Function
;;@name get-output-string
;;@description [SRFI-6]
;;出力文字列ポートportを取り、それまでそのポートに蓄積された
;;文字列を返します。バイトデータがそのポートに書き出されていた場合、
;;この手続きはまず内部バッファをスキャンし、結果が完全な文字列で表現できるかどうかを
;;調べます。もし表現できなければ、不完全な文字列が返されます。
;;
;;これはportの操作には影響をあたえません。get-ouptut-stringを
;;呼んだ後でも、portに内容を蓄積しつづけることができます。
;;
;;@param port 

;;;;;
;;@type Function
;;@name open-output-string
;;@description [SRFI-6]
;;出力文字列ポートを作成して返します。このポートに書き出された文字列は
;;内部のバッファにたくわえられ、get-output-string で取り出すことが
;;できます。
;;これは、順番に文字列を構成する方法として、あらかじめ文字列をアロケートして
;;string-set!で埋めて行くよりもずっと効率の良い方法です。
;;

;;;;;
;;@type Function
;;@name get-remaining-input-string
;;@description portは入力文字列ポートでなければなりません。
;;入力ポートに残っている文字列を返します。
;;portの内部ポインタは動かされないので、portに対するreadは
;;影響を受けません。portが既にEOFに達していた場合は、空文字列が返されます。
;;
;;example:
;;  (define p (open-input-string "abc\ndef"))
;;  (read-line p)                  ==> "abc"
;;  (get-remaining-input-string p) ==> "def"
;;  (read-char p)                  ==> #\d
;;  (read-line p)                  ==> "ef"
;;  (get-remaining-input-string p) ==> ""
;;
;;@param port 

;;;;;
;;@type Function
;;@name open-input-string
;;@description [SRFI-6]
;;stringを内容とする入力文字列ポートを作って返します。
;;文字列に逐次的にアクセスする場合、インデックスをインクリメントしながら
;;string-refを呼び出すより効率の良い方法です。
;;example:
;;  (define p (open-input-string "文字 列"))
;;  (read p) ==> 文字
;;  (read-char p) ==> #\space
;;  (read-char p) ==> #\列
;;  (read-char p) ==> #<eof>
;;  (read-char p) ==> #<eof>
;;
;;@param string 

;;;;;
;;@type Function
;;@name port-fd-dup!
;;@description システムのdup2(2)のインタフェースです。
;;アトミックにtoportのファイルディスクリプタをクローズし、fromportの
;;ファイルディスクリプタを複製したものをtoportに設定します。
;;toport、fromportはいずれもファイルポートでなければなりません。
;;
;;ファイルディスクリプタが「複製」されると、ふたつのディスクリプタ番号が異なっていても
;;それらはシステムのオープンファイルテーブルの同じエントリを指します。
;;例えば、現在の(システムレベルでの)ファイル上の読み書き位置は共有されます。
;;port-fd-dup!の後で、port-seekをfromportに
;;対して呼び出せば、その変更はtoportの読み書き位置にも影響を与えるでしょうし、
;;その逆もまたあります。ただし、共有されるのはシステムレベルの情報のみで、
;;toportやfromportがバッファリングされている場合、バッファの内容は
;;共有されません。
;;
;;この手続きは、主にファイルディスクリプタを明示的に制御する必要のあるプログラム
;;のために用意されています。例えばデーモンプロセスがその入出力を/dev/nullなどの
;;無難なデバイスに切り替えたり、シェルプロセスが子プロセスをexecする前に
;;そのファイルディスクリプタをセットアップしたりするような場合です。
;;
;;@param toport 
;;@param fromport 

;;;;;
;;@type Function
;;@name open-output-fd-port
;;@description 与えられたファイルディスクリプタにアクセスする入力または出力ポートを
;;作成して返します。buffering はopen-input-file の項で
;;説明されたポートのバッファリングモードを指定します。デフォルトは:fullです。
;;nameはport-nameによって返されるポートの名前を指定します。
;;owner? は、このポートを閉じた時にfdもクローズすべきかどうかを
;;指定するブーリアン値です。
;;
;;@param fd 
;;@param :key 
;;@param buffering 
;;@param name 
;;@param owner? 

;;;;;
;;@type Function
;;@name open-input-fd-port
;;@description 与えられたファイルディスクリプタにアクセスする入力または出力ポートを
;;作成して返します。buffering はopen-input-file の項で
;;説明されたポートのバッファリングモードを指定します。デフォルトは:fullです。
;;nameはport-nameによって返されるポートの名前を指定します。
;;owner? は、このポートを閉じた時にfdもクローズすべきかどうかを
;;指定するブーリアン値です。
;;
;;@param fd 
;;@param :key 
;;@param buffering 
;;@param name 
;;@param owner? 

;;;;;
;;@type Function
;;@name copy-port
;;@description srcからEOFまでデータを読みだし、dstへ書き出します。
;;
;;キーワード引数unitは0以上の整数か、シンボルbyteもしくはchar
;;でなければなりません。これはデータをコピーする単位を指定します。
;;整数ならば、その大きさ(0の場合はシステム規定の大きさ)のバッファが確保され、
;;ブロックI/Oを使って転送が行われます。通常のファイルをコピーする場合などはこれが
;;速いでしょう。もしunitがシンボルbyteであれば、バイト毎
;;に読みだし／書き込みが行われます。unitがシンボルcharであれば、
;;キャラクタ毎に読みだし／書き込みが行われます。
;;
;;キーワード引数sizeに非負の整数が与えられた場合、それはコピーされるデータの
;;最大量を指定します。unitがシンボルcharの場合はsizeは
;;コピーされる文字数を、そうでない場合はバイト数を指定します。
;;
;;@param src 
;;@param dst 
;;@param :key 
;;@param (unit 0) (size #f) 

;;;;;
;;@type Function
;;@name port-tell
;;@description portの現在のread/writeポインタの値をバイト数で返します。
;;portがランダムアクセス可能でない場合は#fが返されます。
;;これは以下の呼び出しと等価です。
;;example:
;;  (port-seek port 0 SEEK_CUR)
;;
;;@param port 

;;;;;
;;@type Function
;;@name port-seek
;;@description portがランダムアクセス可能なポートの場合、
;;この手続きはportのread/writeポインタをoffsetとwhenceの値によって
;;設定し、新たなread/writeポインタの値(データの先頭からのバイトオフセット)を
;;返します。portがランダムアクセス可能でない場合は#fが返されます。
;;現在のバージョンでは、ファイルポートおよび入力文字列ポートがランダムアクセス可能です。
;;出力文字列ポートは現在のポインタの値を問い合わせる動作だけが可能です。
;;
;;ポートのポインタはバイト数で表現され、文字数とは異なることに注意して下さい。
;;
;;portが出力ファイルポートの場合は、データの終端を超えた位置までseek
;;することが可能です。その場合の動作はPOSIXのlseek(2)に準じます。
;;入力ファイルポートや入力文字列ポートではデータの終端以降にseekすることはできません。
;;
;;whence引数は、offsetの基準を指定する小さな整数です。
;;以下の定数が定義されています。
;;
;;SEEK_SET ------
;;  offsetはデータ先頭からのバイト数を指定します。
;;  whenceが省略された場合のデフォルトの動作です。
;;  
;;SEEK_CUR ------
;;  offsetは現在のread/writeポインタからの相対バイト数を指定します。
;;  offsetが0であれば、ポインタを動かさずに現在のポート位置を知ることができます。
;;  
;;SEEK_END ------
;;  offsetはデータの終端からの相対バイト数を指定します。
;;
;;@param port 
;;@param offset 
;;@param :optional 
;;@param whence 

;;;;;
;;@type Function
;;@name port-file-number
;;@description portがファイルに関連付けられている場合、そのファイルディスクリプタ番号を
;;返します。それ以外の場合は#fを返します。
;;
;;@param port 

;;;;;
;;@type Function
;;@name port-current-line
;;@description portの現在の行番号を返します。行番号は、ファイルに関連付けられたポートで
;;かつシーケンシャルなキャラクタI/Oを行っている場合のみ有効です。それ以外の場合は
;;-1を返します。
;;
;;@param port 

;;;;;
;;@type Function
;;@name port-buffering
;;@description ファイルポート((port-type port)がfileを返すもの)
;;に対して、そのバッファリングモードを読みだし、もしくは変更します。
;;入力ポートではバッファリングモードは
;;:full、 :modest、:noneのいずれかです。
;;出力ポートでは
;;:full、 :line、:noneのいずれかです。
;;バッファリングモードの詳細な説明は、File ports を参照してください。
;;
;;port-bufferingがファイルポート以外のポートに対して呼ばれた場合は
;;#fを返します。port-bufferingのsetterが
;;ファイルポート以外のポートに対して呼ばれた場合はエラーとなります。
;;
;;@param port 

;;;;;
;;@type Function
;;@name port-name
;;@description portの名前を返します。ポートがファイルに関連付けられている場合は、ポートの名前は
;;ファイル名です。そうでない場合、ポートを説明する文字列が返されます。
;;
;;@param port 

;;;;;
;;@type Function
;;@name port-type
;;@description portのタイプを、シンボルfile、string、procの
;;いずれかで返します。
;;
;;@param port 

;;;;;
;;@type Function
;;@name with-ports
;;@description 上の3つの動作を同時に行う手続きです。
;;入力、出力、エラーの各ポートをそれぞれiport, oport, eportに
;;セットしてthunkを呼び出します。変更する必要がないポートの引数には
;;#fを渡すことができます。
;;
;;@param iport 
;;@param oport 
;;@param eport 
;;@param thunk 

;;;;;
;;@type Function
;;@name with-error-to-port
;;@description それぞれ入力、出力、エラーポートをportにセットした状態でthunkを呼び出します。
;;
;;@param port 
;;@param thunk 

;;;;;
;;@type Function
;;@name with-output-to-port
;;@description それぞれ入力、出力、エラーポートをportにセットした状態でthunkを呼び出します。
;;
;;@param port 
;;@param thunk 

;;;;;
;;@type Function
;;@name with-input-from-port
;;@description それぞれ入力、出力、エラーポートをportにセットした状態でthunkを呼び出します。
;;
;;@param port 
;;@param thunk 

;;;;;
;;@type Function
;;@name standard-error-port
;;@description 引数無しで呼ぶと、プログラム開始時点の標準入出力ポートを返します。これらの値が
;;current-input-port、current-output-port、
;;current-error-portのデフォルトとなります。
;;
;;引数にポート(standard-input-portには入力ポート、
;;standard-output-portとstandard-error-portには
;;出力ポート)を渡すことで、これらの手続きが次回から返すポートを変えることができます。
;;引数ありで呼ばれた場合、これらの手続きは変更前の、現在の値を返します。
;;Schemeプログラムからこれらの値を変更する必要はほとんどないでしょう。
;;というのも、これらの値は通常はcurrent-input-portなどを初期化する際にだけ
;;使われるからです。また、低レベルのCライブラリが参照している標準入出力を
;;これらの手続きで置き換えることもできません。
;;どうしても必要がある場合にだけ変更を考えてください。
;;
;;@param :optional 
;;@param new-port 

;;;;;
;;@type Function
;;@name standard-output-port
;;@description 引数無しで呼ぶと、プログラム開始時点の標準入出力ポートを返します。これらの値が
;;current-input-port、current-output-port、
;;current-error-portのデフォルトとなります。
;;
;;引数にポート(standard-input-portには入力ポート、
;;standard-output-portとstandard-error-portには
;;出力ポート)を渡すことで、これらの手続きが次回から返すポートを変えることができます。
;;引数ありで呼ばれた場合、これらの手続きは変更前の、現在の値を返します。
;;Schemeプログラムからこれらの値を変更する必要はほとんどないでしょう。
;;というのも、これらの値は通常はcurrent-input-portなどを初期化する際にだけ
;;使われるからです。また、低レベルのCライブラリが参照している標準入出力を
;;これらの手続きで置き換えることもできません。
;;どうしても必要がある場合にだけ変更を考えてください。
;;
;;@param :optional 
;;@param new-port 

;;;;;
;;@type Function
;;@name standard-input-port
;;@description 引数無しで呼ぶと、プログラム開始時点の標準入出力ポートを返します。これらの値が
;;current-input-port、current-output-port、
;;current-error-portのデフォルトとなります。
;;
;;引数にポート(standard-input-portには入力ポート、
;;standard-output-portとstandard-error-portには
;;出力ポート)を渡すことで、これらの手続きが次回から返すポートを変えることができます。
;;引数ありで呼ばれた場合、これらの手続きは変更前の、現在の値を返します。
;;Schemeプログラムからこれらの値を変更する必要はほとんどないでしょう。
;;というのも、これらの値は通常はcurrent-input-portなどを初期化する際にだけ
;;使われるからです。また、低レベルのCライブラリが参照している標準入出力を
;;これらの手続きで置き換えることもできません。
;;どうしても必要がある場合にだけ変更を考えてください。
;;
;;@param :optional 
;;@param new-port 

;;;;;
;;@type Function
;;@name current-error-port
;;@description 現在のエラーポートを返します。
;;

;;;;;
;;@type Function
;;@name port-closed?
;;@description objがポートであり、既に閉じられていた場合に真を返します。
;;一度閉じたポートは再び開くことはできません。
;;
;;@param port 

;;;;;
;;@type Function
;;@name with-port-locking
;;@description portをロックし、thunkを実行します。
;;ロックはthunkのダイナミックエクステントの期間有効です。
;;
;;portがロックされている期間での組み込みのポートアクセス関数の
;;呼び出しは排他制御をバイパスするため、性能向上が見込まれます。
;;
;;ロックの有効期間はthunkのダイナミックエクステントなので、
;;thunk内からwith-port-lockingの外で捕捉された
;;継続を呼んだ場合、ロックは解放されます。その後、thunk内で
;;捕捉された継続が呼ばれた場合、再びロックが獲得されます。
;;
;;with-port-lockingはネスト可能です。ロックは最も外側の
;;with-port-lockingの期間中有効となります。
;;
;;この手続きはポート組込みのロック機構を利用します。つまり、ポートアクセスが
;;競合した場合はbusy waitになるということです。この手続きはあくまで
;;頻繁なロックによるオーバヘッドを回避するためのものです。
;;もし本当に競合が予測される場合は明示的に排他制御を行ってください。
;;
;;@param port 
;;@param thunk 

;;;;;
;;@type Class
;;@name <port>
;;@description Portは、Schemeにおいて抽象化された入出力のインタフェースを提供します。
;;Gaucheはportにいくつかの拡張を行い、いろいろなアプリケーションに対応できるようにしました。
;;
;;標準のSchemeでは、portはキャラクタを一文字づつ読み込む(一文字先読み可)、
;;もしくは書き出すだけのもので、他の入出力ルーチンはその上に構築されています。
;;
;;Gaucheではさらに次のような操作がportに対して可能になっています。
;;
;;バイナリI/O ------
;;  キャラクタ毎でなく、オクテット毎のI/Oが可能です(Gaucheではマルチバイト文字を
;;  扱うので、この２つが異なることに注意して下さい)。大抵のポートでは
;;  キャラクタI/OとバイナリI/Oを混ぜて使うことができます。
;;  
;;  最も基本的なバイナリI/Oプリミティブはread-byteとwrite-byteです。
;;  また、より高機能なpackやunpackといった手続きが
;;  Packing Binary Data で提供されています。
;;  
;;ブロックI/O ------
;;  ポートから指定した数のバイト列を読んだり、ポートへ書いたりできます。
;;  ポートがブロックI/Oを行うデバイスに接続されている場合、ある程度大きなブロック毎に
;;  読み書きすると効率の良いデータ転送ができます。
;;  
;;変換 ------
;;  ポートはまた、データストリームを変換するのにも使えます。例えばgauche.charconv
;;  モジュールでは、文字コード間の変換を行うポートを提供しています
;;  (詳しくはCharacter code conversionを参照)。
;;  
;;追加機能 ------
;;  また、特殊な機能を実現するポートもあります。
;;  コーディング認識ポート(Coding-aware ports参照)は
;;  ファイル中の特殊なコメントを認識して、そのファイルがどの文字エンコーディング
;;  で書かれているかを検出します。
;;  仮想ポート(Virtual ports参照)はSchemeでふるまいをプログラムできる
;;  ポートを提供します。
;;
;;

;;;;;
;;@type Function
;;@name read-eval-print-loop
;;@description goshのデフォルトのread-eval-printループをアプリケーションに
;;エクスポートします。それぞれの引数は、Gaucheのデフォルトの手続きを使うことを
;;示す#fであっても良いですし、以下の条件を満たす手続きであっても構いません。
;;
;;reader ------
;;  引数を取らない手続きです。式を読み込んでそれを返すことを期待されます。
;;evaluator ------
;;  式と環境識別子を2引数として取る手続きです。式を評価して、0個以上の値を
;;  返すことを期待されます。
;;printer ------
;;  0個以上の引数を取る手続きです。それらの値を出力することを期待されます。
;;  この手続きの戻り値は無視されます。
;;prompter ------
;;  引数を取らない手続きです。プロンプトを出力することを期待されます。
;;  この手続きの戻り値は無視されます。
;;
;;これらの手続きが与えられると、read-eval-print-loopは以下のように
;;動作します。
;;
;;prompterを呼んでプロンプトを出力します。
;;readerを呼んで式を読み込みます。EOFが返されたら、ループを終了し
;;read-eval-print-loopから戻ります。
;;evaluatorを呼んで式を評価します。
;;printerを呼んで結果を出力し、その後、1から繰り返します。
;;
;;これらの手続きのうちの1つからエラーが通知されると、そのエラーは
;;デフォルトのエスケープハンドラにより捕捉・報告され、その後、
;;ループが1から再開します。
;;
;;これらの手続きの内部で継続を捕捉し、後で再起動することは
;;許されています。
;;
;;@param :optional 
;;@param reader 
;;@param evaluator 
;;@param printer 
;;@param prompter 

;;;;;
;;@type Macro
;;@name condition
;;@description [SRFI-35]
;;コンディションを生成するのに便利なマクロ。
;;合成されたコンディションも生成できます。
;;Type-field-binding は、
;;(condition-type (field-name value-expr) ...)
;;という形式になります。
;;
;;example:
;;  (condition
;;    (type0 (field00 value00) ...)
;;    (type1 (field10 value10) ...)
;;    ...)
;;   ≡ 
;;  (make-compound-condition
;;    (make-condition type0 'field00 value00 ...)
;;    (make-condition type1 'field10 value10 ...)
;;    ...)
;;
;;@param type-field-binding 
;;@param ... 

;;;;;
;;@type Function
;;@name extract-condition
;;@description [SRFI-35]
;;condition はコンディションで、condition-typeタイプで
;;なければなりません。この手続きは condition-type のコンディション
;;を返し、condition からとりだされた値のフィールドを持ちます。
;;
;;@param condition 
;;@param condition-type 

;;;;;
;;@type Function
;;@name make-compound-condition
;;@description [SRFI-35]
;;condition0 condition1 ... のすべてを持つ合成コンディション
;;を返します。返されたコンディションのフィールドは、与えられたコンディション
;;のすべてのフィールドの和集合になります。同じ名前のフィールドを持つ
;;コンディションがある場合には最初に与えられものが優先されます。
;;返されたコンディションは元になったコンディションのすべてのタイプの
;;コンディションタイプをもつことになります。
;;(これは多重継承ではありません。上の <compound-condition> を参照)
;;
;;@param condition0 
;;@param condition1 
;;@param ... 

;;;;;
;;@type Function
;;@name condition-ref
;;@description [SRFI-35]
;;condition のフィールド field-name の値を検索します。
;;condition が合成コンディションであれば、元のコンディションの
;;フィールドにアクセスできます。もし、複数の元のコンディションが、
;;field-name を持つ場合には、最初に make-compound-condition
;;に渡されたものが優先されます。
;;
;;コンディションのフィールドにアクセスするには、slot-ref および
;;ref の両方あるいはどちらかを使えます。合成コンディションでは、
;;slot-missing メソッドが定義されますので、slot-ref は
;;あたかも、合成コンディションが元になったコンディションの全てのスロットを
;;もつかのように振舞います。しかしながら、condition-ref を
;;使う方が可搬性が増します。
;;
;;@param condition 
;;@param field-name 

;;;;;
;;@type Function
;;@name condition-has-type?
;;@description [SRFI-35]
;;obj がコンディションタイプ type に属している場合で、その
;;場合にかぎり、#t を返します。合成コンディションがあるので、
;;これは、is-a? と同じではありません
;;
;;@param obj 
;;@param type 

;;;;;
;;@type Function
;;@name condition?
;;@description [SRFI-35]
;;obj がコンディションである場合で、その場合にかぎり、
;;#t を返します。Gauche では (is-a? obj <condition>) と
;;同じです。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name make-condition
;;@description [SRFI-35]
;;コンディションタイプ type のコンディションを生成し、
;;field-name および value のペアで指定されたように
;;フィールドを初期化します。
;;
;;@param type 
;;@param field-name 
;;@param value 
;;@param ... 

;;;;;
;;@type Function
;;@name make-condition-type
;;@description [SRFI-35]
;;新しいコンディションタイプを生成する手続き版です。
;;
;;@param name 
;;@param parent 
;;@param field-names 

;;;;;
;;@type Function
;;@name condition-type?
;;@description [SRFI-35]
;;objがコンディションタイプである場合で、その場合にかぎり、
;;#t を返します。Gauche では (is-a? obj <condition-meta>)
;;と同じです。
;;
;;@param obj 

;;;;;
;;@type Macro
;;@name define-condition-type
;;@description [SRFI-35+]
;;新しいコンディションタイプを定義します。Gaucheでは、コンディションタイプは
;;クラスであり、そのメタクラスは <condition-meta> です。
;;
;;name が新しいタイプの名前になり、この名前の変数が作成された
;;コンディションタイプに束縛されます。supertype はこのコンディション
;;タイプのスーパータイプ(直接のスーパークラス)の名前です。コンディション
;;タイプは <condition> を継承するか、その子孫を継承しなければ
;;なりません。(この形式では、多重継承を指定することはできません。
;;一般的にいって、コンディションタイプの階層の中では多重継承は避ける
;;べきです。そのかわりに、合成コンディションを使えます。合成コンディションは
;;多重継承を使いません。)
;;
;;変数 predicate はこのコンディションタイプ用の述語手続きに
;;束縛されます。
;;
;;各 field-spec は (field-name accessor-name) の形式で
;;このコンディションは、フィールド名は field-name で決まります。
;;変数 accessor-name はそのフィールドにアクセスする手続きに
;;束縛されます。Gauche では、それぞれのフィールドは生成された
;;クラスのスロットとなります。
;;
;;Gaucheはsrfi-35を拡張して、predicateやaccessor-nameを
;;定義する必要が無い場合はその位置に#fを指定できるようにしています。
;;accessor-nameが必要無い場合はそれを省略することもできます。
;;
;;define-condition-typeがクラス定義に展開される際に、
;;各スロットは:init-keywordスロットオプションにスロット名と
;;同名のキーワードを取るように定義されます。
;;
;;@param name 
;;@param supertype 
;;@param predicate 
;;@param field-spec 
;;@param ... 

;;;;;
;;@type Class
;;@name <io-unit-error>
;;@description 対象となるポートでサポートされていない単位での読み/書き要求
;;(たとえば、キャラクタ専用ポートでのバイナリ I/O 要求)の際の I/O エラー。
;;<port-error> を継承しています。
;;

;;;;;
;;@type Class
;;@name <io-closed-error>
;;@description [SRFI-36]
;;クローズされたポートで読み込み/書き出しをしようしたときの I/O エラー。
;;<port-error> を継承しています。
;;

;;;;;
;;@type Class
;;@name <io-write-error>
;;@description [SRFI-36]
;;ポートへの書き出し中の I/O エラー。<port-error> を継承しています。
;;

;;;;;
;;@type Class
;;@name <io-read-error>
;;@description [SRFI-36]
;;ポートから読み込み中の I/O エラー。<port-error> を継承しています。
;;

;;;;;
;;@type Class
;;@name <port-error>
;;@description [SRFI-36]
;;ポート関連の I/O エラー。<io-error> を継承しています。
;;
;;エラーを起したポートを保持。
;;

;;;;;
;;@type Class
;;@name <io-error>
;;@description [SRFI-36]
;;I/O エラーのベースとなるクラス。<error> を継承しています。
;;

;;;;;
;;@type Class
;;@name &read-error
;;@description [SRFI-36]
;;<error> のサブクラス。リーダがS式を読み込み中に、字句エラー
;;または構文エラーを検出したとき、この型のコンディションが投げられます。
;;
;;
;;
;;
;;
;;@slot port リーダがS式を読みこんでいたポート。
;;(註: SRFI-36 の &read-error はこのスロットを定義していません。
;;ポータブルなプログラムを書く場合はこのスロットを使わないで下さい)。
;;
;;@slot line リーダがこのエラーを発生させたときの入力行カウント(1がベース)。
;;リーダが行カウントを保持しないポートから読み込むときには、-1 となる。
;;
;;@slot column @defivarx {<read-error>} position
;;@defivarx {<read-error>} span
;;これらのスロットは、SRFI-36 の &read-error で定義されています。
;;今のところ、これらのスロットは常に #f を保持するようになっています。
;;

;;;;;
;;@type Class
;;@name <read-error>
;;@description [SRFI-36]
;;<error> のサブクラス。リーダがS式を読み込み中に、字句エラー
;;または構文エラーを検出したとき、この型のコンディションが投げられます。
;;
;;
;;
;;
;;
;;@slot port リーダがS式を読みこんでいたポート。
;;(註: SRFI-36 の &read-error はこのスロットを定義していません。
;;ポータブルなプログラムを書く場合はこのスロットを使わないで下さい)。
;;
;;@slot line リーダがこのエラーを発生させたときの入力行カウント(1がベース)。
;;リーダが行カウントを保持しないポートから読み込むときには、-1 となる。
;;
;;@slot column @defivarx {<read-error>} position
;;@defivarx {<read-error>} span
;;これらのスロットは、SRFI-36 の &read-error で定義されています。
;;今のところ、これらのスロットは常に #f を保持するようになっています。
;;

;;;;;
;;@type Class
;;@name <unhandled-signal-error>
;;@description <error>のサブクラス。多くのシグナルのデフォルトハンドラは
;;このコンディションを投げます。詳しくはHandling signalsを
;;参照してください。
;;
;;@slot signal 受け取ったシグナル番号を示す整数値。典型的なシグナル番号については
;;定数が定義されています。Signals and signal setsを参照のこと。
;;

;;;;;
;;@type Class
;;@name <system-error>
;;@description <error> のサブクラス。
;;システムコールがエラーを返したとき、この型の例外が投げられます。
;;message スロットには通常エラーの(strerror(3)のような)説明が
;;含まれています。それ以外に、このクラスにはもうひとつ次のような
;;インスタンススロットがあります。
;;
;;
;;このクラスには対応する SRFI のコンディションタイプがありませんが、
;;OSの生のエラーコードを取得するのに重要です。いくつかのケースで
;;このタイプのコンディションは他の、たとえば <io-read-error>
;;のようなコンディションと合成されます。
;;
;;@slot errno システムのエラー番号の整数値を持ちます。
;;
;;エラー番号はシステムによって異なる可能性があります。Gaucheは典型的な
;;Unixのエラー番号に対して定数を定義している(例: EACCES, EBADF)ので、
;;それを使うと良いでしょう。定義されている定数に関しては
;;System inquiryのsys-strerrorの説明を参照してください。
;;

;;;;;
;;@type Class
;;@name &error
;;@description [SRFI-35]
;;エラーを表します。<serious-condition> および
;;<message-condition> を継承しています。したがって、
;;message スロットを持っています。
;;
;;注意事項: SRFI-35 の&errorコンディションは &serious
;;のみを継承し、&message は継承していません。したがって、
;;このエラーコンディションにメッセージを付与するためには、
;;合成コンディションを使わなければなりません。Gauche は
;;主として過去のバージョンとの互換性を確保するために、
;;ここで多重継承を用いています。
;;可搬性のあるコードを書くには、以下のようにメッセージコンディション
;;付きのエラーコンディションを使うべきです。
;;
;;example:
;;  (condition
;;    (&message (message "Error message"))
;;    (&error))
;;

;;;;;
;;@type Class
;;@name <error>
;;@description [SRFI-35]
;;エラーを表します。<serious-condition> および
;;<message-condition> を継承しています。したがって、
;;message スロットを持っています。
;;
;;注意事項: SRFI-35 の&errorコンディションは &serious
;;のみを継承し、&message は継承していません。したがって、
;;このエラーコンディションにメッセージを付与するためには、
;;合成コンディションを使わなければなりません。Gauche は
;;主として過去のバージョンとの互換性を確保するために、
;;ここで多重継承を用いています。
;;可搬性のあるコードを書くには、以下のようにメッセージコンディション
;;付きのエラーコンディションを使うべきです。
;;
;;example:
;;  (condition
;;    (&message (message "Error message"))
;;    (&error))
;;

;;;;;
;;@type Class
;;@name &message
;;@description [SRFI-35]
;;このクラスはメッセージ付のコンディションを表現し、スロットを一つ
;;もっています。
;;
;;
;;@slot message メッセージ
;;
;;

;;;;;
;;@type Class
;;@name <message-condition>
;;@description [SRFI-35]
;;このクラスはメッセージ付のコンディションを表現し、スロットを一つ
;;もっています。
;;
;;
;;@slot message メッセージ
;;
;;

;;;;;
;;@type Class
;;@name <serious-compound-condition>
;;@description 深刻なコンディションを含む合成コンディションを表現するための
;;内部クラスです。<compound-condition> および
;;<serious-condition> の両方を継承しています。
;;make-compound-condition は深刻なコンディションを含む複数の
;;コンディションを渡されると、このクラスを使います。このクラスを
;;直接使ってはいけません。
;;

;;;;;
;;@type Class
;;@name &serious
;;@description [SRFI-35]
;;このクラスのコンディションは無視して先を続けることはできない深刻な
;;状況のためにあります。特に、このタイプのコンディションを raise
;;したら、それは元には絶対に戻らないと考えて問題ありません。
;;

;;;;;
;;@type Class
;;@name <serious-condition>
;;@description [SRFI-35]
;;このクラスのコンディションは無視して先を続けることはできない深刻な
;;状況のためにあります。特に、このタイプのコンディションを raise
;;したら、それは元には絶対に戻らないと考えて問題ありません。
;;

;;;;;
;;@type Class
;;@name <compound-condition>
;;@description 合成コンディションを表現します。合成コンディションは
;;make-compound-condition を用いて1つ以上のコンディションから
;;生成することができます。このクラスを直接使ってはいけません。
;;
;;合成コンディションはcondition-has-type? に対して、
;;元のコンディションのどれかが、与えられたタイプなら、#t を返します。
;;

;;;;;
;;@type Class
;;@name &condition
;;@description [SRFI-35]
;;コンディションの階層のルートクラスです。
;;

;;;;;
;;@type Class
;;@name <condition>
;;@description [SRFI-35]
;;コンディションの階層のルートクラスです。
;;

;;;;;
;;@type Class
;;@name <condition-meta>
;;@description すべてのコンディションクラスはこのクラスのインスタンスです。
;;このクラスは object-apply を定義していますので、
;;コンディションクラスは述語として使うことができます。たとえば、
;;
;;example:
;;  (<error> obj) ≡  (condition-has-type? obj <error>)
;;

;;;;;
;;@type Function
;;@name with-exception-handler
;;@description [SRFI-18]
;;handlerは1引数を取る手続きです。この手続きは、handlerを
;;現在の例外ハンドラにセットし、thunkを呼び出します。
;;
;;@param handler 
;;@param thunk 

;;;;;
;;@type Function
;;@name current-exception-handler
;;@description [SRFI-18]
;;現在の例外ハンドラを返します。
;;

;;;;;
;;@type Function
;;@name with-error-handler
;;@description handlerをアクティブなエラーハンドラにし、thunkを実行します。
;;thunkが正常に戻ったら、その結果が返されます。
;;thunkの実行中にエラーが通知されたら、エラーを表す例外オブジェクトを
;;1引数とするhandlerが、with-error-handlerの継続とともに呼ばれます。
;;すなわち、with-error-handlerは、handlerが返す値を返します。
;;
;;handlerがエラーを通知したら、それはwith-error-handlerが
;;呼ばれたときにインストールされていたハンドラにより処理されます。
;;
;;handlerが実行される場合の動的な環境は、エラーが起きたときのそれと
;;同じです。thunk内でdynamic-windが使われていたら、
;;そのafterメソッドはhandlerが戻った後、かつwith-error-handlerが
;;戻る前に呼ばれます。
;;
;;註: この手続きを直接使うことはもはや推奨されません。guardの方が
;;より安全でポータブルだからです。互換性を保つためまだしばらくは
;;この手続きを残しますが、この手続きを使っているコードをguardによって
;;書き直すことを推奨します。「エラー時に後始末をする」というよくある次のような処理は：
;;example:
;;  (with-error-handler (lambda (e) (cleanup) (raise e))
;;    (lambda () body ...))
;;次のように書き直すことができます。
;;example:
;;  (guard (e (else (cleanup) (raise e)))
;;    body ...)
;;
;;@param handler 
;;@param thunk 

;;;;;
;;@type Macro
;;@name unwind-protect
;;@description bodyを実行してからcleanupを実行し、bodyの結果を返す。
;;body内で例外が挙がった場合、その例外がunwind-protectフォー
;;ムを抜ける前に、cleanupが実行されます。たとえば、以下のコードで
;;はなにも問題が起きなければ、start-motor、drill-a-hole、
;;stop-motorが、この順で呼ばれます。何か不具合が
;;start-motorあるいはdrill-a-holeで起った場合でも、例外が
;;unwind-protectを抜ける前にstop-motorが呼ばれます。
;;
;;example:
;;  (unwind-protect
;;    (begin (start-motor)
;;           (drill-a-hole))
;;    (stop-motor))
;;
;;cleanupフォームはunwind-protectと同じ動的環境で評価されま
;;す。例外がcleanup内で投げられた場合その例外は、
;;unwind-protectフォームの外側で処理されることになります。
;;
;;このフォームはdynamic-windと似ていますが、この2つは動作するレイ
;;ヤが違いますので混同しないようにしてください。
;;dynamic-windは最下位レイヤのもので、現在の例外ハンドラ、現在の入出力
;;ポート、パラメータなどを管理するのに用います。
;;dynamic-windのbeforeおよびafterのサンクは
;;対応する制御フローの遷移が起きたときに必ず呼ばれます。
;;一方、unwind-protectはGaucheの例外システムの面倒しか見ません。
;;unwind-protectのcleanupはbodyが正常終了するか
;;Gaucheの例外を投げたときにのみ呼びだされます。上述の例で、unwind-protectの外側で
;;補足された継続が呼ばれ、制御がdrill-a-holeを抜けると、
;;cleanupは呼ばれません。制御が再びdrill-a-holeに戻る可能性
;;があるからです。たとえば、ユーザレベルのスレッドシステムが
;;call/ccで実装されているような場合にこのようなことが起こる可能性
;;があります。
;;
;;このフォームの名前はCommon Lispから取りました。同様のマクロに
;;try-finallyというような別の名前を使っているSchemeの処理系もあります。
;;
;;@param body 
;;@param cleanup 

;;;;;
;;@type Macro
;;@name guard
;;@description [SRFI-34]
;;これはGaucheでのエラー処理の高水準フォームです。
;;
;;var はシンボルで clause は cond 節と同じ形式です。
;;つまり、各節は以下の形式のどれかひとつです。
;;(test expr ...)
;;(test => proc)
;;
;;最後のclauseは(else expr ...)という形式も許されます。
;;
;;このフォームは通常の場合には body ... を評価し最後の
;;body の式の値を返します。本体の式を評価している最中に例外が
;;発生した場合、発生した例外を変数 var に束縛し、その後
;;各節の test 式を評価します。もし、test 式のひとつが
;;真値を返したとき、その節が上述の最初の形式であれば、対応する
;;expr が評価されます。あるいは、節が二番目の形式であれば、
;;手続きprocにtestの結果が渡されます。
;;
;;指定された節の test および expr が評価されるとき、
;;guardを呼び出した時点での例外ハンドラが設定されます。つまり、
;;clause 内部で再び例外が発生した場合、その例外は、外側の
;;例外ハンドラまたは guard フォームで処理されます。
;;
;;もし、どの test も真値を返さず、最後の clause が
;;else 節であれば、それに結びつけられた expr が評価されます。
;;もし、どの test も真値を返さず、else 節がなければ、再び
;;例外が発生し、外側の例外ハンドラで処理されます。
;;
;;例外が clause のどれかで処理された時には、guard は
;;それを処理した節の最後の expr の値を返します。
;;
;;clauseはguardと同じ動的環境で評価されます。すなわち、
;;body中のdynamic-windはclauseの評価の前に
;;巻戻されます。これは低レベル関数のwith-error-handlerや
;;with-exception-handlerとは異なることに注意してください。
;;これら低レベル関数では例外ハンドラが呼ばれてから動的環境が巻戻されます。
;;
;;example:
;;  (let ((z '()))
;;    (guard (e (else (push! z 'caught)))
;;      (dynamic-wind (lambda () (push! z 'pre))
;;                    (lambda () (error "foo"))
;;                    (lambda () (push! z 'post))))
;;    (reverse z))
;;   ==> (pre post caught)
;;  
;;  (guard (e (else (print 'OUTER) #f))
;;    (with-output-to-string ()
;;      (print 'INNER)
;;      (error "foo")))
;;   ==> OUTERを文字列ポートではなくguard実行時の
;;        current-output-portに出力。
;;
;;@param (var clause 
;;@param ...) body ... 

;;;;;
;;@type Function
;;@name raise
;;@description [SRFI-18]
;;これは、例外事態を通知する基本となるメカニズムです。
;;
;;この手続きは現在の例外ハンドラを呼び出します。引数conditionは
;;例外の性質を表現するのに使われ、例外ハンドラに渡されます。
;;Gaucheの組み込み手続きやライブラリ手続きは常に、<condition>クラス
;;もしくはそのサブクラスのインスタンスをconditionとして用いますが、
;;ユーザは任意のオブジェクトをraiseに渡すこともできます。
;;渡されたconditionの解釈は例外ハンドラに任されます。
;;
;;注意事項: いくつかの主流の言語では、例外を「投げる」と制御はそこに
;;戻りません。Gaucheではraiseから戻って来れるように
;;セットアップすることが可能です。詳細はHandling exceptionsを
;;参照してください。
;;
;;raiseから戻って来ることが無いようにしたい場合は、
;;<serious-condition>やそのサブクラスのインスタンスをcondition
;;としてraiseに渡すのが確実です。
;;組み込みコンディションのクラス階層についてはConditionsを参照して下さい。
;;
;;@param condition 

;;;;;
;;@type Function
;;@name errorf
;;@description errorに似ていますが、エラーメッセージはformatによりフォーマット
;;されます。すなわち、最初のフォームは以下と等価です。
;;example:
;;  (define (errorf fmt . args)
;;    (error (apply format #f fmt args)))
;;
;;2番目の形式は<error>以外のエラーコンディションを通知するのに
;;使えます。condition-type, keyword-argの意味については
;;errorと同じです。
;;
;;@param condition-type 
;;@param keyword-arg 
;;@param ... 
;;@param fmt-string 
;;@param arg 
;;@param ... 

;;;;;
;;@type Function
;;@name errorf
;;@description errorに似ていますが、エラーメッセージはformatによりフォーマット
;;されます。すなわち、最初のフォームは以下と等価です。
;;example:
;;  (define (errorf fmt . args)
;;    (error (apply format #f fmt args)))
;;
;;2番目の形式は<error>以外のエラーコンディションを通知するのに
;;使えます。condition-type, keyword-argの意味については
;;errorと同じです。
;;
;;@param fmt-string 
;;@param arg 
;;@param ... 

;;;;;
;;@type Function
;;@name error
;;@description [SRFI-23+] エラーを通知します。最初の形式は、
;;stringとarg ...からなるメッセージを持つ
;;<error>コンディションを作成それをraiseします。
;;この形式はsrfi-23のerrorと互換です。
;;
;;example:
;;  gosh> (define (check-integer x)
;;          (unless (integer? x)
;;             (error "Integer required, but got:" x)))
;;  check-integer
;;  gosh> (check-integer "a")
;;  *** ERROR: Integer required, but got: "a"
;;  Stack Trace:
;;  _______________________________________
;;
;;2番目の形式は<error>以外のエラーコンディションを通知したいときに
;;使います。condition-typeはコンディションタイプ
;;でなければなりません (コンディションタイプについてはConditionsを
;;参照して下さい)。その後に、キーワードと値のリストを与えることで
;;コンディションのスロットを初期化することができます。また、その後に
;;メッセージを構成する文字列と他のオブジェクトのリストを与えることができます。
;;
;;example:
;;  (define-condition-type <my-error> <error> #f
;;    (reason)
;;    (priority))
;;  
;;  ...
;;    (unless (memq operation *supported-operations*)
;;      (error <my-error> 
;;             :reason 'not-supported :priority 'urgent
;;             "Operation not supported:" operation))
;;  ...
;;
;;@param condition-type 
;;@param keyword-arg 
;;@param ... 
;;@param string 
;;@param arg 
;;@param ... 

;;;;;
;;@type Function
;;@name error
;;@description [SRFI-23+] エラーを通知します。最初の形式は、
;;stringとarg ...からなるメッセージを持つ
;;<error>コンディションを作成それをraiseします。
;;この形式はsrfi-23のerrorと互換です。
;;
;;example:
;;  gosh> (define (check-integer x)
;;          (unless (integer? x)
;;             (error "Integer required, but got:" x)))
;;  check-integer
;;  gosh> (check-integer "a")
;;  *** ERROR: Integer required, but got: "a"
;;  Stack Trace:
;;  _______________________________________
;;
;;2番目の形式は<error>以外のエラーコンディションを通知したいときに
;;使います。condition-typeはコンディションタイプ
;;でなければなりません (コンディションタイプについてはConditionsを
;;参照して下さい)。その後に、キーワードと値のリストを与えることで
;;コンディションのスロットを初期化することができます。また、その後に
;;メッセージを構成する文字列と他のオブジェクトのリストを与えることができます。
;;
;;example:
;;  (define-condition-type <my-error> <error> #f
;;    (reason)
;;    (priority))
;;  
;;  ...
;;    (unless (memq operation *supported-operations*)
;;      (error <my-error> 
;;             :reason 'not-supported :priority 'urgent
;;             "Operation not supported:" operation))
;;  ...
;;
;;@param string 
;;@param arg 
;;@param ... 

;;;;;
;;@type Function
;;@name promise?
;;@description objがプロミスオブジェクトである場合に
;;#tを返します。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name lazy
;;@description [SRFI-45][R5RS]
;;これらの形式はexpressionの評価を遅延するプロミスを生成し
;;ます。Expression はこのプロミスがforceにわたったときに評
;;価されます。
;;
;;expression自身がプロミスを評価するようになっている場合には、
;;lazyを使うべきです。そうでなければ、delayを使うべきです。
;;型で考えればその違いは明白でしょう。
;;
;;example:
;;  lazy  : Promise a -> Promise a
;;  delay : a -> Promise a
;;
;;Schemeでは静的な型付けをしないので、この使い分けを強制することができま
;;せん。文脈にしたがってプログラマが適切に選択する必要があります。一般的
;;にはlazyは遅延アルゴリズムを表現している関数本体全体を囲む場合
;;にのみ出現します。
;;
;;lazyの実用的な使用例についてはutil.stream
;;(Stream library)の実装をチェックするといいでしょう。
;;
;;@param expression 

;;;;;
;;@type Macro
;;@name values-ref
;;@description mv-exprが返す多値のk-番目の値を返します。概念としては、
;;以下のコードと同じです。
;;example:
;;  (call-with-values (lambda () mv-expr) (lambda r (list-ref r k)))
;;このマクロは k がゼロであるような典型的な場合にはより単純な形へと
;;展開されます。
;;
;;Common Lisp の nth-value に似ていますが、引数の順が逆になっています。
;;Scheme の他の*-ref 手続きと合わせるためです。
;;
;;@param mv-expr 
;;@param k 

;;;;;
;;@type Macro
;;@name let/cc
;;@description このマクロは次のように展開されます :
;;(call/cc (lambda (var) body ...)).
;;APIはPLT Schemeから取りました。
;;
;;@param var 
;;@param body 
;;@param ... 

;;;;;
;;@type Method
;;@name object-apply
;;@description 手続きでもジェネリックファンクションでもないオブジェクトが何らかの引数に
;;適用されたとき、そのオブジェクトと引数がジェネリックファンクションobject-apply
;;に渡されます。
;;
;;この機能は、具体的な例を挙げた方が説明し易いでしょう。
;;
;;@param object 
;;@param arg 
;;@param ... 

;;;;;
;;@type Function
;;@name procedure-arity-includes?
;;@description 手続きprocが引数kを取れる場合、#tを返します。
;;そうでなければ#fを返します。
;;
;;@param proc 
;;@param k 

;;;;;
;;@type Function
;;@name arity-at-least-value
;;@description arity-at-leastオブジェクトが表す必須引数の数を返します。
;;
;;@param arity-at-least 

;;;;;
;;@type Function
;;@name arity-at-least?
;;@description objがarity-at-leastオブジェクトなら、真を返します。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name arity
;;@description 手続きprocを与え、整数、arity-at-leastオブジェクト、
;;整数とarity-at-leastオブジェクトからなるリストのいずれかを
;;返します。
;;
;;整数の戻り値は、procが正確にその数の引数を取ることを表します。
;;arity-at-leastは、procが最低でも
;;引数(arity-at-least-value arity-at-least)を取ることを
;;表します。リストは、異なるアリティを持つ複数の手続きがあることを
;;表します。
;;
;;Gaucheではいつでも、既存の手続きやジェネリック関数にメソッドを追加
;;できるので、arityが返す値はその手続きの現在の状態を示すに
;;過ぎません。その手続きやジェネリック関数に新しいメソッドが追加
;;されると、それも変更されます。
;;
;;example:
;;  (arity cons) ==> 2
;;  (arity list) ==> #<arity-at-least 0>
;;  (arity make) ==> (#<arity-at-least 1>)
;;
;;@param proc 

;;;;;
;;@type Macro
;;@name let-keywords*
;;@description このマクロはlet-keywordsとほぼ同じですが、束縛がvar-specでの
;;順番に行われるところが異なります。exprは以前のvar-specにより
;;束縛された変数を参照できます。
;;
;;@param restarg 
;;@param (var-spec ... 
;;@param . 
;;@param restvar) body ... 

;;;;;
;;@type Macro
;;@name let-keywords*
;;@description このマクロはlet-keywordsとほぼ同じですが、束縛がvar-specでの
;;順番に行われるところが異なります。exprは以前のvar-specにより
;;束縛された変数を参照できます。
;;
;;@param restarg 
;;@param (var-spec ...) body ... 

;;;;;
;;@type Macro
;;@name let-keywords
;;@description このマクロはキーワード引数のためのものです。var-specは
;;以下のフォームのうちのいずれかです。
;;
;;(symbol expr) ------
;;  restargがsymbolと同じ名前を持つキーワードを含んでいる場合、
;;  symbolを対応する値に束縛します。そのようなキーワードがrestargに
;;  ない場合は、symbolをexprの結果に束縛します。
;;(symbol keyword expr) ------
;;  restargがキーワードkeywordを含む場合、
;;  symbolを対応する値に束縛します。そのようなキーワードがrestargに
;;  ない場合、symbolをexprの結果に束縛します。
;;
;;デフォルト値exprは、restargにキーワードが与えられてなかった
;;場合にのみ評価されます。
;;
;;1番目のフォームでは、var-specにないキーワード引数がrestargに
;;現れるとエラーとなります。
;;他のキーワード引数を許したい場合は次の2番目のフォームを使ってください。
;;
;;2番目のフォームでは、restvarはシンボルか#fでなければなりません。
;;シンボルのときは、var-specに束縛されなかったrestargsのキーワード
;;リストがrestvarに束縛されます。#fのときは、それらのrestargs
;;のキーワードは単に無視されます。
;;
;;example:
;;  (define (proc x . options)
;;    (let-keywords options ((a 'a)
;;                           (b :beta 'b)
;;                           (c 'c)
;;                           . rest)
;;      (list x a b c rest)))
;;  
;;  (proc 0)         ==> (0 a b c ())
;;  (proc 0 :a 1)    ==> (0 1 b c ())
;;  (proc 0 :beta 1) ==> (0 a 1 c ())
;;  (proc 0 :beta 1 :c 3 :unknown 4) ==> (0 a 1 3 (:unknown 4))
;;
;;@param restarg 
;;@param (var-spec ... 
;;@param . 
;;@param restvar) body ... 

;;;;;
;;@type Macro
;;@name let-keywords
;;@description このマクロはキーワード引数のためのものです。var-specは
;;以下のフォームのうちのいずれかです。
;;
;;(symbol expr) ------
;;  restargがsymbolと同じ名前を持つキーワードを含んでいる場合、
;;  symbolを対応する値に束縛します。そのようなキーワードがrestargに
;;  ない場合は、symbolをexprの結果に束縛します。
;;(symbol keyword expr) ------
;;  restargがキーワードkeywordを含む場合、
;;  symbolを対応する値に束縛します。そのようなキーワードがrestargに
;;  ない場合、symbolをexprの結果に束縛します。
;;
;;デフォルト値exprは、restargにキーワードが与えられてなかった
;;場合にのみ評価されます。
;;
;;1番目のフォームでは、var-specにないキーワード引数がrestargに
;;現れるとエラーとなります。
;;他のキーワード引数を許したい場合は次の2番目のフォームを使ってください。
;;
;;2番目のフォームでは、restvarはシンボルか#fでなければなりません。
;;シンボルのときは、var-specに束縛されなかったrestargsのキーワード
;;リストがrestvarに束縛されます。#fのときは、それらのrestargs
;;のキーワードは単に無視されます。
;;
;;example:
;;  (define (proc x . options)
;;    (let-keywords options ((a 'a)
;;                           (b :beta 'b)
;;                           (c 'c)
;;                           . rest)
;;      (list x a b c rest)))
;;  
;;  (proc 0)         ==> (0 a b c ())
;;  (proc 0 :a 1)    ==> (0 1 b c ())
;;  (proc 0 :beta 1) ==> (0 a 1 c ())
;;  (proc 0 :beta 1 :c 3 :unknown 4) ==> (0 a 1 3 (:unknown 4))
;;
;;@param restarg 
;;@param (var-spec ...) body ... 

;;;;;
;;@type Macro
;;@name get-optional
;;@description これはlet-optionals*の短いバージョンで、オプショナル引数が
;;1つしかないときに使います。オプショナル引数のリストとしてrestargsが
;;与えらると、このマクロはオプショナル引数が与えられていればその値を返し、
;;そうでなければdefaultの結果を返します。defaultはrestargsが
;;空リストでなければ評価されません。
;;
;;example:
;;  (define (proc x . maybe-opt)
;;    (let ((option (get-optional maybe-opt #f)))
;;      (list x option)))
;;  
;;  (proc 0)         ==> (0 #f)
;;  (proc 0 1)       ==> (0 1)
;;
;;@param restargs 
;;@param default 

;;;;;
;;@type Macro
;;@name let-optionals*
;;@description 与えられた値のリストrestargsを、var-specにしたがって
;;変数に束縛し、bodyを評価します。
;;
;;var-specはシンボルか、そのcarがシンボルである2要素のリストの
;;いずれかです。シンボルは束縛された変数名です。
;;restargsにある値は、順番にシンボルに束縛されます。
;;restargsにvar-specに示される数の値がない場合は、
;;残りのsymbolは以下に従ってデフォルト値が束縛されます。
;;var-specが単なるシンボルなら、デフォルト値は未定義です。
;;var-specがリストなら、デフォルト値はリストの2番目の要素を
;;評価した結果です。後者の場合、2番目の要素は十分な引数がない場合にのみ
;;評価されます。
;;束縛はvar-specの順番にしたがって行われるので、2番目の要素は
;;以前のvar-specのバインディングを参照するかも知れません。
;;
;;2番目のフォームでは、restvarはシンボルでなければならず、
;;var-specに束縛された後、restargsに残っている値のリストに
;;束縛されます。
;;
;;restargがvar-specよりも多い値を持っていてもエラーでは
;;ありません。最初のフォームでは、余分な値は単に無視されます。
;;
;;example:
;;  (define (proc x . args)
;;    (let-optionals* args ((a 'a)
;;                          (b 'b)
;;                          (c 'c))
;;      (list x a b c)))
;;  
;;  (proc 0)         ==> (0 a b c)
;;  (proc 0 1)       ==> (0 1 b c)
;;  (proc 0 1 2)     ==> (0 1 2 c)
;;  (proc 0 1 2 3)   ==> (0 1 2 3)
;;  
;;  (define (proc2 . args)
;;    (let-optionals* args ((a 'a) . b)
;;      (list a b)))
;;  
;;  (proc2)          ==> (a ())
;;  (proc2 0)        ==> (0 ())
;;  (proc2 0 1)      ==> (0 (1))
;;  (proc2 0 1 2)    ==> (0 (1 2))
;;  
;;  (define (proc3 . args)
;;    (let-optionals* args ((a 0)
;;                          (b (+ a 1))
;;                          (c (+ b 1)))
;;      (list a b c)))
;;  
;;  (proc3)          ==> (0 1 2)
;;  (proc3 8)        ==> (8 9 10)
;;  (proc3 8 2)      ==> (8 2 3)
;;  (proc3 8 2 -1)   ==> (8 2 -1)
;;
;;@param restargs 
;;@param (var-spec ... 
;;@param . 
;;@param restvar) body ... 

;;;;;
;;@type Macro
;;@name let-optionals*
;;@description 与えられた値のリストrestargsを、var-specにしたがって
;;変数に束縛し、bodyを評価します。
;;
;;var-specはシンボルか、そのcarがシンボルである2要素のリストの
;;いずれかです。シンボルは束縛された変数名です。
;;restargsにある値は、順番にシンボルに束縛されます。
;;restargsにvar-specに示される数の値がない場合は、
;;残りのsymbolは以下に従ってデフォルト値が束縛されます。
;;var-specが単なるシンボルなら、デフォルト値は未定義です。
;;var-specがリストなら、デフォルト値はリストの2番目の要素を
;;評価した結果です。後者の場合、2番目の要素は十分な引数がない場合にのみ
;;評価されます。
;;束縛はvar-specの順番にしたがって行われるので、2番目の要素は
;;以前のvar-specのバインディングを参照するかも知れません。
;;
;;2番目のフォームでは、restvarはシンボルでなければならず、
;;var-specに束縛された後、restargsに残っている値のリストに
;;束縛されます。
;;
;;restargがvar-specよりも多い値を持っていてもエラーでは
;;ありません。最初のフォームでは、余分な値は単に無視されます。
;;
;;example:
;;  (define (proc x . args)
;;    (let-optionals* args ((a 'a)
;;                          (b 'b)
;;                          (c 'c))
;;      (list x a b c)))
;;  
;;  (proc 0)         ==> (0 a b c)
;;  (proc 0 1)       ==> (0 1 b c)
;;  (proc 0 1 2)     ==> (0 1 2 c)
;;  (proc 0 1 2 3)   ==> (0 1 2 3)
;;  
;;  (define (proc2 . args)
;;    (let-optionals* args ((a 'a) . b)
;;      (list a b)))
;;  
;;  (proc2)          ==> (a ())
;;  (proc2 0)        ==> (0 ())
;;  (proc2 0 1)      ==> (0 (1))
;;  (proc2 0 1 2)    ==> (0 (1 2))
;;  
;;  (define (proc3 . args)
;;    (let-optionals* args ((a 0)
;;                          (b (+ a 1))
;;                          (c (+ b 1)))
;;      (list a b c)))
;;  
;;  (proc3)          ==> (0 1 2)
;;  (proc3 8)        ==> (8 9 10)
;;  (proc3 8 2)      ==> (8 2 3)
;;  (proc3 8 2 -1)   ==> (8 2 -1)
;;
;;@param restargs 
;;@param (var-spec ...) body ... 

;;;;;
;;@type Function
;;@name every-pred
;;@description 与えられた引数をそれぞれ述語predに適用する手続きを返します。
;;全てのpredが#fでない値を返す場合、戻り値は最後の
;;predの戻り値になります。いずれかのpredが#fを
;;返す場合、every-predはそれ以降のpredを呼び出さずに
;;#fを返します。
;;
;;example:
;;  ((every-pred odd? positive?) 3)  ==> #t
;;  ((every-pred odd? positive?) 4)  ==> #f
;;  ((every-pred odd? positive?) -3) ==> #f
;;  
;;  (define safe-length (every-pred list? length))
;;  (safe-length '(a b c))  ==> 3
;;  (safe-length "aaa")     ==> #f
;;
;;@param pred 
;;@param ... 

;;;;;
;;@type Function
;;@name any-pred
;;@description 与えられた引数をそれぞれ述語predに適用する手続きを返します。
;;いずれかのpredが#fでない値を返す場合、その値を返します。
;;全てのpredが#fを返す場合、#fを返します。
;;
;;example:
;;  (define string-or-symbol? (any-pred string? symbol?))
;;  (string-or-symbol? "abc") ==> #t
;;  (string-or-symbol? 'abc)  ==> #t
;;  (string-or-symbol? 3)     ==> #f
;;  
;;  (define <> (any-pred < >))
;;  (<> 3 4) ==> #t
;;  (<> 3 3) ==> #f
;;  
;;  ((any-pred (cut memq <> '(a b c))
;;             (cut memq <> '(1 2 3)))
;;   'b)  ==> '(b c)
;;
;;@param pred 
;;@param ... 

;;;;;
;;@type Function
;;@name complement
;;@description 述語predの意味を逆にした手続きを返します。すなわち、predが真を
;;返すような引数にたいして偽を返す、またその逆も同様であるような手続きです。
;;
;;example:
;;  (map (complement even?) '(1 2 3)) ==> '(#t #f #t)
;;  (map (complement =) '(1 2 3) '(1 1 3)) ==> '(#f #t #f)
;;  ((complement (lambda () #f))) ==> #t
;;
;;@param pred 

;;;;;
;;@type Function
;;@name compose
;;@description 複数の手続きを結合します。引数は全て手続きでなければなりません。
;;2つの引数が渡された時、(.$ f g)は次の式と等価です。
;;example:
;;  (lambda args (call-with-values (lambda () (apply g args)) f))
;;
;;2つ以上の引数が渡された場合は、次のように結合されます。
;;example:
;;  (.$ f g h ...) ≡  (.$ (.$ f g) h ...)
;;
;;いくつか例を示します。
;;
;;example:
;;  (define not-zero? (.$ not zero?))
;;  (not-zero? 3) ==> #t
;;  (not-zero? 0) ==> #f
;;  
;;  (define dot-product (.$ (apply$ +) (map$ *)))
;;  (dot-product '(1 2 3) '(4 5 6)) ==> 32
;;
;;境界のケース：ひとつだけ引数が渡された場合は、その引数がそのまま返されます。
;;引数が全く渡されなかった場合は手続きvaluesが返されます。
;;
;;註: .$という名前は、文献やいくつかの他のプログラミング言語で
;;.が関数合成によく使われること、そしてGaucheではコンビネータの末尾に
;;$をつける習慣があることから来ています。ただ、これはR5RS/R6RSの
;;範囲内では有効な識別子でないので、ポータビリティを考えるプログラムは
;;別名のcomposeを使った方が良いでしょう。そうすればsrfi-0などを
;;使って容易に移植が可能です。
;;
;;@param f 
;;@param ... 

;;;;;
;;@type Function
;;@name .$
;;@description 複数の手続きを結合します。引数は全て手続きでなければなりません。
;;2つの引数が渡された時、(.$ f g)は次の式と等価です。
;;example:
;;  (lambda args (call-with-values (lambda () (apply g args)) f))
;;
;;2つ以上の引数が渡された場合は、次のように結合されます。
;;example:
;;  (.$ f g h ...) ≡  (.$ (.$ f g) h ...)
;;
;;いくつか例を示します。
;;
;;example:
;;  (define not-zero? (.$ not zero?))
;;  (not-zero? 3) ==> #t
;;  (not-zero? 0) ==> #f
;;  
;;  (define dot-product (.$ (apply$ +) (map$ *)))
;;  (dot-product '(1 2 3) '(4 5 6)) ==> 32
;;
;;境界のケース：ひとつだけ引数が渡された場合は、その引数がそのまま返されます。
;;引数が全く渡されなかった場合は手続きvaluesが返されます。
;;
;;註: .$という名前は、文献やいくつかの他のプログラミング言語で
;;.が関数合成によく使われること、そしてGaucheではコンビネータの末尾に
;;$をつける習慣があることから来ています。ただ、これはR5RS/R6RSの
;;範囲内では有効な識別子でないので、ポータビリティを考えるプログラムは
;;別名のcomposeを使った方が良いでしょう。そうすればsrfi-0などを
;;使って容易に移植が可能です。
;;
;;@param f 
;;@param ... 

;;;;;
;;@type Function
;;@name assoc$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param item 

;;;;;
;;@type Function
;;@name delete$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param pred 

;;;;;
;;@type Function
;;@name every$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param pred 

;;;;;
;;@type Function
;;@name any$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param pred 

;;;;;
;;@type Function
;;@name find-tail$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param pred 

;;;;;
;;@type Function
;;@name find$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param pred 

;;;;;
;;@type Function
;;@name member$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param item 

;;;;;
;;@type Function
;;@name partition$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param pred 

;;;;;
;;@type Function
;;@name remove$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param pred 

;;;;;
;;@type Function
;;@name filter$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param pred 

;;;;;
;;@type Function
;;@name reduce-right$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param f 
;;@param :optional 
;;@param ridentity 

;;;;;
;;@type Function
;;@name reduce$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param f 
;;@param :optional 
;;@param ridentity 

;;;;;
;;@type Function
;;@name fold-right$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param kons 
;;@param :optional 
;;@param knil 

;;;;;
;;@type Function
;;@name fold$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param kons 
;;@param :optional 
;;@param knil 

;;;;;
;;@type Function
;;@name count$
;;@description SRFI-1(List library参照)の手続に対応する部分適用版手続。
;;
;;@param pred 

;;;;;
;;@type Function
;;@name for-each$
;;@description apply, mapとfor-eachの部分適用版です。
;;
;;example:
;;  (define map2* (map$ (pa$ * 2)))
;;  (map2* '(1 2 3)) ==> (2 4 6)
;;
;;
;;@param proc 

;;;;;
;;@type Function
;;@name map$
;;@description apply, mapとfor-eachの部分適用版です。
;;
;;example:
;;  (define map2* (map$ (pa$ * 2)))
;;  (map2* '(1 2 3)) ==> (2 4 6)
;;
;;
;;@param proc 

;;;;;
;;@type Function
;;@name apply$
;;@description apply, mapとfor-eachの部分適用版です。
;;
;;example:
;;  (define map2* (map$ (pa$ * 2)))
;;  (map2* '(1 2 3)) ==> (2 4 6)
;;
;;
;;@param proc 

;;;;;
;;@type Function
;;@name pa$
;;@description 部分適用。手続きを返します。その手続きが引数m ...を伴って
;;呼ばれた場合、それは(proc arg ... m ...)と等価になります。
;;
;;example:
;;  (define add3 (pa$ + 3))
;;  (add3 4) ==> 7
;;  
;;  (map (pa$ * 2) '(1 2 3)) ==> (2 4 6)
;;
;;SRFI-26で定義されているマクロcutとcuteも似たような抽象化の
;;方法を提供しますが、pa$より多少柔軟性が高く、その分やや冗長です。
;;Making Proceduresを参照して下さい。
;;
;;@param proc 
;;@param arg 
;;@param ... 

;;;;;
;;@type Function
;;@name map*
;;@description mapとほぼ同じですが、引数の最後のペアのcdrにtail-procが
;;適用され、その返り値が結果のリストの最後のペアのcdrになります。
;;この手続きは正規でないリストを引数に取ることができます。
;;引数のリストがひとつだけの場合、tail-procの引数は必ずペアでないオブジェクトです。
;;
;;example:
;;  (map* - / '(1 2 3 . 4)) ==> (-1 -2 -3 . 1/4)
;;  
;;  (define (proper lis)
;;    (map* values
;;          (lambda (p) (if (null? p) '() (list p)))
;;          lis))
;;  
;;  (proper '(1 2 3))     ==> (1 2 3)
;;  (proper '(1 2 3 . 4)) ==> (1 2 3 4)
;;
;;二つ以上のリストが与えられた場合は、最も短いリストがtail-procの呼び出しを
;;決めます。map*が最も短いリストの最後のペアに達した時点で、
;;その時のそれぞれのペアのcdrがtail-procへと渡されます。
;;
;;example:
;;  (map* + vector '(1 2 3 4) '(1 2 . 3))
;;    ==> (3 6 . #((3 4) 3))
;;
;;註: map*という名前は、正規でないリストを作り得るlist*/cons*からの
;;連想でつけられました
;;(List constructors、SRFI-1 List constructors参照)。
;;
;;@param proc 
;;@param tail-proc 
;;@param list1 
;;@param list2 
;;@param ... 

;;;;;
;;@type Function
;;@name ~
;;@description The procedure ~ can be used to access a part of various
;;aggregate types.
;;
;;example:
;;  ;; Access to an element of a sequence by index
;;  (~ '(a b c) 0)       ==> a
;;  (~ '#(a b c) 2)      ==> c
;;  (~ "abc" 1)          ==> #\b
;;  (~ '#u8(10 20 30) 1) ==> 20
;;  
;;  ;; Access to an element of a collection by key
;;  (~ (hash-table 'eq? '(a . 1) '(b . 2)) 'a)
;;    ==> 1
;;  
;;  ;; Access to a slot of an object by slot name
;;  (~ (sys-localtime (sys-time)) 'hour)
;;    ==> 20
;;
;;The access can be chained:
;;
;;example:
;;  (~ '#((a b c) (d e f) (g h i)) 1 2) ==> f
;;  
;;  (~ (hash-table 'eq? '(a . "abc") '(d . "def")) 'a 2)
;;    ==> #\c
;;
;;You can think ~ as left-associative, that is,
;;example:
;;  (~ x k j) ≡  (~ (~ x k) j)
;;and so on.
;;
;;The generalized setter set! can be used with ~ to
;;replace the specified element.
;;
;;example:
;;  (define z (vector 'a 'b 'c))
;;  (set! (~ z 1) 'Z)
;;  
;;  z ==> #(a Z c)
;;  
;;  (define z (vector (list (vector 'a 'b 'c)
;;                          (vector 'd 'e 'f)
;;                          (vector 'g 'h 'i))
;;                    (list (vector 'a 'b 'c)
;;                          (vector 'd 'e 'f)
;;                          (vector 'g 'h 'i))))
;;  
;;  z ==> #((#(a b c) #(d e f) #(g h i))
;;       (#(a b c) #(d e f) #(g h i)))
;;  
;;  (set! (~ z 1 2 0) 'Z)
;;  z ==>  #((#(a b c) #(d e f) #(g h i))
;;       (#(a b c) #(d e f) #(Z h i)))
;;
;;@param obj 
;;@param key 
;;@param keys 
;;@param ... 

;;;;;
;;@type Class
;;@name <procedure>

;;;;;
;;@type Function
;;@name weak-vector-set!
;;@description weak ベクタ wvecのk番目の要素をobjに変更します。
;;kが負数であったりベクタの長さより大きい場合はエラーとなります。
;;
;;@param wvec 
;;@param k 
;;@param obj 

;;;;;
;;@type Function
;;@name weak-vector-ref
;;@description weak ベクタ wvecのk番目の要素を返します。
;;
;;weak-vector-refはkが負の値であったりベクタの長さより
;;大きかったりした場合はエラーを通知します。但し、省略可能な引数fallback
;;が与えられている場合はその値が返されます。
;;
;;該当する要素が既にガベージコレクトされていた場合、fallbackが
;;与えられていればそれが、そうでなければ#fが返されます。
;;
;;gauche.sequenceモジュールをロードしていれば、
;;メソッドrefも同じ目的で使えます。
;;
;;@param wvec 
;;@param k 
;;@param &optioal 
;;@param fallback 

;;;;;
;;@type Function
;;@name weak-vector-length
;;@description weak ベクタ wvecの大きさを返します。
;;
;;@param wvec 

;;;;;
;;@type Function
;;@name make-weak-vector
;;@description 大きさsizeのweak ベクタを作成して返します。
;;
;;@param size 

;;;;;
;;@type Class
;;@name <weak-vector>
;;@description Weak ベクタのクラスです。<sequence>と<collection>を継承しているので、
;;gauche.collection (Collection framework参照) と
;;gauche.sequence (Sequence framework参照) も使えます。
;;example:
;;  (coerce-to <weak-vector> '(1 2 3 4))
;;    ==> a weak vector with four elements
;;

;;;;;
;;@type Function
;;@name alist->tree-map
;;@description key=?, key<? によって新たなtreemapを作成し、
;;連想リストalistに含まれる要素を追加した上で返します。
;;
;;@param alist 
;;@param key=? 
;;@param key<? 

;;;;;
;;@type Function
;;@name tree-map->alist
;;@description tree-map含まれる要素を連想リストにして返します。返される連
;;想リストのキーは昇順に並んでいます。
;;
;;@param tree-map 

;;;;;
;;@type Function
;;@name tree-map-values
;;@description それぞれ、tree-map内の全てのキーまたは値をリストにして返しま
;;す。返されるリストの要素はキーの昇順に並んでいます。
;;
;;@param tree-map 

;;;;;
;;@type Function
;;@name tree-map-keys
;;@description それぞれ、tree-map内の全てのキーまたは値をリストにして返しま
;;す。返されるリストの要素はキーの昇順に並んでいます。
;;
;;@param tree-map 

;;;;;
;;@type Function
;;@name tree-map-successor-value
;;@description Like tree-map-floor etc., but only returns the value of
;;the found entry (or fallback-value if there's no entry which satisfies
;;the criteria).
;;
;;@param tree-map 
;;@param probe 
;;@param optional 
;;@param fallback-value 

;;;;;
;;@type Function
;;@name tree-map-predecessor-value
;;@description Like tree-map-floor etc., but only returns the value of
;;the found entry (or fallback-value if there's no entry which satisfies
;;the criteria).
;;
;;@param tree-map 
;;@param probe 
;;@param optional 
;;@param fallback-value 

;;;;;
;;@type Function
;;@name tree-map-ceiling-value
;;@description Like tree-map-floor etc., but only returns the value of
;;the found entry (or fallback-value if there's no entry which satisfies
;;the criteria).
;;
;;@param tree-map 
;;@param probe 
;;@param optional 
;;@param fallback-value 

;;;;;
;;@type Function
;;@name tree-map-floor-value
;;@description Like tree-map-floor etc., but only returns the value of
;;the found entry (or fallback-value if there's no entry which satisfies
;;the criteria).
;;
;;@param tree-map 
;;@param probe 
;;@param optional 
;;@param fallback-value 

;;;;;
;;@type Function
;;@name tree-map-successor-key
;;@description Like tree-map-floor etc., but only returns the key of
;;the found entry (or fallback-key if there's no entry which satisfies
;;the criteria).
;;
;;@param tree-map 
;;@param probe 
;;@param optional 
;;@param fallback-key 

;;;;;
;;@type Function
;;@name tree-map-predecessor-key
;;@description Like tree-map-floor etc., but only returns the key of
;;the found entry (or fallback-key if there's no entry which satisfies
;;the criteria).
;;
;;@param tree-map 
;;@param probe 
;;@param optional 
;;@param fallback-key 

;;;;;
;;@type Function
;;@name tree-map-ceiling-key
;;@description Like tree-map-floor etc., but only returns the key of
;;the found entry (or fallback-key if there's no entry which satisfies
;;the criteria).
;;
;;@param tree-map 
;;@param probe 
;;@param optional 
;;@param fallback-key 

;;;;;
;;@type Function
;;@name tree-map-floor-key
;;@description Like tree-map-floor etc., but only returns the key of
;;the found entry (or fallback-key if there's no entry which satisfies
;;the criteria).
;;
;;@param tree-map 
;;@param probe 
;;@param optional 
;;@param fallback-key 

;;;;;
;;@type Function
;;@name tree-map-successor
;;@description These procedures search the entry which has the closest key
;;to the given probe.  If such an entry is found, returns
;;two values, its key and its value.  Otherwise, returns two values,
;;fallback-key and fallback-value, both defaulted to #f.
;;
;;The criteria of ``closest'' differ slightly among these procedures;
;;tree-map-floor finds the maximum key which is no greater than
;;probe; tree-map-ceiling finds the minimum key which is 
;;no less than probe; tree-map-predecessor finds the
;;maximum key which is strictly less than probe;
;;and tree-map-successor finds the minimum key which 
;;is strictly greater than probe.
;;
;;@param tree-map 
;;@param probe 
;;@param :optional 
;;@param fallback-key 
;;@param fallback-value 

;;;;;
;;@type Function
;;@name tree-map-predecessor
;;@description These procedures search the entry which has the closest key
;;to the given probe.  If such an entry is found, returns
;;two values, its key and its value.  Otherwise, returns two values,
;;fallback-key and fallback-value, both defaulted to #f.
;;
;;The criteria of ``closest'' differ slightly among these procedures;
;;tree-map-floor finds the maximum key which is no greater than
;;probe; tree-map-ceiling finds the minimum key which is 
;;no less than probe; tree-map-predecessor finds the
;;maximum key which is strictly less than probe;
;;and tree-map-successor finds the minimum key which 
;;is strictly greater than probe.
;;
;;@param tree-map 
;;@param probe 
;;@param :optional 
;;@param fallback-key 
;;@param fallback-value 

;;;;;
;;@type Function
;;@name tree-map-ceiling
;;@description These procedures search the entry which has the closest key
;;to the given probe.  If such an entry is found, returns
;;two values, its key and its value.  Otherwise, returns two values,
;;fallback-key and fallback-value, both defaulted to #f.
;;
;;The criteria of ``closest'' differ slightly among these procedures;
;;tree-map-floor finds the maximum key which is no greater than
;;probe; tree-map-ceiling finds the minimum key which is 
;;no less than probe; tree-map-predecessor finds the
;;maximum key which is strictly less than probe;
;;and tree-map-successor finds the minimum key which 
;;is strictly greater than probe.
;;
;;@param tree-map 
;;@param probe 
;;@param :optional 
;;@param fallback-key 
;;@param fallback-value 

;;;;;
;;@type Function
;;@name tree-map-floor
;;@description These procedures search the entry which has the closest key
;;to the given probe.  If such an entry is found, returns
;;two values, its key and its value.  Otherwise, returns two values,
;;fallback-key and fallback-value, both defaulted to #f.
;;
;;The criteria of ``closest'' differ slightly among these procedures;
;;tree-map-floor finds the maximum key which is no greater than
;;probe; tree-map-ceiling finds the minimum key which is 
;;no less than probe; tree-map-predecessor finds the
;;maximum key which is strictly less than probe;
;;and tree-map-successor finds the minimum key which 
;;is strictly greater than probe.
;;
;;@param tree-map 
;;@param probe 
;;@param :optional 
;;@param fallback-key 
;;@param fallback-value 

;;;;;
;;@type Function
;;@name tree-map-for-each
;;@description Applies proc with each key/value pair in tree-map,
;;in the increasing order of the keys.  proc is called purely
;;for side effects; the returned values are discarded.
;;
;;@param tree-map 
;;@param proc 

;;;;;
;;@type Function
;;@name tree-map-map
;;@description Applies proc with each key/value pair in tree-map,
;;and collect the results into a list and returns it.  The order
;;of results corresponds to the order of keys---that is, the first element
;;of the result list is what proc returns with minimum key and its value,
;;and the last element of the result list is what proc returns
;;with the maximum key and its value.
;;(Note: Like map, the order that proc is actually called
;;is unspecified; proc is better to be side-effect free.)
;;
;;@param tree-map 
;;@param proc 

;;;;;
;;@type Function
;;@name tree-map-fold-right
;;@description tree-mapの各要素に対し、(key, value, seed) -> seed の型を持つ
;;procを適用してゆきます。
;;tree-map-foldとtree-map-fold-rightの違いは
;;foldのfold-right違いと同じ、すなわち
;;結合の方向にあります。
;;example:
;;  tree-map-fold:
;;    (proc Kn Vn (proc Kn-1 Vn-1 ... (proc K0 V0 seed)))
;;  
;;  tree-map-fold-right
;;    (proc K0 V0 (proc K1 V1 ... (proc Kn Vn seed)))
;;
;;例:
;;example:
;;  (define tree (alist->tree-map '((3 . a) (7 . b) (5 . c)) = <))
;;  
;;  (tree-map-fold tree list* '()) 
;;     ==> (7 b 5 c 3 a)
;;  (tree-map-fold-right tree list* '()) 
;;     ==> (3 a 5 c 7 b)
;;
;;@param tree-map 
;;@param proc 
;;@param seed 

;;;;;
;;@type Function
;;@name tree-map-fold
;;@description tree-mapの各要素に対し、(key, value, seed) -> seed の型を持つ
;;procを適用してゆきます。
;;tree-map-foldとtree-map-fold-rightの違いは
;;foldのfold-right違いと同じ、すなわち
;;結合の方向にあります。
;;example:
;;  tree-map-fold:
;;    (proc Kn Vn (proc Kn-1 Vn-1 ... (proc K0 V0 seed)))
;;  
;;  tree-map-fold-right
;;    (proc K0 V0 (proc K1 V1 ... (proc Kn Vn seed)))
;;
;;例:
;;example:
;;  (define tree (alist->tree-map '((3 . a) (7 . b) (5 . c)) = <))
;;  
;;  (tree-map-fold tree list* '()) 
;;     ==> (7 b 5 c 3 a)
;;  (tree-map-fold-right tree list* '()) 
;;     ==> (3 a 5 c 7 b)
;;
;;@param tree-map 
;;@param proc 
;;@param seed 

;;;;;
;;@type Function
;;@name tree-map-pop-max!
;;@description それぞれ、tree-mapに含まれる最小および最大のキーを探索し、そ
;;のエントリをtree-mapから削除したうえで、そのキーと値のペアを
;;返します。tree-mapが空だった場合は#fが返されます。
;;
;;@param tree-map 

;;;;;
;;@type Function
;;@name tree-map-pop-min!
;;@description それぞれ、tree-mapに含まれる最小および最大のキーを探索し、そ
;;のエントリをtree-mapから削除したうえで、そのキーと値のペアを
;;返します。tree-mapが空だった場合は#fが返されます。
;;
;;@param tree-map 

;;;;;
;;@type Function
;;@name tree-map-max
;;@description それぞれ、tree-mapに含まれる最小および最大のキーを探索し、その
;;キーと値のペアを返します。tree-mapが空だった場合は#fが返されます。
;;
;;@param tree-map 

;;;;;
;;@type Function
;;@name tree-map-min
;;@description それぞれ、tree-mapに含まれる最小および最大のキーを探索し、その
;;キーと値のペアを返します。tree-mapが空だった場合は#fが返されます。
;;
;;@param tree-map 

;;;;;
;;@type Function
;;@name tree-map-pop!
;;@description tree-map中のキーkeyに対応する値が存在し、かつペアであった場合
;;に、そのエントリの値を元の値のcdrで置き換え、元の値のcarを返します。
;;keyに対応する値が存在しないかペアではなかった場合、tree-mapは
;;変更されず、fallbackが与えられていればそれが返され、与えられていな
;;ければエラーが報告されます。
;;
;;@param tree-map 
;;@param key 
;;@param :optional 
;;@param fallback 

;;;;;
;;@type Function
;;@name tree-map-push!
;;@description tree-map中の、キーkeyに対応する値にvalueをコンスし、
;;それをkey
;;に対する新たな値とします。もしkeyに対応する値がまだ無ければ、新た
;;なエントリが作成され、(list value)がその値となります。
;;
;;@param tree-map 
;;@param key 
;;@param value 

;;;;;
;;@type Function
;;@name tree-map-update!
;;@description tree-map-push!等のより一般的なバージョンです。木の探索が一度
;;しか行われないことを除いては、基本的に次のように動作します。
;;example:
;;  (let ((tmp (proc (tree-map-get tree-map key fallback))))
;;    (tree-map-put! tree-map key tmp)
;;    tmp)
;;
;;@param tree-map 
;;@param key 
;;@param proc 
;;@param :optional 
;;@param fallback 

;;;;;
;;@type Function
;;@name tree-map-clear!
;;@description tree-map内の全てのエントリを削除します。
;;
;;@param tree-map 

;;;;;
;;@type Function
;;@name tree-map-delete!
;;@description tree-mapからキーkeyを持つエントリを削除します。keyを持つエン
;;トリが実際に存在して削除された場合は#tを、エントリが存在しなかっ
;;た場合は#fを返します。
;;
;;@param tree-map 
;;@param key 

;;;;;
;;@type Function
;;@name tree-map-put!
;;@description キーkeyと対応する値valueをtree-mapに挿入します。もし、keyと、
;;key=?における意味で同じキーがすでに存在する場合、キーに対応する値
;;は新たな値に置き換えられます。
;;
;;@param tree-map 
;;@param key 
;;@param value 

;;;;;
;;@type Function
;;@name tree-map-get
;;@description キーkeyをtree-mapから探します。見つかればkeyに対応する値を返
;;します。キーが見つからなかった場合、fallbackが与えられていればそれ
;;を返し、そうでなければエラーを報告します。
;;
;;@param tree-map 
;;@param key 
;;@param :optional 
;;@param fallback 

;;;;;
;;@type Function
;;@name tree-map-exists?
;;@description tree-mapにキーkeyを持つエントリがあれば#tを、
;;そうでなければ#fを返します。
;;
;;@param tree-map 
;;@param key 

;;;;;
;;@type Function
;;@name tree-map-num-entries
;;@description tree-map内の要素の個数を返します。
;;
;;@param tree-map 

;;;;;
;;@type Function
;;@name tree-map-empty?
;;@description tree-mapが要素を持たないなら#tを、そうでなければ#fを
;;返します。
;;
;;@param tree-map 

;;;;;
;;@type Function
;;@name tree-map-copy
;;@description tree-mapのコピーを作り、それを返します。返された木に対す
;;る破壊的操作は、元の木に影響を与えません。
;;
;;@param tree-map 

;;;;;
;;@type Function
;;@name make-tree-map
;;@description <tree-map>オブジェクトを作成して返します。
;;key=?、key<?はそれぞれ引
;;数を2つ受け取り真偽値を返す手続きであり、要素のキーが渡されます。
;;key=?は、2つの引数a, b が同値の場合に真を、それ以外の場合に#fを
;;返す手続きです。key<?は、a < bが成り立つ場合に真を、それ以外の
;;場合に#fを返す手続きです。
;;
;;@param key=? 
;;@param key<? 

;;;;;
;;@type Class
;;@name <tree-map>
;;@description ツリーマップクラス。ツリーマップはキーオブジェクトから値オブジェクトへ
;;の写像をあらわすデータ構造です。ツリーマップでは平衡木を使うということ
;;以外はハッシュテーブルと同じです。ツリーマップでは挿入と検索の手間は
;;O(log n)です。
;;
;;ハッシュテーブルとはちがい、キーの順序は保存されます。したがってキーの
;;順序どおりにトラバースするのは簡単で、キーの最小値/最大値を見つけたり、
;;指定したキーにもっとも近いキーを探すのも簡単です。
;;
;;<tree-map>クラスは<sequence>および
;;<ordered-dictionary>を継承しています。
;;

;;;;;
;;@type Function
;;@name hash-table-values
;;@description それぞれ、ハッシュテーブルht内の全てのキーまたは値をリストにして返します。
;;
;;@param ht 

;;;;;
;;@type Function
;;@name hash-table-keys
;;@description それぞれ、ハッシュテーブルht内の全てのキーまたは値をリストにして返します。
;;
;;@param ht 

;;;;;
;;@type Function
;;@name hash-table-fold
;;@description ハッシュテーブルht内の全てのエントリについてkonsを呼びます。
;;konsには3つの引数が渡されます。
;;各エントリのキーと値、および一つ前のkonsの返り値です。
;;最初のkonsの呼び出しの時には、第3引数にknilが渡されます。
;;最後のkonsの返り値がhash-table-foldの返り値となります。
;;
;;@param ht 
;;@param kons 
;;@param knil 

;;;;;
;;@type Function
;;@name hash-table-map
;;@description ハッシュテーブルht内の全てのエントリについて、各エントリのキーと値を
;;2つの引数として手続きprocを呼びます。
;;
;;@param ht 
;;@param proc 

;;;;;
;;@type Function
;;@name hash-table-for-each
;;@description ハッシュテーブルht内の全てのエントリについて、各エントリのキーと値を
;;2つの引数として手続きprocを呼びます。
;;
;;@param ht 
;;@param proc 

;;;;;
;;@type Function
;;@name hash-table-update!
;;@description hash-table-push!等のより一般的なバージョンです。
;;ハッシュテーブルの探索が一度しか行われないことを除いては、
;;基本的に次のように動作します。
;;example:
;;  (let ((tmp (proc (hash-table-get ht key default))))
;;    (hash-table-put! ht key tmp)
;;    tmp)
;;
;;例えば、ハッシュテーブルを使ってオブジェクトの個数を数えているとしましょう。
;;次の1行で、オブジェクトitemが既に出現したかどうかを気にせずに
;;その個数をインクリメントできます。
;;
;;example:
;;  (hash-table-update! ht item (cut + 1 <>) 0))
;;
;;
;;@param ht 
;;@param key 
;;@param proc 
;;@param :optional 
;;@param default 

;;;;;
;;@type Function
;;@name hash-table-pop!
;;@description ハッシュテーブルht中のキーkeyに対応する値が存在し、かつペアで
;;あった場合に、そのエントリーを元の値のcdrで置き換え、元の値のcarを返します。
;;keyに対応する値が存在しないかペアではなかった場合、テーブルは変更されず、
;;defaultが与えられていればそれが返され、与えられていなければエラーが報告されます。
;;
;;値が置き換えれる場合でもキーの探索は一度しか行われないため効率が良いです。
;;
;;@param ht 
;;@param key 
;;@param :optional 
;;@param default 

;;;;;
;;@type Function
;;@name hash-table-push!
;;@description ハッシュテーブルht中の、キーkeyに対応する値にvalueをコンスし、
;;それをkeyに対する新たな値とします。もしkeyに対応する値がまだ無ければ、
;;新たなエントリが作成され、(list value)がその値となります。
;;
;;この手続きは次のコードと同じ動作をしますが、キーの探索が一度しか行われないためより高速です。
;;example:
;;  (hash-table-put! ht key
;;      (cons value (hash-table-get ht key '())))
;;
;;@param ht 
;;@param key 
;;@param value 

;;;;;
;;@type Function
;;@name hash-table-clear!
;;@description ハッシュテーブルhtの全てのエントリを削除します。
;;
;;@param ht 

;;;;;
;;@type Function
;;@name hash-table-delete!
;;@description ハッシュテーブルhtからキーkeyを持つエントリを削除します。
;;keyを持つエントリが実際に存在して削除された場合は#tを、
;;エントリが存在しなかった場合は#fを返します。
;;この手続きはSTkでhash-table-remove!と呼ばれているものです
;;(STkのは戻り値が定義されていませんが)。GaucheではSRFI-1, SRFI-13やその他の
;;ライブラリとの一貫性のために `delete' を採用しました。
;;
;;@param ht 
;;@param key 

;;;;;
;;@type Function
;;@name hash-table-exists?
;;@description ハッシュテーブルhtにキーkeyを持つエントリがあれば#tを返します。
;;
;;@param ht 
;;@param key 

;;;;;
;;@type Method
;;@name ref
;;@description hash-table-getとhash-table-put!のメソッド版です。
;;
;;@param (ht <hash-table>) key :optional default 

;;;;;
;;@type Function
;;@name hash-table-put!
;;@description キーkeyと対応する値valueをハッシュテーブルhtに挿入します。
;;
;;@param ht 
;;@param key 
;;@param value 

;;;;;
;;@type Function
;;@name hash-table-get
;;@description キーkeyをハッシュテーブルhtから探します。見つかればキーに対応する
;;値を返します。キーが見つからなかった場合、defaultが与えられていればそれを
;;返し、そうでなければエラーを報告します。
;;
;;@param ht 
;;@param key 
;;@param :optional 
;;@param default 

;;;;;
;;@type Function
;;@name hash-table
;;@description 与えられたキーと値の列からタイプがtypeであるハッシュテーブルを構築して
;;返します。typeの意味はmake-hash-tableと同じです。
;;各key&valueはペアでなければならず、そのcarがキー、cdrが値として使われます。
;;
;;example:
;;  (hash-table 'eq? '(a . 1) '(b . 2))
;;    ≡ 
;;    (let ((h (make-hash-table 'eq?)))
;;       (hash-table-put! h 'a 1)
;;       (hash-table-put! h 'b 2)
;;       h)
;;
;;@param type 
;;@param key&value 
;;@param ... 

;;;;;
;;@type Function
;;@name hash-table-num-entries
;;@description ハッシュテーブルht中の要素の個数を返します。
;;
;;@param ht 

;;;;;
;;@type Function
;;@name hash-table-type
;;@description ハッシュテーブルhtのタイプに応じて、シンボル
;;eq?、eqv?、equal?、string=?のいずれかを
;;返します。
;;
;;@param ht 

;;;;;
;;@type Function
;;@name hash-table?
;;@description objがハッシュテーブルであれば#tを返します。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name eqv-hash
;;@description この2つは eq?-タイプおよび eqv?-タイプのハッシュテーブル
;;用のハッシュ関数で、2^n-1 以下の非負の整数を返します。ここで、
;;n は 32 以上のシステム依存の値です。返り値のハッシュ値は、
;;システムおよびプロセスに依存する値です。動作しているプロセスの境界を
;;超えてもちまわることはできません。
;;
;;注意: eq-hash をつかって、数をハッシュしてはいけません。
;;2つの数はたとえその値が等しくても eq? であることは保証されて
;;いません。したがって、eq?-タイプのハッシュテーブルで、
;;数のキーとしての使用はサポートされていません。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name eq-hash
;;@description この2つは eq?-タイプおよび eqv?-タイプのハッシュテーブル
;;用のハッシュ関数で、2^n-1 以下の非負の整数を返します。ここで、
;;n は 32 以上のシステム依存の値です。返り値のハッシュ値は、
;;システムおよびプロセスに依存する値です。動作しているプロセスの境界を
;;超えてもちまわることはできません。
;;
;;注意: eq-hash をつかって、数をハッシュしてはいけません。
;;2つの数はたとえその値が等しくても eq? であることは保証されて
;;いません。したがって、eq?-タイプのハッシュテーブルで、
;;数のキーとしての使用はサポートされていません。
;;
;;@param obj 

;;;;;
;;@type Method
;;@name object-hash
;;@description この総称関数に対するメソッドを定義することにより、ユーザ定義された
;;型のオブジェクトはハッシュ値を持つことができ、equal?型のハッシュ
;;テーブルで利用することができるようになります。
;;
;;メソッドは正確な非負整数を返さなければなりません。また、hash と
;;同じ制約に従わなければなりません。
;;
;;メソッドが obj の要素のハッシュ値を必要とする場合には、
;;それらに対しては、object-hash ではなく、hash を
;;呼ばなければなりません。プリミティブなオブジェクトのハッシュ計算は
;;hash が行うからです。
;;
;;example:
;;  (define-class <myclass> () (x y))
;;  
;;  ;; user-defined equality function
;;  (define-method object-equal? ((a <myclass>) (b <myclass>))
;;    (and (equal? (ref a 'x) (ref b 'x))
;;         (eq?    (ref a 'y) (ref b 'y))))
;;  
;;  ;; user-defined hash function
;;  (define-method object-hash ((a <myclass>))
;;    (hash (list (ref a 'x) (ref a 'y))))
;;
;;@param obj 

;;;;;
;;@type Function
;;@name hash
;;@description obj のハッシュ値を返します。equal?-タイプのハッシュテーブルで
;;利用するハッシュ関数です。この関数が返すハッシュ値は正確な非負整数で、
;;以下の二つの性質があります。
;;a および b の型について、hash が定義されているとき、
;;あらゆるオブジェクト a および  b に対して、
;;(equal? a b) であれば
;;(= (hash a) (hash b))。
;;hash は(そのデータのアドレスというような)実行時の計算機の状態とは
;;独立しています。それゆえ、その値をファイルに格納し、別のプロセスで読み込んで
;;利用しても、ハッシュ値の正当性を失うことがないので、安全です。
;;obj が、数値、真理値、文字、シンボル、キーワード、文字列、リスト、
;;ベクタのいずれかならば、そのハッシュ値を求めるのには内部ハッシュ関数を
;;使います。
;;obj が、それ以外であれば、 hash は総称関数 object-hash
;;を呼んで、そのハッシュ値を計算します。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name make-hash-table
;;@description ハッシュテーブルを作成します。シンボルtypeはテーブルのタイプを指定します。
;;現在、以下のようなタイプがサポートされています。
;;(typeが省略された場合はeq?とみなされます。)
;;eq? ------
;;  キーの比較にeq?を使います。
;;eqv? ------
;;  キーの比較にeqv?を使います。
;;equal? ------
;;  キーの比較にequal?を使います。
;;string=? ------
;;  キーの比較にstring=?を使います。キーは文字列でなければなりません。
;;
;;eq?、eqv?、string=?タイプのハッシュテーブルでは、
;;システム組み込みのハッシュ関数が使われます。Schemeからは、
;;それらのハッシュ関数はそれぞれeq-hash、eqv-hash、
;;そしてSRFI-13のstring-hashとして呼ぶことができます。
;;これらの関数はユーザ定義型に対応するように拡張することはできません。
;;一方、equal?タイプのハッシュテーブルは
;;下に述べるhash関数を使います。後者では、ユーザ定義型に対するハッシュ関数を
;;独自に定義することができます。
;;
;;
;;@param :optional 
;;@param type 

;;;;;
;;@type Class
;;@name <hash-table>
;;@description ハッシュテーブルのクラスです。<collection>と<dictionary>を
;;継承します。
;;

;;;;;
;;@type Function
;;@name vector-copy
;;@description [SRFI-43]
;;ベクタvectorをコピーします。引数startとendを与えることで
;;コピーされる範囲を制限することができます。
;;startとendで指定される範囲が元のvectorの範囲を越えた
;;場合は、その部分がfillで埋められます。
;;
;;example:
;;  (vector-copy '#(1 2 3 4 5))     ==> #(1 2 3 4 5)
;;  (vector-copy '#(1 2 3 4 5) 2 4) ==> #(3 4)
;;  (vector-copy '#(1 2 3 4 5) 3 7 #f) ==> #(4 5 #f #f)
;;
;;@param vector 
;;@param :optional 
;;@param start 
;;@param end 
;;@param fill 

;;;;;
;;@type Class
;;@name <vector>
;;@description ベクタはSchemeオブジェクトの単純な一次元配列です。
;;インデックスを用いて定数時間でその要素にアクセスできます。
;;一度作成されたベクタはその大きさを変えることはできません。
;;
;;<vector>クラスはまた<sequence>クラスを継承し、
;;mapやfoldなど様々な総称関数を使うことができます。
;;Collection framework と
;;Sequence framework を参照して下さい。
;;
;;数値しか要素に持たないベクタを使う場合、SRFI-4の
;;単一型ベクタも使えるかもしれません (Homogeneous vectors参照)。
;;
;;より多くのベクタに対する操作がVector libraryで提供されています。
;;

;;;;;
;;@type Function
;;@name regexp-unparse
;;@description From the regexp's ast, reconstruct the string representation
;;of the regexp.  The keyword argument on-error can be
;;a keyword :error (default) or #f.  If its the former,
;;an error is signalled when ast isn't valid regexp AST.
;;If it's the latter, regexp-unparse just returns #f.
;;
;;@param ast 
;;@param :key 
;;@param (on-error :error) 

;;;;;
;;@type Function
;;@name regexp-ast
;;@description Returns AST used for the regexp object regexp.
;;
;;@param regexp 

;;;;;
;;@type Function
;;@name regexp-compile
;;@description Takes an regexp AST and returns a regexp object.
;;Currently the outermost form of ast must be
;;a zero-th capturing group.  It is always added
;;by regexp-parse to capture the entire regexp.
;;
;;Note: The function does some basic check to see the given AST
;;is valid, but it may not reject invalid ASTs.  In such case,
;;the returned regexp object doesn't work properly.  It is
;;caller's responsibility to provide a properly constructed AST.
;;(Even if it rejects an AST, error messages are often
;;incomprehensible.)
;;
;;@param ast 

;;;;;
;;@type Function
;;@name regexp-optimize
;;@description Performs some rudimental optimization on the regexp AST,
;;returning regexp AST.
;;
;;Currently it only optimizes some obvious cases.  The plan is
;;to make it cleverer in future.
;;
;;@param ast 

;;;;;
;;@type Function
;;@name regexp-parse
;;@description Parses a string specification of regexp in string
;;and returns its AST, represented in S-expression.
;;See below for the spec of AST.
;;
;;When a true value is given to the keyword argument case-fold,
;;returned AST will match case-insensitively.
;;(Case insensitive regexp is handled in parser level,
;;not by the engine).
;;
;;@param string 
;;@param :key 
;;@param case-fold 

;;;;;
;;@type Macro
;;@name rxmatch-case
;;@description string-exprがまず評価され、続いてclauseが順に検査されます。
;;clauseは以下のいずれかの形式でなければなりません。
;;
;;(re (var ...) form ...) ------
;;  reはリテラル正規表現オブジェクトでなければなりません
;;  (Regular expressions参照)。string-exprの結果が文字列であり
;;  reにマッチした場合は、マッチ文字列が変数var ...に
;;  束縛され、formが評価されます。最後のformの値がrxmatch-case
;;  の値となります。
;;  
;;  string-exprの結果の文字列がreにマッチしないか、
;;  string-exprの結果が文字列以外であった場合は次のclauseへと
;;  処理が進みます。
;;  
;;(test proc form ...) ------
;;  手続きprocがstring-exprの結果を引数として呼ばれます。
;;  それが真の値を返した場合はformが順に評価され、最後のformの
;;  値がrxmatch-caseの値として返されます。
;;  
;;  procが#fを返した場合は次のclauseへと
;;  処理が進みます。
;;  
;;(test proc => proc2) ------
;;  手続きprocがstring-exprの結果を引数として呼ばれます。
;;  それが真の値を返した場合は、その値を引数としてproc2が呼ばれ、
;;  その返り値がrxmatch-caseの値として返されます。
;;  
;;  procが#fを返した場合は次のclauseへと
;;  処理が進みます。
;;  
;;(else form ...) ------
;;  このフォームは、与えられる場合は最後のclauseでなければなりません。
;;  他の全てのclauseが失敗した場合に、formが順に評価され、最後のformの
;;  値がrxmatch-caseの値として返されます。
;;  
;;(else => proc) ------
;;  このフォームは、与えられる場合は最後のclauseでなければなりません。
;;  他の全てのclauseが失敗した場合に、procが評価されます。
;;  その値は一引数の手続きにならなければなりません。
;;  その手続きが、string-exprの値を引数として呼ばれます。
;;  procの結果がrxmatch-caseの値となります。
;;
;;else clauseが与えられず、かつ全てのclauseが
;;失敗した場合の戻り値は未定義です。
;;
;;上のparse-dateの例はrxmatch-caseを使うとより単純になります。
;;
;;example:
;;  (define (parse-date2 str)
;;    (rxmatch-case str
;;      (test (lambda (s) (not (string? s))) #f)
;;      (#/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ (#f mm dd yyyy)
;;       (map string->number (list yyyy mm dd)))
;;      (#/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ (#f yyyy mm dd)
;;       (map string->number (list yyyy mm dd)))
;;      (#/^\d+\/\d+\/\d+$/                (#f)
;;       (errorf "ambiguous: ~s" str))
;;      (else (errorf "bogus: ~s" str))))
;;
;;@param string-expr 
;;@param clause 
;;@param ... 

;;;;;
;;@type Macro
;;@name rxmatch-cond
;;@description clauseの条件を順に評価してゆき、条件を満たすものが現れたら
;;そのclauseの残りのフォームを評価し、最後のフォームの値を
;;rxmatch-condの値とします。clauseは以下のいずれかの
;;形式でなければなりません。
;;
;;(match-expr (var ...) form ...) ------
;;  match-exprを評価し、それがマッチオブジェクトを返した場合は
;;  マッチ文字列を変数var ...に束縛した上で
;;  form ...を評価します。
;;  
;;(test expr form ...) ------
;;  exprを評価し、それが真の値を返した場合はform ...を評価します。
;;  
;;(test expr => proc) ------
;;  exprを評価し、それが真の値を返した場合は
;;  それを唯一の引数として手続きprocを呼びます。
;;  
;;(else form ...) ------
;;  このclauseは、もし与えられたとすれば最後のclauseでなければ
;;  なりません。全てのclauseが失敗した場合に、form ...が
;;  評価されます。
;;
;;else clauseが与えられず、かつ全てのclauseが
;;失敗した場合の戻り値は未定義です。
;;
;;example:
;;  ;; 何通りかの日付のフォーマットをパーズする
;;  (define (parse-date str)
;;    (rxmatch-cond
;;      ((rxmatch #/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ str)
;;          (#f mm dd yyyy)
;;        (map string->number (list yyyy mm dd)))
;;      ((rxmatch #/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ str)
;;          (#f yyyy mm dd)
;;        (map string->number (list yyyy mm dd)))
;;      ((rxmatch #/^\d+\/\d+\/\d+$/ str)
;;          (#f)
;;       (errorf "ambiguous: ~s" str))
;;      (else (errorf "bogus: ~s" str))))
;;  
;;  (parse-date "2001/2/3") ==> (2001 2 3)
;;  (parse-date "12/25/1999") ==> (1999 12 25)
;;
;;このマクロはscshのmatch-condに相当します。
;;
;;@param clause 
;;@param ... 

;;;;;
;;@type Macro
;;@name rxmatch-if
;;@description match-exprを評価し、それがマッチオブジェクトを返したら
;;マッチした文字列を変数var ...に束縛してthen-formを
;;評価します。マッチオブジェクトが返されなければ束縛は行われず、
;;else-formが評価されます。変数varをマッチ文字列に
;;束縛するルールはrxmatch-letと同じです。
;;
;;example:
;;  (rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11:22:33")
;;      (time)
;;    (format #f "time is ~a" time)
;;    "unknown time")
;;   ==> "time is 11:22"
;;  
;;  (rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11-22-33")
;;      (time)
;;    (format #f "time is ~a" time)
;;    "unknown time")
;;   ==> "unknown time"
;;
;;このマクロはscshのif-matchに相当します。
;;
;;@param match-expr 
;;@param (var ...) then-form else-form 

;;;;;
;;@type Macro
;;@name rxmatch-let
;;@description 
;;match-exprを評価し、それがマッチオブジェクトを返したら、
;;マッチした文字列を@var{var ...}に束縛し、formを評価します。
;;最初のvarはマッチした文字列全体に束縛され、
;;以降の変数はサブマッチ文字列に束縛されます。実際のサブマッチ文字列が
;;与えられた変数より少なかった場合は、余った変数は#fに束縛されます。
;;
;;特定のマッチ文字列を受け取る必要が無いときは、その場所の
;;変数の変わりに#fを置いておくこともできます。
;;
;;example:
;;  (rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
;;                        "Jan  1 23:59:58, 2001")
;;     (time hh mm ss)
;;    (list time hh mm ss))
;;   ==> ("23:59:58" "23" "59" "58")
;;  
;;  (rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
;;                        "Jan  1 23:59:58, 2001")
;;     (#f hh mm)
;;    (list hh mm))
;;   ==> ("23" "59")
;;
;;このマクロはscshのlet-matchに相当します。
;;
;;@param match-expr 
;;@param (var ...) form ... 

;;;;;
;;@type Function
;;@name regexp-quote
;;@description string中で、正規表現において特別な意味を持つ文字を全てエスケープした
;;文字列を返します。
;;
;;example:
;;  (regexp-quote "[2002/10/12] touched foo.h and *.c")
;;   ==> "\\[2002/10/12\\] touched foo\\.h and \\*\\.c"
;;
;;@param string 

;;;;;
;;@type Function
;;@name regexp-replace-all*
;;@description まず、regexp-replace あるいは regexp-replace-all を
;;正規表現 rx1、置換 sub1 で string に適用し、
;;その結果にさらに regexp-replace あるいは
;;regexp-replace-all を正規表現 rx2、置換 sub2 で
;;適用し、以下同様です。これらの関数はひとつの文字列上で複数回置換を行う
;;ときに便利です。
;;
;;@param string 
;;@param rx1 
;;@param sub1 
;;@param rx2 
;;@param sub2 
;;@param ... 

;;;;;
;;@type Function
;;@name regexp-replace*
;;@description まず、regexp-replace あるいは regexp-replace-all を
;;正規表現 rx1、置換 sub1 で string に適用し、
;;その結果にさらに regexp-replace あるいは
;;regexp-replace-all を正規表現 rx2、置換 sub2 で
;;適用し、以下同様です。これらの関数はひとつの文字列上で複数回置換を行う
;;ときに便利です。
;;
;;@param string 
;;@param rx1 
;;@param sub1 
;;@param rx2 
;;@param sub2 
;;@param ... 

;;;;;
;;@type Function
;;@name regexp-replace-all
;;@description string中でregexpにマッチした部分をsubstitutionで
;;置き換えます。regexp-replaceは最初にマッチした部分のみを置き換え、
;;regexp-replace-allは全てのマッチを置き換えます。
;;
;;substitutionは文字列か手続きです。
;;文字列の場合、バックスラッシュに続く数値、もしくは
;;\k<name>という形式でサブマッチ文字列を参照できます
;;\0はマッチ文字列全体を参照します。文字列リテラルにバックスラッシュを
;;埋め込む場合は二つのバックスラッシュが必要であることに注意して下さい。
;;バックスラッシュそのものをsubstitution中で使いたい場合は
;;二つのバックスラッシュを重ねます; 文字列リテラルの場合は4つのバックスラッシュが
;;必要になります。
;;
;;example:
;;  (regexp-replace #/def|DEF/ "abcdefghi" "...")
;;    ==> "abc...ghi"
;;  (regexp-replace #/def|DEF/ "abcdefghi" "|\\0|")
;;    ==> "abc|def|ghi"
;;  (regexp-replace #/def|DEF/ "abcdefghi" "|\\\\0|")
;;    ==> "abc|\\0|ghi"
;;  (regexp-replace #/c(.*)g/ "abcdefghi" "|\\1|")
;;    ==> "ab|def|hi"
;;  (regexp-replace #/c(?<match>.*)g/ "abcdefghi" "|\\k<match>|")
;;    ==> "ab|def|hi"
;;
;;substitutionが手続きである場合、string中の各マッチについて、
;;マッチオブジェクトを引数としてその手続きが呼ばれます。その手続きが返す
;;値をdisplayで表現したものが置換文字列として使われます。
;;
;;example:
;;  (regexp-replace #/c(.*)g/ "abcdefghi" 
;;                  (lambda (m)
;;                    (list->string
;;                     (reverse
;;                      (string->list (rxmatch-substring m 1))))))
;;   ==> "abfedhi"
;;
;;註: regexp-replace-all は文字列でマッチした部分の後ろの部分に
;;ついて再帰的に自分自身を適用します。従って、regexpが
;;文字列先頭のアサーション (^) を含んでいても、それはstringの
;;先頭だけにマッチするとは限りません。
;;
;;@param regexp 
;;@param string 
;;@param substitution 

;;;;;
;;@type Function
;;@name regexp-replace
;;@description string中でregexpにマッチした部分をsubstitutionで
;;置き換えます。regexp-replaceは最初にマッチした部分のみを置き換え、
;;regexp-replace-allは全てのマッチを置き換えます。
;;
;;substitutionは文字列か手続きです。
;;文字列の場合、バックスラッシュに続く数値、もしくは
;;\k<name>という形式でサブマッチ文字列を参照できます
;;\0はマッチ文字列全体を参照します。文字列リテラルにバックスラッシュを
;;埋め込む場合は二つのバックスラッシュが必要であることに注意して下さい。
;;バックスラッシュそのものをsubstitution中で使いたい場合は
;;二つのバックスラッシュを重ねます; 文字列リテラルの場合は4つのバックスラッシュが
;;必要になります。
;;
;;example:
;;  (regexp-replace #/def|DEF/ "abcdefghi" "...")
;;    ==> "abc...ghi"
;;  (regexp-replace #/def|DEF/ "abcdefghi" "|\\0|")
;;    ==> "abc|def|ghi"
;;  (regexp-replace #/def|DEF/ "abcdefghi" "|\\\\0|")
;;    ==> "abc|\\0|ghi"
;;  (regexp-replace #/c(.*)g/ "abcdefghi" "|\\1|")
;;    ==> "ab|def|hi"
;;  (regexp-replace #/c(?<match>.*)g/ "abcdefghi" "|\\k<match>|")
;;    ==> "ab|def|hi"
;;
;;substitutionが手続きである場合、string中の各マッチについて、
;;マッチオブジェクトを引数としてその手続きが呼ばれます。その手続きが返す
;;値をdisplayで表現したものが置換文字列として使われます。
;;
;;example:
;;  (regexp-replace #/c(.*)g/ "abcdefghi" 
;;                  (lambda (m)
;;                    (list->string
;;                     (reverse
;;                      (string->list (rxmatch-substring m 1))))))
;;   ==> "abfedhi"
;;
;;註: regexp-replace-all は文字列でマッチした部分の後ろの部分に
;;ついて再帰的に自分自身を適用します。従って、regexpが
;;文字列先頭のアサーション (^) を含んでいても、それはstringの
;;先頭だけにマッチするとは限りません。
;;
;;@param regexp 
;;@param string 
;;@param substitution 

;;;;;
;;@type Function
;;@name rxmatch->string
;;@description A convenience procedure to match a string to the given regexp,
;;then returns the matched substring, or #f if it doesn't match.
;;
;;If no selector is given, it is the same as this:
;;
;;example:
;;  (rxmatch-substring (rxmatch regexp string))
;;
;;If an integer is given as a selector, it returns the subtring
;;of the numbered submatch.
;;
;;If a symbol after or before is given, it returns
;;the substring after or before the match.  You can give these symbols
;;and an integer to extract a substring before or after the numbered
;;submatch.
;;
;;example:
;;  gosh> (rxmatch->string #/\d+/ "foo314bar")
;;  "314"
;;  gosh> (rxmatch->string #/(\w+)@@([\w.]+)/ "foo@@example.com" 2)
;;  "example.com"
;;  gosh> (rxmatch->string #/(\w+)@@([\w.]+)/ "foo@@example.com" 'before 2)
;;  "foo@@"
;;
;;@param regexp 
;;@param string 
;;@param :optional 
;;@param selector 
;;@param ... 

;;;;;
;;@type Function
;;@name rxmatch-before
;;@description マッチオブジェクトmatchの前および後の文字列を返します。
;;正の整数がiに与えられた場合はi番目のサブマッチの前および後の
;;文字列を返します。シンボルが与えられた場合は、その名前を持つ
;;サブマッチの前後の文字列を返します。
;;
;;example:
;;  (define match (rxmatch #/(\d+)\.(\d+)/ "pi=3.14..."))
;;  
;;  (rxmatch-after match) ==> "..."
;;  (rxmatch-after match 1) ==> ".14..."
;;  
;;  (rxmatch-before match) ==> "pi="
;;  (rxmatch-before match 2) ==> "pi=3."
;;
;;@param match 
;;@param :optional 
;;@param (i 0) 

;;;;;
;;@type Function
;;@name rxmatch-after
;;@description マッチオブジェクトmatchの前および後の文字列を返します。
;;正の整数がiに与えられた場合はi番目のサブマッチの前および後の
;;文字列を返します。シンボルが与えられた場合は、その名前を持つ
;;サブマッチの前後の文字列を返します。
;;
;;example:
;;  (define match (rxmatch #/(\d+)\.(\d+)/ "pi=3.14..."))
;;  
;;  (rxmatch-after match) ==> "..."
;;  (rxmatch-after match 1) ==> ".14..."
;;  
;;  (rxmatch-before match) ==> "pi="
;;  (rxmatch-before match 2) ==> "pi=3."
;;
;;@param match 
;;@param :optional 
;;@param (i 0) 

;;;;;
;;@type Function
;;@name rxmatch-num-matches
;;@description matchの持つマッチの数を返します。この数には
;;「マッチ全体」も含まれるので、<regmatch>オブジェクトに対しては
;;常に正の整数が返ることになります。また、値を持たないマッチもカウントされます
;;(下の例を参照)。
;;
;;簡便のために、matchに#fを渡すこともできます。
;;その場合は0が返ります。
;;
;;example:
;;  (rxmatch-num-matches (rxmatch #/abc/ "abc"))
;;    ==> 1
;;  
;;  (rxmatch-num-matches (rxmatch #/(a(.))|(b(.))/ "ba"))
;;    ==> 5
;;  
;;  (rxmatch-num-matches #f)
;;    ==> 0
;;
;;
;;@param match 

;;;;;
;;@type Function
;;@name rxmatch-substring
;;@description rxmatchが返すマッチオブジェクトmatchから情報を取り出します。
;;iが省略されるか0の場合、これらの手続きはそれぞれ一致した
;;文字列の開始インデックス、終了インデックス、および一致した部分文字列を
;;返します。iに正の整数が与えられた場合は、i番目のサブマッチ
;;に関する情報を返します。iにシンボルが与えられた場合は、名前
;;iを持つサブマッチの情報を返します。同じ名前iを持つ複数の
;;サブマッチがある場合には、成功したサブマッチの情報を返します。
;;iにそれ以外の値を与えるのはエラーです。
;;
;;簡便のために、matchに#fを渡すことも許されています。
;;その場合、これらの手続きは#fを返します。
;;
;;これらの手続きはScshでmatch:start、match:end、
;;match:substringと呼ばれているものと等価です。
;;
;;@param match 
;;@param :optional 
;;@param (i 0) 

;;;;;
;;@type Function
;;@name rxmatch-end
;;@description rxmatchが返すマッチオブジェクトmatchから情報を取り出します。
;;iが省略されるか0の場合、これらの手続きはそれぞれ一致した
;;文字列の開始インデックス、終了インデックス、および一致した部分文字列を
;;返します。iに正の整数が与えられた場合は、i番目のサブマッチ
;;に関する情報を返します。iにシンボルが与えられた場合は、名前
;;iを持つサブマッチの情報を返します。同じ名前iを持つ複数の
;;サブマッチがある場合には、成功したサブマッチの情報を返します。
;;iにそれ以外の値を与えるのはエラーです。
;;
;;簡便のために、matchに#fを渡すことも許されています。
;;その場合、これらの手続きは#fを返します。
;;
;;これらの手続きはScshでmatch:start、match:end、
;;match:substringと呼ばれているものと等価です。
;;
;;@param match 
;;@param :optional 
;;@param (i 0) 

;;;;;
;;@type Function
;;@name rxmatch-start
;;@description rxmatchが返すマッチオブジェクトmatchから情報を取り出します。
;;iが省略されるか0の場合、これらの手続きはそれぞれ一致した
;;文字列の開始インデックス、終了インデックス、および一致した部分文字列を
;;返します。iに正の整数が与えられた場合は、i番目のサブマッチ
;;に関する情報を返します。iにシンボルが与えられた場合は、名前
;;iを持つサブマッチの情報を返します。同じ名前iを持つ複数の
;;サブマッチがある場合には、成功したサブマッチの情報を返します。
;;iにそれ以外の値を与えるのはエラーです。
;;
;;簡便のために、matchに#fを渡すことも許されています。
;;その場合、これらの手続きは#fを返します。
;;
;;これらの手続きはScshでmatch:start、match:end、
;;match:substringと呼ばれているものと等価です。
;;
;;@param match 
;;@param :optional 
;;@param (i 0) 

;;;;;
;;@type Function
;;@name rxmatch
;;@description 正規表現オブジェクトregexpに一致するものを文字列stringから
;;探します。一致が見付かった場合は<regmatch>オブジェクトを返し、
;;見付からなかった場合は#fを返します。
;;
;;他のScheme処理系ではこれは
;;match、regexp-search、string-matchなど
;;様々な名で呼ばれています。
;;
;;@param regexp 
;;@param string 

;;;;;
;;@type Function
;;@name regexp->string
;;@description 正規表現regexpを記述する元になった文字列を返します。
;;返される文字列は変更不可な文字列です。
;;
;;@param regexp 

;;;;;
;;@type Function
;;@name regexp?
;;@description objが正規表現オブジェクトなら真の値を返します。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name string->regexp
;;@description 文字列stringを正規表現とみなして、<regexp>のインスタンスを
;;作成して返します。
;;
;;キーワード引数case-foldに真の値が与えられた場合、作成される正規表現は
;;大文字小文字を区別しないものとなります。
;;(大文字小文字を区別しない正規表現に関しては上の説明を参照して下さい)。
;;
;;@param string 
;;@param :key 
;;@param case-fold 

;;;;;
;;@type Class
;;@name <regmatch>
;;@description 正規表現マッチオブジェクトのクラスです。正規表現エンジンrxmatchは、
;;一致した場合にこのオブジェクトを返します。部分一致の情報を含めた
;;全てのマッチに関する情報がこのオブジェクトに含まれています。
;;
;;一致した部分文字列やそのインデックスのリストではなく
;;マッチオブジェクトを返すことの利点は効率です。
;;regmatchオブジェクトはマッチの内部状態を保持しており、
;;要求された時にはじめて該当する部分文字列やインデックスを計算します。
;;これは特にマルチバイト文字列に有効です。マルチバイト文字列
;;へのインデックスアクセスは遅いからです。
;;

;;;;;
;;@type Class
;;@name <regexp>
;;@description 正規表現オブジェクトのクラスです。string->regexpを使って実行時に
;;作成できます。また、Gaucheはリテラルの正規表現を表す構文を持っており、
;;ロード時に作成することもできます。
;;
;;Gaucheの正規表現エンジンはマルチバイト文字列に対応しています。
;;

;;;;;
;;@type Function
;;@name string-incomplete->complete
;;@description 不完全文字列strの内容を再解釈して、あらたに完全文字列を返す。
;;handling引数でstr中の不正なバイト列の扱いかたを指定します。
;;#f ------
;;  strが不正なバイト列を含んでいる場合、変換を諦めて#fを返し
;;  ます。これがデフォルトのふるまいです。
;;:omit ------
;;  不正なバイト列を捨てます。常に完全文字列を返します。
;;1文字 ------
;;  不正なバイト列中の各バイトを与えた文字で置き換えます。常に完全文字列を
;;  返します。
;;strが完全文字列なら、そのコピーが返されます。
;;
;;@param str 
;;@param :optional 
;;@param handling 

;;;;;
;;@type Function
;;@name string-split
;;@description string を splitter で分割し、文字列のリストを返します。
;;splitter には、文字、文字セット、文字列、正規表現、手続きが
;;使えます。
;;
;;splitter が文字の場合、その文字がデリミタとして使われます。
;;
;;splitter が文字セットの場合は、その文字セットに含まれる文字の
;;連続がデリミタとして使われます。
;;
;;splitter に手続きが与えられた場合、string にある各文字に
;;対してその手続きが呼ばれ、splitter が真の値を返すような連続した
;;文字群がデリミタとして使われます。
;;
;;example:
;;  (string-split "/aa/bb//cc" #\/)    ==> ("" "aa" "bb" "" "cc")
;;  (string-split "/aa/bb//cc" "/")    ==> ("" "aa" "bb" "" "cc")
;;  (string-split "/aa/bb//cc" "//")   ==> ("/aa/bb" "cc")
;;  (string-split "/aa/bb//cc" #[/])   ==> ("" "aa" "bb" "cc")
;;  (string-split "/aa/bb//cc" #/\/+/) ==> ("" "aa" "bb" "cc")
;;  (string-split "/aa/bb//cc" #[\w])  ==> ("/" "/" "//" "")
;;  (string-split "/aa/bb//cc" char-alphabetic?) ==> ("/" "/" "//" "")
;;  
;;  ;; some boundary cases
;;  (string-split "abc" #\/) ==> ("abc")
;;  (string-split ""    #\/) ==> ("")
;;
;;string-tokenize (SRFI-13 other string operations)
;;も参照して下さい。
;;
;;@param string 
;;@param splitter 

;;;;;
;;@type Function
;;@name string-scan
;;@description string にある item (文字列あるいは文字)を探します。
;;引数 return は、string 中に item が見つかった
;;場合にどの値が返されるかを指定します。それは以下のシンボルのうちの
;;一つでなければなりません。
;;
;;index ------
;;  item が見つかった場合はstring 内でのインデックス、
;;  そうでなければ #f を返します。これがデフォルトの振る舞いです。
;;  example:
;;    (string-scan "abracadabra" "ada") ==> 5
;;    (string-scan "abracadabra" #\c) ==> 4
;;    (string-scan "abracadabra" "aba") ==> #f
;;before ------
;;  item よりも前にある string の部分文字列、あるいは
;;  item が見つからなければ #f を返します。
;;  example:
;;    (string-scan "abracadabra" "ada" 'before) ==> "abrac"
;;    (string-scan "abracadabra" #\c 'before) ==> "abra"
;;after ------
;;  item より後ろにある string の部分文字列、あるいは
;;  item が見つからなければ #f を返します。
;;  example:
;;    (string-scan "abracadabra" "ada" 'after) ==> "bra"
;;    (string-scan "abracadabra" #\c 'after) ==> "adabra"
;;before* ------
;;  item の前にある string の部分文字列と後ろにある
;;  string の部分文字列を返します。item が見つからない場合は、
;;  (values #f #f) を返します。
;;  example:
;;    (string-scan "abracadabra" "ada" 'before*)
;;      ==> "abrac" and "adabra"
;;    (string-scan "abracadabra" #\c 'before*)
;;      ==> "abra" and "cadabra"
;;after* ------
;;  string のうち、item の終端までの部分文字列とその残りを
;;  返します。item が見つからなかった場合は、(values #f #f)
;;  を返します。
;;  example:
;;    (string-scan "abracadabra" "ada" 'after*)
;;      ==> "abracada" and "bra"
;;    (string-scan "abracadabra" #\c 'after*)
;;      ==> "abrac" and "adabra"
;;both ------
;;  string のうち、item の前と item の後ろの
;;  部分文字列を返します。item が見つからない場合、
;;  (values #f #f) を返します。
;;  example:
;;    (string-scan "abracadabra" "ada" 'both)
;;      ==> "abrac" and "bra"
;;    (string-scan "abracadabra" #\c 'both)
;;      ==> "abra" and "adabra"
;;
;;@param string 
;;@param item 
;;@param :optional 
;;@param return 

;;;;;
;;@type Function
;;@name string-join
;;@description [SRFI-13] リスト strs 中にある文字列を、文字列 delim を'糊'
;;として連結します。
;;
;;引数 grammer は、文字列がどのように連結されるかを指定する
;;シンボルで、以下のうちの一つです。
;;infix ------
;;  それぞれの文字列の間に delim を使います。このモードが
;;  デフォルトです。strs が空文字列かヌル文字列を含むリスト
;;  である場合は、曖昧に(適当に)動作します。
;;  example:
;;    (string-join '("apple" "mango" "banana") ", ") 
;;      ==> "apple, mango, banana"
;;    (string-join '() ":")
;;      ==> ""
;;    (string-join '("") ":")
;;      ==> ""
;;strict-infix ------
;;  infix のように動作しますが、strs には空リストは
;;  許されません。したがって、曖昧さはありません。
;;prefix ------
;;  delim をそれぞれの文字列の前に補います。
;;  example:
;;    (string-join '("usr" "local" "bin") "/" 'prefix)
;;      ==> "/usr/local/bin"
;;    (string-join '() "/" 'prefix)
;;      ==> ""
;;    (string-join '("") "/" 'prefix)
;;      ==> "/"
;;suffix ------
;;  delim をそれぞれの文字列の後ろに補います。
;;  example:
;;    (string-join '("a" "b" "c") "&" 'suffix)
;;      ==> "a&b&c&"
;;    (string-join '() "&" 'suffix)
;;      ==> ""
;;    (string-join '("") "&" 'suffix)
;;      ==> "&"
;;
;;
;;@param strs 
;;@param :optional 
;;@param delim 
;;@param grammer 

;;;;;
;;@type Function
;;@name string-fill!
;;@description [R5RS+][SRFI-13] string を char で埋めます。
;;オプションの start と end は、影響を受ける領域を
;;制限します。
;;example:
;;  (string-fill! "orange" #\X)
;;    ==> "XXXXXX"
;;  (string-fill! "orange" #\X 2 4)
;;    ==> "orXXge"
;;
;;@param string 
;;@param char 
;;@param :optional 
;;@param start 
;;@param end 

;;;;;
;;@type Function
;;@name string-byte-set!
;;@description stringのk番目のバイトを整数byteで置き換えます。
;;byteは0から255の範囲(255を含む)でなければなりません。
;;kは0以上、(string-size string)より小である必要があります。
;;stringが完全文字列の場合、この操作により不完全文字列になります。
;;戻り値は未定義です。
;;
;;@param string 
;;@param k 
;;@param byte 

;;;;;
;;@type Function
;;@name string-byte-ref
;;@description (多分、不完全な)文字列stringのk番目のバイトを返します。
;;戻り値は、0から255の範囲の整数です。kは0以上、
;;(string-size string)より小でなければなりません。
;;
;;@param string 
;;@param k 

;;;;;
;;@type Function
;;@name string-size
;;@description 文字列stringの大きさを返します。文字列の大きさは、
;;stringが占めるメモリ上のバイト数で、これは文字列の内部エンコーディングに
;;依存します。同じ文字列であっても内部エンコーディングが違えば違う大きさになる場合も
;;あります。
;;
;;不完全な文字列では、文字列の長さと大きさは常に一致します。
;;
;;@param string 

;;;;;
;;@type Method
;;@name x->string
;;@description 文字列への強制型変換手続きです。
;;objの文字列表現を返します。
;;デフォルトのメソッドでは、文字列はそのまま返され、数値はnumber->stringで、
;;シンボルはsymbol->stringで変換され、その他のオブジェクトはdisplay表現
;;が使われます。
;;
;;他のクラスはこのメソッドを定義することにより、独自の変換関数を提供することができます。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name make-byte-string
;;@description 大きさkの不完全な文字列を作成して返します。
;;byteが与えられた場合は、その下位1バイトで文字列の各バイトを初期化します。
;;byteは正確な整数でなければなりません。
;;
;;@param k 
;;@param :optional 
;;@param byte 

;;;;;
;;@type Function
;;@name string-incomplete?
;;@description objが不完全文字列なら#tを、そうでなければ#fを返します。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name string-immutable?
;;@description objが変更不可な文字列なら#tを、そうでなければ#fを返します。
;;
;;@param obj 

;;;;;
;;@type Class
;;@name <string>
;;@description 文字列のクラスです。Gaucheでは、文字列は文字のシーケンスともバイトのシーケンスとも
;;みなすことができます。
;;

;;;;;
;;@type Function
;;@name char-set-copy
;;@description [SRFI-14]
;;char-setのコピーを作って返します。
;;
;;@param char-set 

;;;;;
;;@type Function
;;@name char-set
;;@description [SRFI-14]
;;文字char ... からなる文字集合を作成して返します。
;;example:
;;  (char-set #\a #\b #\c)   ==> #[a-c]
;;  (char-set #\あ #\い #\う) ==> #[あいう]
;;
;;@param char 
;;@param ... 

;;;;;
;;@type Function
;;@name char-set-contains?
;;@description [SRFI-14]
;;文字集合char-setが文字charを含んでいれば真の値を返します。
;;example:
;;  (char-set-contains? #[a-z] #\y) ==> #t
;;  (char-set-contains? #[a-z] #\3) ==> #f
;;  
;;  (char-set-contains? #[^ABC] #\A) ==> #f
;;  (char-set-contains? #[^ABC] #\D) ==> #t
;;  
;;  (char-set-contains? #[あ-お] #\う) ==> #t
;;  (char-set-contains? #[あ-お] #\ぷ) ==> #f
;;
;;@param char-set 
;;@param char 

;;;;;
;;@type Function
;;@name char-set?
;;@description [SRFI-14]
;;objが文字集合であれば真の値を返します。
;;
;;@param obj 

;;;;;
;;@type Class
;;@name <char-set>
;;@description 文字の集合を取り扱う、文字集合(キャラクタセット)のクラスです。
;;Gaucheは文字集合オブジェクトのサポートと、
;;ある文字がその集合に属するかどうかを調べる手続きを言語組み込みで持っています。
;;
;;文字集合に関する他の操作、例えば集合演算などは、SRFI-14モジュール
;;(Character-set library参照) で提供されています。
;;

;;;;;
;;@type Function
;;@name supported-character-encodings
;;@description ネイティブなマルチバイトエンコーディングスキームでサポートされている
;;文字エンコーディングスキームの名前を表す文字列のリストを返します。
;;

;;;;;
;;@type Function
;;@name gauche-character-encoding
;;@description コンパイル時に選択された内部文字エンコーディングを表すシンボルを返します。
;;返される値は以下のいずれかです。
;;euc-jp ------
;;  EUC-JP
;;utf-8 ------
;;  UTF-8
;;sjis ------
;;  Shift JIS
;;none ------
;;  マルチバイトキャラクタをサポートしない(8ビット固定長文字)。
;;

;;;;;
;;@type Function
;;@name integer->digit
;;@description digit->integerの逆です。整数integerを radix進数 ひと桁で
;;表現するのに使われる文字を返します。integerがひと桁で表現できない数値の場合は
;;#fが返されます。
;;example:
;;  (integer->digit 13 16) ==> #\d
;;  (integer->digit 10) ==> #f
;;Common Lispのdigit-charに当たります。
;;
;;@param integer 
;;@param :optional 
;;@param (radix 10) 

;;;;;
;;@type Function
;;@name digit->integer
;;@description 文字charが radix進数の数字を構成するのに有効な文字であれば、
;;対応する整数が、そうでなければ#fが返されます。
;;example:
;;  (digit->integer #\4) ==> 4
;;  (digit->integer #\e 16) ==> 14
;;  (digit->integer #\9 8) ==> #f
;;Common Lispには同様の手続きがdigit-char-pというやや曖昧な名で定義されています。
;;
;;@param char 
;;@param :optional 
;;@param (radix 10) 

;;;;;
;;@type Function
;;@name char-foldcase
;;@description [R5RS+]
;;charの大文字、小文字、titlecase、foldcaseを
;;それぞれ返します。foldcaseは最初に大文字にしてそれから小文字にするのと同じ操作です。
;;
;;変換は原則としてUnicodeで定義された文字対文字のマッピングに従います。
;;Unicodeに従って変換する先の文字が内部エンコーディングでサポートされていない
;;場合は、変換は行いません。内部エンコーディングが'none'の場合は、
;;文字をLatin-1 (ISO-8859-1) であるとみなします。Latin-1の
;;small y with diaresis (U+00ff) をupcaseすると、
;;内部エンコーディングがutf-8の場合はcapital y with diaresis (U+039c)にマップされますが、
;;内部エンコーディングがnoneであれば元の文字がそのまま返されます。
;;
;;文字対文字のマッピングでは、一文字が複数文字に展開されるようなケースマッピングは
;;扱いません。有名な例はeszett (latin small letter sharp S, U+00df)で、
;;文字列のコンテキストでは二つの大文字のSへとマップされますが、
;;char-upcase #\s は単に #\s を返します。
;;完全なマッピングが必要なら、text.unicodeモジュールの
;;string-upcase等が利用できます
;;(Full string case conversion参照)。
;;
;;@param char 

;;;;;
;;@type Function
;;@name char-titlecase
;;@description [R5RS+]
;;charの大文字、小文字、titlecase、foldcaseを
;;それぞれ返します。foldcaseは最初に大文字にしてそれから小文字にするのと同じ操作です。
;;
;;変換は原則としてUnicodeで定義された文字対文字のマッピングに従います。
;;Unicodeに従って変換する先の文字が内部エンコーディングでサポートされていない
;;場合は、変換は行いません。内部エンコーディングが'none'の場合は、
;;文字をLatin-1 (ISO-8859-1) であるとみなします。Latin-1の
;;small y with diaresis (U+00ff) をupcaseすると、
;;内部エンコーディングがutf-8の場合はcapital y with diaresis (U+039c)にマップされますが、
;;内部エンコーディングがnoneであれば元の文字がそのまま返されます。
;;
;;文字対文字のマッピングでは、一文字が複数文字に展開されるようなケースマッピングは
;;扱いません。有名な例はeszett (latin small letter sharp S, U+00df)で、
;;文字列のコンテキストでは二つの大文字のSへとマップされますが、
;;char-upcase #\s は単に #\s を返します。
;;完全なマッピングが必要なら、text.unicodeモジュールの
;;string-upcase等が利用できます
;;(Full string case conversion参照)。
;;
;;@param char 

;;;;;
;;@type Function
;;@name ucs->char
;;@description それぞれ、文字charをUCSコードポイントを表す整数へ変換し、
;;またUCSコードポイントを表す整数nを文字へと変換する手続きです。
;;
;;Gaucheの内部文字エンコーディングがUTF-8でコンパイルされている場合は、
;;これらの手続きはそれぞれchar->integerおよびinteger->char
;;と等価です。
;;
;;Gaucheの内部文字エンコーディングがUTF-8でない場合、
;;これらの手続きはgauche.charconvモジュールを使って
;;内部文字コードとUCSとの変換を行います (Character code conversion参照)。
;;charが対応するUCSコードを持っていない場合、char->ucsは#fを
;;返します。UCSコードnに対応する文字が内部エンコーディングで定義されていない
;;場合、変換ルーチンが代替文字を提供していればそれを、そうでなければ#f
;;が返されます。
;;
;;@param n 

;;;;;
;;@type Function
;;@name char->ucs
;;@description それぞれ、文字charをUCSコードポイントを表す整数へ変換し、
;;またUCSコードポイントを表す整数nを文字へと変換する手続きです。
;;
;;Gaucheの内部文字エンコーディングがUTF-8でコンパイルされている場合は、
;;これらの手続きはそれぞれchar->integerおよびinteger->char
;;と等価です。
;;
;;Gaucheの内部文字エンコーディングがUTF-8でない場合、
;;これらの手続きはgauche.charconvモジュールを使って
;;内部文字コードとUCSとの変換を行います (Character code conversion参照)。
;;charが対応するUCSコードを持っていない場合、char->ucsは#fを
;;返します。UCSコードnに対応する文字が内部エンコーディングで定義されていない
;;場合、変換ルーチンが代替文字を提供していればそれを、そうでなければ#f
;;が返されます。
;;
;;@param char 

;;;;;
;;@type Class
;;@name <char>

;;;;;
;;@type Function
;;@name identifier->symbol
;;@param identifier 

;;;;;
;;@type Function
;;@name identifier?
;;@param obj 

;;;;;
;;@type Class
;;@name <identifier>

;;;;;
;;@type Function
;;@name delete-keywords!
;;@description delete-keywordやdelete-keyword!と似ていますが、
;;keysにオブジェクトのリストを指定できます。
;;kv-list中のキーがkeysのうちのどれかに一致すれば、
;;そのキーと続く値がkv-listから取り除かれます。
;;
;;example:
;;  (delete-keywords '(:x :y) '(:x 1 :y 2 :z 3 :y 4))
;;   ==> (:z 3)
;;
;;
;;@param keys 
;;@param kv-list 

;;;;;
;;@type Function
;;@name delete-keywords
;;@description delete-keywordやdelete-keyword!と似ていますが、
;;keysにオブジェクトのリストを指定できます。
;;kv-list中のキーがkeysのうちのどれかに一致すれば、
;;そのキーと続く値がkv-listから取り除かれます。
;;
;;example:
;;  (delete-keywords '(:x :y) '(:x 1 :y 2 :z 3 :y 4))
;;   ==> (:z 3)
;;
;;
;;@param keys 
;;@param kv-list 

;;;;;
;;@type Function
;;@name delete-keyword!
;;@description kv-list から key に eq? であるキーをもつキーと値を
;;削除します。
;;
;;delete-keyword は kv-list を変更しません。しかし、
;;返されたリストは共通の末尾部分を共有します。
;;
;;delete-keyword! は新しくアロケートされることはありません。
;;そして、破壊的に kv-list を変更する可能性があります。
;;最初のキーがマッチした場合元のリストは変更されないこともありえますが、
;;返り値のリストを使わなければいけません。
;;
;;key にマッチするキーがない場合 kv-list が返ります。
;;
;;example:
;;  (delete-keyword :y '(:x 1 :y 2 :z 3 :y 4))
;;   ==> (:x 1 :z 3)
;;
;;
;;@param key 
;;@param kv-list 

;;;;;
;;@type Function
;;@name delete-keyword
;;@description kv-list から key に eq? であるキーをもつキーと値を
;;削除します。
;;
;;delete-keyword は kv-list を変更しません。しかし、
;;返されたリストは共通の末尾部分を共有します。
;;
;;delete-keyword! は新しくアロケートされることはありません。
;;そして、破壊的に kv-list を変更する可能性があります。
;;最初のキーがマッチした場合元のリストは変更されないこともありえますが、
;;返り値のリストを使わなければいけません。
;;
;;key にマッチするキーがない場合 kv-list が返ります。
;;
;;example:
;;  (delete-keyword :y '(:x 1 :y 2 :z 3 :y 4))
;;   ==> (:x 1 :z 3)
;;
;;
;;@param key 
;;@param kv-list 

;;;;;
;;@type Macro
;;@name get-keyword*
;;@description get-keyword と同様ですが、kv-list が key を
;;含まない場合にのみ fallback が評価されることだけが違います。
;;
;;@param key 
;;@param kv-list 
;;@param :optional 
;;@param fallback 

;;;;;
;;@type Function
;;@name get-keyword
;;@description キー-値のリストから値を取り出すのに便利な手続きです。
;;キー-値のリスト kv-list は偶数個の要素を持たなければなりません。
;;1つ目、3つ目、5つ目、... の要素はキーとして扱われ、
;;2つ目、4つ目、6つ目、... の要素は、その前の要素をキーとした値と
;;なります。
;;
;;この手続きは、キーの集合から key を探して、それが見つかれば、
;;対応する値を返します。
;;2つ以上のキーにマッチしたら、最左のものとなります。
;;マッチするキーがない場合、fallback が与えられていればそれを
;;返し、さもなければエラーを通知します。
;;
;;kv-list が正しい偶数個の要素を持つリストでない場合は、エラーに
;;なります。
;;
;;キーワード-値リストの `キーワード' と、key 引数は、実際には
;;キーワードである必要はありません。いかなる Scheme オブジェクトで
;;あっても良いです。キーの比較は、eq? によって行われます。
;;
;;この手続きは、STk から導入されました。
;;
;;example:
;;  (get-keyword :y '(:x 1 :y 2 :z 3))
;;    ==> 2
;;  (get-keyword 'z '(x 1 y 2 z 3))
;;    ==> 3
;;  
;;  (get-keyword :t '(:x 1 :y 2 :z 3))
;;    ==> #<error>
;;  (get-keyword :t '(:x 1 :y 2 :z 3) #f)
;;    ==> #f
;;
;;@param key 
;;@param kv-list 
;;@param :optional 
;;@param fallback 

;;;;;
;;@type Function
;;@name keyword->string
;;@description キーワード keyword の名前を文字列で返します。
;;example:
;;  (keyword->string :foo) ==> "foo"
;;
;;@param keyword 

;;;;;
;;@type Function
;;@name make-keyword
;;@description 名前が name であるキーワードを返します。nameには
;;文字列かシンボルが許されます。
;;example:
;;  (make-keyword "foo")  ==> :foo
;;  
;;  (make-keyword 'foo)   ==> :foo
;;
;;@param name 

;;;;;
;;@type Function
;;@name keyword?
;;@description obj がキーワードであれば、#t を返します。
;;
;;@param obj 

;;;;;
;;@type Class
;;@name <keyword>
;;@description キーワードは特別なシンボルの一種で、自動的にクォートされます。
;;名前で渡す引数(キーワード引数)や、キーワード-値のリストで広く使われて
;;います。
;;CommonLisp とは異なり、キーワードとシンボルは別々の型として扱われます。
;;
;;Gaucheにおけるキーワード引数のサポートについてはMaking Proceduresを、
;;また独自にキーワード-値リストをパーズする方法については
;;let-keywords マクロ(Optional argument parsing) も参照して下さい。
;;

;;;;;
;;@type Function
;;@name symbol-sans-prefix
;;@description symbolとprefixは共にシンボルでなければなりません。
;;prefixがsymbolの先頭部分にマッチした場合、
;;symbolからマッチ部分を取り除いた名前を持つシンボルを返します。
;;マッチしない場合は#fを返します。
;;
;;example:
;;  (symbol-sans-prefix 'foo:bar 'foo:) ==> bar
;;  (symbol-sans-prefix 'foo:bar 'baz:) ==> #f
;;
;;@param symbol 
;;@param prefix 

;;;;;
;;@type Function
;;@name gensym
;;@description インターンされてない、新しいシンボルを作って返します。
;;返されるシンボルは、他のシンボルとは決してeq?にならないことが保証されます。
;;prefixが与えられた場合は、それは文字列でなければならず、
;;それが作られるシンボルのプレフィクスに使われます。これは主としてデバッグを
;;容易にするためのものです。
;;
;;@param :optional 
;;@param prefix 

;;;;;
;;@type Function
;;@name string->uninterned-symbol
;;@description string->symbolと似ていますが、作られたシンボルはインターンされません。
;;
;;example:
;;  (string->uninterned-symbol "a") ==> #:a
;;
;;@param string 

;;;;;
;;@type Function
;;@name symbol-interned?
;;@description シンボルsymbolがインターンされていらば#tを、
;;そうでなければ#fを返します。シンボルでないものが渡された場合はエラーとなります。
;;
;;@param symbol 

;;;;;
;;@type Class
;;@name <symbol>
;;@description シンボルを表すクラスです。
;;

;;;;;
;;@type Function
;;@name reverse!
;;@description [SRFI-1]
;;listの各要素を逆順に持つリストを返します。結果を作成するために、
;;listのセルは再利用されるかもしれません。
;;
;;@param list 

;;;;;
;;@type Function
;;@name append!
;;@description [SRFI-1]
;;渡されたリストの要素を繋げたリストを返します。最後の引数以外のリストのセルは、結果を
;;作成するために再利用されるかもしれません。
;;最後の引数は正規のリストである必要はありません。
;;
;;@param list 
;;@param ... 

;;;;;
;;@type Function
;;@name last-pair
;;@description [SRFI-1]
;;listの最後のペアを返します。listは
;;正規のリストかドットリストです。
;;
;;@param list 

;;;;;
;;@type Function
;;@name list-copy
;;@description [SRFI-1]
;;listの浅いコピーを行います。
;;listが循環リストの場合、この手続きは停止しません。
;;
;;@param list 

;;;;;
;;@type Function
;;@name list*
;;@description listとほぼ同じですが、最後の引数が作成されるリストの最後のペアのcdrになります。
;;SRFI-1ではこの手続きがcons*という名で定義されています。
;;example:
;;  (list* 1 2 3) ==> (1 2 . 3)
;;  (list* 1) ==> 1
;;
;;@param obj1 
;;@param obj2 
;;@param ... 

;;;;;
;;@type Function
;;@name make-list
;;@description [SRFI-1]
;;長さlenの正規のリストを返します。引数fillが与えられていれば、各要素は
;;fillになります。そうでなければ各要素の値は不定です。
;;example:
;;  (make-list 5 #t) ==> (#t #t #t #t #t)
;;
;;@param len 
;;@param :optional 
;;@param fill 

;;;;;
;;@type Function
;;@name acons
;;@description (cons (cons obj1 obj2) obj3) を返します。
;;連想リストの先頭に新しいエントリを加えるのに便利です。
;;example:
;;  (acons 'a 'b '((c . d))) ==> ((a . b) (c . d))
;;
;;@param obj1 
;;@param obj2 
;;@param obj3 

;;;;;
;;@type Class
;;@name <pair>
;;@description ペアのクラスです。
;;

;;;;;
;;@type Class
;;@name <null>
;;@description 空リストのクラスです。()がこのクラスの唯一のインスタンスです。
;;

;;;;;
;;@type Class
;;@name <list>
;;@description リストを表す抽象クラスで、クラス<null>とクラス<pair>の親クラスです。
;;クラス<sequence>を継承します。
;;
;;循環リストやドットリストも<list>クラスのインスタンスですが、
;;list?は偽の値を返すことに注意して下さい。
;;example:
;;  (use srfi-1)
;;  (list? (circular-list 1 2)) ==> #f
;;  (is-a? (circular-list 1 2) <list>) ==> #t
;;

;;;;;
;;@type Function
;;@name undefined
;;@description 未定義値を返します。
;;

;;;;;
;;@type Function
;;@name undefined?
;;@description objが未定義値である場合に限り#tを返します。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name boolean
;;@description objが#fであるとき#fを返し、それ以外の場合は#tを
;;返します。値を論理値に変換したい場合に便利です。
;;
;;@param obj 

;;;;;
;;@type Class
;;@name <boolean>
;;@description 論理値のクラスです。#tと#fのみがこのクラスのインスタンスです。
;;

;;;;;
;;@type Function
;;@name native-endian
;;@description システムのエンディアンを示すシンボルを返します。
;;

;;;;;
;;@type Parameter
;;@name default-endian
;;@description これは、バイナリ入出力ルーチンでendian指定が省略された場合に
;;共通して使われるエンディアンを指定する動的パラメータです
;;(Parameters参照)。
;;このパラメータの初期値はシステムのネイティブエンディアンです。
;;

;;;;;
;;@type Function
;;@name integer-length
;;@description [SRFI-60]
;;正確な整数nを表現するのに必要な最小ビット数を返します。負の数は2
;;の補数で表現されるものと仮定しています。符号用のビットは考慮しません。
;;
;;example:
;;  (integer-length 255)  ==> 8
;;  (integer-length 256)  ==> 9
;;  
;;  (integer-length -256)  ==> 8
;;  (integer-length -257)  ==> 9
;;
;;@param n 

;;;;;
;;@type Function
;;@name logcount
;;@description [SRFI-60]
;;nが正なら、nのビットのうち1の個数を返します。n
;;が負なら、nの2に関する補数のビットのうち0の個数を返します。
;;
;;example:
;;  (logcount 0)      ==> 0
;;  (logcount #b0010) ==> 1
;;  (logcount #b0110) ==> 2
;;  (logcount #b1111) ==> 4
;;  
;;  (logcount #b-0001) ==> 0  ;; 2の補数:  ....111111
;;  (logcount #b-0010) ==> 1  ;; 2の補数:  ....111110
;;  (logcount #b-0011) ==> 1  ;; 2の補数:  ....111101
;;  (logcount #b-0100) ==> 2  ;; 2の補数:  ....111100
;;
;;@param n 

;;;;;
;;@type Function
;;@name copy-bit-field
;;@description [SRFI-60]
;;正確な整数を返します。この整数の各ビットはstart番目のビット(この
;;ビットを含む)からend番目のビット(このビットは含まない)の部分以外
;;はnと同じで、この区間のビットは、正確な数fromの下位
;;(end-start)ビットのコピーです。
;;
;;example:
;;  (number->string (copy-bit-field #b10000000 1 5 -1) 2)
;;    ==> "10011110"
;;  
;;  (number->string (copy-bit-field #b10000000 1 7 #b010101010) 2)
;;    ==> "11010100"
;;
;;@param n 
;;@param start 
;;@param end 
;;@param from 

;;;;;
;;@type Function
;;@name copy-bit
;;@description [SRFI-60]
;;bitが真の値なら、整数nのindexビット目をセットした数値を
;;返します。
;;bitが偽の値なら、整数nのindexビット目をリセットした数値を
;;返します。
;;
;;@param index 
;;@param n 
;;@param bit 

;;;;;
;;@type Function
;;@name bit-field
;;@description [SRFI-60]
;;整数nのstartビット目(含む)からendビット目(含まない)までを
;;取り出した数値を返します。start < end でなければなりません。
;;
;;@param n 
;;@param start 
;;@param end 

;;;;;
;;@type Function
;;@name logbit?
;;@description [SRFI-60]
;;整数nのindex目のビットが1ならば#tを、0ならば#fを
;;返します。
;;
;;@param index 
;;@param n 

;;;;;
;;@type Function
;;@name logtest
;;@description [SRFI-60]
;;≡  (not (zero? (logand n1 n2 ...)))
;;
;;@param n1 
;;@param n2 
;;@param ... 

;;;;;
;;@type Function
;;@name lognot
;;@description [SRFI-60]
;;整数nのビット否定を返します。
;;
;;@param n 

;;;;;
;;@type Function
;;@name logxor
;;@description [SRFI-60]
;;整数n1 ...の、それぞれビット論理積、
;;ビット論理和、ビット排他的論理積を返します。
;;ゼロ個の引数が与えられた場合は、logandは-1を、
;;logiorとlogxorは0を返します。
;;
;;@param n1 
;;@param ... 

;;;;;
;;@type Function
;;@name logior
;;@description [SRFI-60]
;;整数n1 ...の、それぞれビット論理積、
;;ビット論理和、ビット排他的論理積を返します。
;;ゼロ個の引数が与えられた場合は、logandは-1を、
;;logiorとlogxorは0を返します。
;;
;;@param n1 
;;@param ... 

;;;;;
;;@type Function
;;@name logand
;;@description [SRFI-60]
;;整数n1 ...の、それぞれビット論理積、
;;ビット論理和、ビット排他的論理積を返します。
;;ゼロ個の引数が与えられた場合は、logandは-1を、
;;logiorとlogxorは0を返します。
;;
;;@param n1 
;;@param ... 

;;;;;
;;@type Function
;;@name ash
;;@description [SRFI-60]
;;整数nを左に整数countビットだけシフトします。
;;countが負であれば、@minus{}countだけnを右にシフトします。
;;
;;example:
;;  ; @r{Note: 6  ≡  [...00110], and}
;;  ; @r{      -6 ≡  [...11010]}
;;  (ash 6 2)   ==> 24  ;[...0011000]
;;  (ash 6 -2)  ==> 1   ;[...0000001]
;;  (ash -6 2)  ==> -24 ;[...1101000]
;;  (ash -6 -2) ==> -2  ;[...1111110]
;;
;;@param n 
;;@param count 

;;;;;
;;@type Method
;;@name x->integer
;;@description 数値への強制型変換手続きです。
;;objをそれぞれ数値もしくは正確な整数と解釈して返します。
;;数値と文字列に対してのメソッドは定義されています
;;(文字列はstring->numberを使って変換されます。
;;数値として解釈できない文字列に関しては0が返されます)。
;;その他のobjについては単に0が返されます。
;;x->integerは、objが数値として表現できるけれど正確な整数では
;;ない場合、roundとinexact->exactによって正確な整数に変換します。
;;
;;他のクラスはこのメソッドを定義することにより、独自の変換関数を提供することができます。
;;
;;@param obj 

;;;;;
;;@type Method
;;@name x->number
;;@description 数値への強制型変換手続きです。
;;objをそれぞれ数値もしくは正確な整数と解釈して返します。
;;数値と文字列に対してのメソッドは定義されています
;;(文字列はstring->numberを使って変換されます。
;;数値として解釈できない文字列に関しては0が返されます)。
;;その他のobjについては単に0が返されます。
;;x->integerは、objが数値として表現できるけれど正確な整数では
;;ない場合、roundとinexact->exactによって正確な整数に変換します。
;;
;;他のクラスはこのメソッドを定義することにより、独自の変換関数を提供することができます。
;;
;;@param obj 

;;;;;
;;@type Function
;;@name ldexp
;;@description [POSIX] 
;;これらの手続きは、浮動小数点数を分解したり合成するのに使えます。
;;fmodは実数xを実数yで割った余りを返します。すなわち、
;;x/yを0に近いほうの整数に丸めた値をnとするとき、
;;x-n*yを返します。
;;modfはxの少数部と整数部を返します。
;;frexpは実数xを、仮数部と指数部に分解して返します。すなわち、
;;x = fraction * 2^exponent かつ 0 <= fraction <= 0.5
;;であるところのfractionとexponentを返します。
;;ldexpはfrexpの逆関数で、x * 2^n を返します。
;;example:
;;  (fmod 32.1 10.0)  ==> 2.1
;;  (fmod 1.5 1.4)    ==> 0.1
;;  (modf 12.5)       ==> 0.5 and 12.0
;;  (frexp 3.14)      ==> 0.785 and 2
;;  (ldexp 0.785 2)   ==> 3.14
;;
;;@param x 
;;@param n 

;;;;;
;;@type Function
;;@name frexp
;;@description [POSIX] 
;;これらの手続きは、浮動小数点数を分解したり合成するのに使えます。
;;fmodは実数xを実数yで割った余りを返します。すなわち、
;;x/yを0に近いほうの整数に丸めた値をnとするとき、
;;x-n*yを返します。
;;modfはxの少数部と整数部を返します。
;;frexpは実数xを、仮数部と指数部に分解して返します。すなわち、
;;x = fraction * 2^exponent かつ 0 <= fraction <= 0.5
;;であるところのfractionとexponentを返します。
;;ldexpはfrexpの逆関数で、x * 2^n を返します。
;;example:
;;  (fmod 32.1 10.0)  ==> 2.1
;;  (fmod 1.5 1.4)    ==> 0.1
;;  (modf 12.5)       ==> 0.5 and 12.0
;;  (frexp 3.14)      ==> 0.785 and 2
;;  (ldexp 0.785 2)   ==> 3.14
;;
;;@param x 

;;;;;
;;@type Function
;;@name modf
;;@description [POSIX] 
;;これらの手続きは、浮動小数点数を分解したり合成するのに使えます。
;;fmodは実数xを実数yで割った余りを返します。すなわち、
;;x/yを0に近いほうの整数に丸めた値をnとするとき、
;;x-n*yを返します。
;;modfはxの少数部と整数部を返します。
;;frexpは実数xを、仮数部と指数部に分解して返します。すなわち、
;;x = fraction * 2^exponent かつ 0 <= fraction <= 0.5
;;であるところのfractionとexponentを返します。
;;ldexpはfrexpの逆関数で、x * 2^n を返します。
;;example:
;;  (fmod 32.1 10.0)  ==> 2.1
;;  (fmod 1.5 1.4)    ==> 0.1
;;  (modf 12.5)       ==> 0.5 and 12.0
;;  (frexp 3.14)      ==> 0.785 and 2
;;  (ldexp 0.785 2)   ==> 3.14
;;
;;@param x 

;;;;;
;;@type Function
;;@name fmod
;;@description [POSIX] 
;;これらの手続きは、浮動小数点数を分解したり合成するのに使えます。
;;fmodは実数xを実数yで割った余りを返します。すなわち、
;;x/yを0に近いほうの整数に丸めた値をnとするとき、
;;x-n*yを返します。
;;modfはxの少数部と整数部を返します。
;;frexpは実数xを、仮数部と指数部に分解して返します。すなわち、
;;x = fraction * 2^exponent かつ 0 <= fraction <= 0.5
;;であるところのfractionとexponentを返します。
;;ldexpはfrexpの逆関数で、x * 2^n を返します。
;;example:
;;  (fmod 32.1 10.0)  ==> 2.1
;;  (fmod 1.5 1.4)    ==> 0.1
;;  (modf 12.5)       ==> 0.5 and 12.0
;;  (frexp 3.14)      ==> 0.785 and 2
;;  (ldexp 0.785 2)   ==> 3.14
;;
;;@param x 
;;@param y 

;;;;;
;;@type Function
;;@name decode-float
;;@description 与えられた浮動小数点数xに対して、
;;3つの正確な整数からなるベクタ #(m, e, sign)
;;を返します。ここで、
;;example:
;;    x = (* sign m (expt 2.0 e))
;;    sign は 1, 0 または -1.
;;です。このAPIはChezSchemeから取られました。
;;example:
;;  (decode-float 3.1415926)
;;   ==> #(7074237631354954 -51 1)
;;  (* 7074237631354954 (expt 2.0 -51))
;;   ==> 3.1415926
;;
;;@param x 

;;;;;
;;@type Function
;;@name least-fixnum
;;@description [R6RS]
;;These procedures return the width of fixnum (w),
;;the greatest integer representable by fixnum (@var{2^w - 1}),
;;and the least integer representable by fixnum (@var{- 2^w}),
;;respectively.  You might want to care the fixnum range when
;;you are writing a performance-critical section.
;;
;;These names are defined in R6RS.  Common Lisp and ChezScheme have
;;most-positive-fixnum and most-negative-fixnum.
;;

;;;;;
;;@type Function
;;@name greatest-fixnum
;;@description [R6RS]
;;These procedures return the width of fixnum (w),
;;the greatest integer representable by fixnum (@var{2^w - 1}),
;;and the least integer representable by fixnum (@var{- 2^w}),
;;respectively.  You might want to care the fixnum range when
;;you are writing a performance-critical section.
;;
;;These names are defined in R6RS.  Common Lisp and ChezScheme have
;;most-positive-fixnum and most-negative-fixnum.
;;

;;;;;
;;@type Function
;;@name fixnum-width
;;@description [R6RS]
;;These procedures return the width of fixnum (w),
;;the greatest integer representable by fixnum (@var{2^w - 1}),
;;and the least integer representable by fixnum (@var{- 2^w}),
;;respectively.  You might want to care the fixnum range when
;;you are writing a performance-critical section.
;;
;;These names are defined in R6RS.  Common Lisp and ChezScheme have
;;most-positive-fixnum and most-negative-fixnum.
;;

;;;;;
;;@type Function
;;@name atanh
;;@description 双曲線関数です。複素数も扱えます。
;;
;;@param z 

;;;;;
;;@type Function
;;@name acosh
;;@description 双曲線関数です。複素数も扱えます。
;;
;;@param z 

;;;;;
;;@type Function
;;@name asinh
;;@description 双曲線関数です。複素数も扱えます。
;;
;;@param z 

;;;;;
;;@type Function
;;@name tanh
;;@description 双曲線関数です。複素数も扱えます。
;;
;;@param z 

;;;;;
;;@type Function
;;@name cosh
;;@description 双曲線関数です。複素数も扱えます。
;;
;;@param z 

;;;;;
;;@type Function
;;@name sinh
;;@description 双曲線関数です。複素数も扱えます。
;;
;;@param z 

;;;;;
;;@type Function
;;@name clamp
;;@description example:
;;   min if x < min
;;   x   if min <= x <= max
;;   max if max < x
;;を返します。もしminまたはmaxが省略されるか#fが与えられたら、
;;それぞれ -∞ もしくは +∞ と解釈されます。
;;与えられた全ての数値が正確な整数の場合に限り正確な整数を返します。
;;example:
;;  (clamp 3.1 0.0 1.0) ==> 1.0
;;  (clamp 0.5 0.0 1.0) ==> 0.5
;;  (clamp -0.3 0.0 1.0) ==> 0.0
;;  (clamp -5 0)        ==> 0
;;  (clamp 3724 #f 256) ==> 256
;;
;;@param x 
;;@param :optional 
;;@param min 
;;@param max 

;;;;;
;;@type Function
;;@name round->exact
;;@description これらは、頻出する(inexact->exact (floor x)) 等を簡潔に書くための
;;手続きです。
;;
;;@param x 

;;;;;
;;@type Function
;;@name truncate->exact
;;@description これらは、頻出する(inexact->exact (floor x)) 等を簡潔に書くための
;;手続きです。
;;
;;@param x 

;;;;;
;;@type Function
;;@name ceiling->exact
;;@description これらは、頻出する(inexact->exact (floor x)) 等を簡潔に書くための
;;手続きです。
;;
;;@param x 

;;;;;
;;@type Function
;;@name floor->exact
;;@description これらは、頻出する(inexact->exact (floor x)) 等を簡潔に書くための
;;手続きです。
;;
;;@param x 

;;;;;
;;@type Function
;;@name quotient&remainder
;;@description 整数n1を整数n2で割った商(quotient)および余り(remainder)
;;を同時に計算し、2つの値として返します。
;;
;;@param n1 
;;@param n2 

;;;;;
;;@type Function
;;@name /.
;;@description +、*、-、/と同様ですが、引数は不正確な
;;数へと変換され、結果も常に不正確な数となります。
;;正確数による計算が不要で、bignumや正確な有理数をうっかり使ってしまう
;;ことによるオーバヘッドを避けたい時に便利です。
;;
;;@param z1 
;;@param z2 
;;@param ... 

;;;;;
;;@type Function
;;@name -.
;;@description +、*、-、/と同様ですが、引数は不正確な
;;数へと変換され、結果も常に不正確な数となります。
;;正確数による計算が不要で、bignumや正確な有理数をうっかり使ってしまう
;;ことによるオーバヘッドを避けたい時に便利です。
;;
;;@param z1 
;;@param z2 
;;@param ... 

;;;;;
;;@type Function
;;@name +.
;;@description +、*、-、/と同様ですが、引数は不正確な
;;数へと変換され、結果も常に不正確な数となります。
;;正確数による計算が不要で、bignumや正確な有理数をうっかり使ってしまう
;;ことによるオーバヘッドを避けたい時に便利です。
;;
;;@param z 
;;@param ... 

;;;;;
;;@type Function
;;@name min&max
;;@description 与えられた実数から、最大値と最小値の二つの値を返します。
;;
;;@param x1 
;;@param x2 
;;@param ... 

;;;;;
;;@type Function
;;@name bignum?
;;@description nが正確な整数で、かつ内部的にそれぞれfixnumもしくはbignum
;;で表現されているときに#tを返します。
;;通常のSchemeプログラムは整数の内部表現を気にする必要はありません。
;;これらの手続きは、ある種の最適化を行う低レベル手続きのために用意されています。
;;
;;@param n 

;;;;;
;;@type Function
;;@name fixnum?
;;@description nが正確な整数で、かつ内部的にそれぞれfixnumもしくはbignum
;;で表現されているときに#tを返します。
;;通常のSchemeプログラムは整数の内部表現を気にする必要はありません。
;;これらの手続きは、ある種の最適化を行う低レベル手続きのために用意されています。
;;
;;@param n 

;;;;;
;;@type Function
;;@name nan?
;;@description [R6RS]
;;実数に対して、それが有限、無限、NaNであればそれぞれ#tを返します。
;;
;;非実数の複素数に対しては、finite?は実数部と仮数部がともに
;;有限なら#tを、infinite?は実数部と仮数部の少なくともどちらかが
;;無限なら#tを、nan?は実数部と仮数部の少なくともどちらかが
;;NaNなら#tを返します。(これはR6RSとは非互換です。R6RSでは
;;これらの手続きは引数に非実数の数が与えられた場合はエラーを通知しなければならないからです。)
;;
;;@param z 

;;;;;
;;@type Function
;;@name infinite?
;;@description [R6RS]
;;実数に対して、それが有限、無限、NaNであればそれぞれ#tを返します。
;;
;;非実数の複素数に対しては、finite?は実数部と仮数部がともに
;;有限なら#tを、infinite?は実数部と仮数部の少なくともどちらかが
;;無限なら#tを、nan?は実数部と仮数部の少なくともどちらかが
;;NaNなら#tを返します。(これはR6RSとは非互換です。R6RSでは
;;これらの手続きは引数に非実数の数が与えられた場合はエラーを通知しなければならないからです。)
;;
;;@param z 

;;;;;
;;@type Function
;;@name finite?
;;@description [R6RS]
;;実数に対して、それが有限、無限、NaNであればそれぞれ#tを返します。
;;
;;非実数の複素数に対しては、finite?は実数部と仮数部がともに
;;有限なら#tを、infinite?は実数部と仮数部の少なくともどちらかが
;;無限なら#tを、nan?は実数部と仮数部の少なくともどちらかが
;;NaNなら#tを返します。(これはR6RSとは非互換です。R6RSでは
;;これらの手続きは引数に非実数の数が与えられた場合はエラーを通知しなければならないからです。)
;;
;;@param z 

;;;;;
;;@type Class
;;@name <integer>
;;@description 数値オブジェクトのクラス階層を構成します。<complex>は
;;<number>を継承し、<real>は<complex>を継承し、
;;<rational>は<real>を継承し、
;;<integer>は<rational>を継承します。
;;
;;これらのクラスはR5RSで定義されている数値の階層とは必ずしも対応しません。
;;特に、<integer>クラスのインスタンスはR5RSでいうexact integerのみになります。
;;example:
;;  (integer? 1)        ==> #t
;;  (is-a? 1 <integer>) ==> #t
;;  (is-a? 1 <real>)    ==> #t
;;  
;;  (integer? 1.0)        ==> #t
;;  (is-a? 1.0 <integer>) ==> #f
;;  (is-a? 1.0 <real>)    ==> #t
;;  
;;  (class-of (expt 2 100)) ==> #<class <integer>>
;;  (class-of (sqrt -3)) ==> #<class <complex>>
;;

;;;;;
;;@type Class
;;@name <rational>
;;@description 数値オブジェクトのクラス階層を構成します。<complex>は
;;<number>を継承し、<real>は<complex>を継承し、
;;<rational>は<real>を継承し、
;;<integer>は<rational>を継承します。
;;
;;これらのクラスはR5RSで定義されている数値の階層とは必ずしも対応しません。
;;特に、<integer>クラスのインスタンスはR5RSでいうexact integerのみになります。
;;example:
;;  (integer? 1)        ==> #t
;;  (is-a? 1 <integer>) ==> #t
;;  (is-a? 1 <real>)    ==> #t
;;  
;;  (integer? 1.0)        ==> #t
;;  (is-a? 1.0 <integer>) ==> #f
;;  (is-a? 1.0 <real>)    ==> #t
;;  
;;  (class-of (expt 2 100)) ==> #<class <integer>>
;;  (class-of (sqrt -3)) ==> #<class <complex>>
;;

;;;;;
;;@type Class
;;@name <real>
;;@description 数値オブジェクトのクラス階層を構成します。<complex>は
;;<number>を継承し、<real>は<complex>を継承し、
;;<rational>は<real>を継承し、
;;<integer>は<rational>を継承します。
;;
;;これらのクラスはR5RSで定義されている数値の階層とは必ずしも対応しません。
;;特に、<integer>クラスのインスタンスはR5RSでいうexact integerのみになります。
;;example:
;;  (integer? 1)        ==> #t
;;  (is-a? 1 <integer>) ==> #t
;;  (is-a? 1 <real>)    ==> #t
;;  
;;  (integer? 1.0)        ==> #t
;;  (is-a? 1.0 <integer>) ==> #f
;;  (is-a? 1.0 <real>)    ==> #t
;;  
;;  (class-of (expt 2 100)) ==> #<class <integer>>
;;  (class-of (sqrt -3)) ==> #<class <complex>>
;;

;;;;;
;;@type Class
;;@name <complex>
;;@description 数値オブジェクトのクラス階層を構成します。<complex>は
;;<number>を継承し、<real>は<complex>を継承し、
;;<rational>は<real>を継承し、
;;<integer>は<rational>を継承します。
;;
;;これらのクラスはR5RSで定義されている数値の階層とは必ずしも対応しません。
;;特に、<integer>クラスのインスタンスはR5RSでいうexact integerのみになります。
;;example:
;;  (integer? 1)        ==> #t
;;  (is-a? 1 <integer>) ==> #t
;;  (is-a? 1 <real>)    ==> #t
;;  
;;  (integer? 1.0)        ==> #t
;;  (is-a? 1.0 <integer>) ==> #f
;;  (is-a? 1.0 <real>)    ==> #t
;;  
;;  (class-of (expt 2 100)) ==> #<class <integer>>
;;  (class-of (sqrt -3)) ==> #<class <complex>>
;;

;;;;;
;;@type Class
;;@name <number>
;;@description 数値オブジェクトのクラス階層を構成します。<complex>は
;;<number>を継承し、<real>は<complex>を継承し、
;;<rational>は<real>を継承し、
;;<integer>は<rational>を継承します。
;;
;;これらのクラスはR5RSで定義されている数値の階層とは必ずしも対応しません。
;;特に、<integer>クラスのインスタンスはR5RSでいうexact integerのみになります。
;;example:
;;  (integer? 1)        ==> #t
;;  (is-a? 1 <integer>) ==> #t
;;  (is-a? 1 <real>)    ==> #t
;;  
;;  (integer? 1.0)        ==> #t
;;  (is-a? 1.0 <integer>) ==> #f
;;  (is-a? 1.0 <real>)    ==> #t
;;  
;;  (class-of (expt 2 100)) ==> #<class <integer>>
;;  (class-of (sqrt -3)) ==> #<class <complex>>
;;

;;;;;
;;@type Method
;;@name object-equal?
;;@description equal?が未知のオブジェクトに対して呼ばれた場合、
;;このジェネリックファンクションが呼ばれます。自分で定義したクラスに対して
;;このメソッドを定義することにより、equal?で等価判定が行えるように
;;なります。メソッドは、obj1とobj2が等価ならば#tを、
;;そうでなければ#fを返さねばなりません。
;;オブジェクトの各要素に対して再帰的に等価判定を行いたい場合は、
;;object-equal?を直接呼ぶのではなく、equal?を各要素に対して
;;呼ぶようにして下さい。
;;
;;example:
;;  (define-class <foo> ()
;;    ((x :init-keyword :x)
;;     (y :init-keyword :y)))
;;  
;;  (define-method object-equal? ((a <foo>) (b <foo>))
;;    (and (equal? (slot-ref a 'x) (slot-ref b 'x))
;;         (equal? (slot-ref a 'y) (slot-ref b 'y))))
;;  
;;  (equal? (make <foo> :x 1 :y (list 'a 'b))
;;          (make <foo> :x 1 :y (list 'a 'b)))
;;    ==> #t
;;  
;;  (equal? (make <foo> :x 1 :y (make <foo> :x 3 :y 4))
;;          (make <foo> :x 1 :y (make <foo> :x 3 :y 4)))
;;    ==> #t
;;
;;@param obj1 
;;@param obj2 

