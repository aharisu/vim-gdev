
;;;;;
;;@type cmd
;;@@parse-relative #f


;;;;;
;;@type Function
;;@name call/pc
;;@description これはshiftのラッパーです。
;;(shift k expr ...)は(call/pc (lambda (k) expr ...))
;;等価です。call/ccと似た形の呼び出し形式の方が便利な場合があるので
;;用意しました。
;;
;;@param proc 

;;;;;
;;@type Macro
;;@name shift
;;@description この式からもっとも最近のresetにより切り取られた空の継続までの継続を
;;手続きに包み、それをvarに束縛します。
;;そしてもっとも最近のreset式の継続を伴ってexpr ...を実行します。
;;
;;すなわち、expr ...を実行後、その結果の値はもっとも最近のreset
;;の戻り値を待っている式に直ちに渡されます。
;;varに束縛されている部分継続が実行されると、それに渡された値は
;;shiftの戻り値を待っている継続に直ちに渡されます。
;;その部分継続の実行が終了すると、その結果の値はvarを呼び出した式の
;;戻り値となります。
;;
;;@param var 
;;@param expr 
;;@param ... 

;;;;;
;;@type Macro
;;@name reset
;;@description 現在の継続を保存し、expr ... を空の継続を伴って実行します。
;;空の継続はshiftオペレータが捕捉する継続の終端になります。
;;
;;暗黙の限定継続について:
;;Gaucheは内部的に、reset相当の操作を行う場合があります。
;;CルーチンがSchemeを継続渡し形式でない方法で呼び出す場合です。
;;(C APIをご存知の方へ: Scm_EvalRec(), Scm_Apply*Rec(),
;;Scm_Eval()、およびScm_Apply()が相当する関数です。)
;;これらの関数はCの呼び出し側へ、値をたかだか1度だけ返すことが期待されています。
;;Schemeの継続は無限エクステントを持ち、一度返ったルーチンから再び返ることが
;;あり得るため、こういったC関数とは相性が良くありません。
;;これらの関数を呼び出す時に、Gaucheは限定継続を自動的に作成します。
;;
;;例えば、goshのmain関数はSchemeのREPLを
;;Scm_Eval()を通じて呼び出します。ということは、
;;REPL全体がresetで囲まれているということです。
;;従ってresetの外側でshiftを呼び出すと、そのshiftの
;;継続はREPL全体の継続と同じになります。すなわち、goshが終了するということです。
;;暗黙の限定継続に気づかないと、この振る舞いにはびっくりするかもしれません。
;;
;;他に暗黙の限定継続が作られる例をいくつかあげます。
;;仮想ポートのハンドラ (Virtual ports参照)、
;;writeやdisplayから呼ばれるobject-applyメソッド、
;;glut-display-funcにより登録されたGUIコールバック
;;(詳しくはGauche-glのマニュアル参照)などです。
;;
;;そのような暗黙の限定継続を心配する必要は滅多にありません。Cで実装された
;;組み込み関数や拡張関数のほとんどは継続渡し形式でSchemeを呼んでいるため、
;;通常継続も限定継続も制限なく使うことができます。
;;
;;@param expr 
;;@param ... 

